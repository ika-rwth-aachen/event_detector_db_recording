<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>event_detector_db_recording_plugin: basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">event_detector_db_recording_plugin<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbasic__json-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>namespace for Niels Lohmann  
 <a href="classbasic__json.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="json_8hpp_source.html">json.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aea7fcb38964d53d35e84a80b8b1e8d11" id="r_aea7fcb38964d53d35e84a80b8b1e8d11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aea7fcb38964d53d35e84a80b8b1e8d11">value_t</a> = <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td></tr>
<tr class="separator:aea7fcb38964d53d35e84a80b8b1e8d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7e3533ab09b9e9d24a516379961a93" id="r_a7c7e3533ab09b9e9d24a516379961a93"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> = ::nlohmann::json_pointer&lt; StringType &gt;</td></tr>
<tr class="memdesc:a7c7e3533ab09b9e9d24a516379961a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON Pointer, see nlohmann::json_pointer.  <br /></td></tr>
<tr class="separator:a7c7e3533ab09b9e9d24a516379961a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8738738b9e5c4cdc6519e3799de38a" id="r_a5e8738738b9e5c4cdc6519e3799de38a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SFINAE &gt; </td></tr>
<tr class="memitem:a5e8738738b9e5c4cdc6519e3799de38a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5e8738738b9e5c4cdc6519e3799de38a">json_serializer</a> = JSONSerializer&lt; T, SFINAE &gt;</td></tr>
<tr class="separator:a5e8738738b9e5c4cdc6519e3799de38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc0836764d6ba2580ee0c775ceeeab7" id="r_abbc0836764d6ba2580ee0c775ceeeab7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abbc0836764d6ba2580ee0c775ceeeab7">error_handler_t</a> = <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td></tr>
<tr class="memdesc:abbc0836764d6ba2580ee0c775ceeeab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat decoding errors  <br /></td></tr>
<tr class="separator:abbc0836764d6ba2580ee0c775ceeeab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2373759df24fffb094fd7789c726abe1" id="r_a2373759df24fffb094fd7789c726abe1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2373759df24fffb094fd7789c726abe1">cbor_tag_handler_t</a> = <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td></tr>
<tr class="memdesc:a2373759df24fffb094fd7789c726abe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to treat CBOR tags  <br /></td></tr>
<tr class="separator:a2373759df24fffb094fd7789c726abe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2063ed828cd027216c549ac48527a562" id="r_a2063ed828cd027216c549ac48527a562"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> = std::initializer_list&lt; <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a2063ed828cd027216c549ac48527a562"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> values  <br /></td></tr>
<tr class="separator:a2063ed828cd027216c549ac48527a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcf8e1a03522bf1ea9bb6fb49251dab" id="r_a0bcf8e1a03522bf1ea9bb6fb49251dab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0bcf8e1a03522bf1ea9bb6fb49251dab">input_format_t</a> = detail::input_format_t</td></tr>
<tr class="separator:a0bcf8e1a03522bf1ea9bb6fb49251dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c291e7719ceccef199189e5ee4ecd4f" id="r_a0c291e7719ceccef199189e5ee4ecd4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0c291e7719ceccef199189e5ee4ecd4f">json_sax_t</a> = <a class="el" href="structjson__sax.html">json_sax</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a0c291e7719ceccef199189e5ee4ecd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAX interface type, see nlohmann::json_sax.  <br /></td></tr>
<tr class="separator:a0c291e7719ceccef199189e5ee4ecd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe811a234bbc90f4a0d3c6488272186" id="r_adfe811a234bbc90f4a0d3c6488272186"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adfe811a234bbc90f4a0d3c6488272186">parse_event_t</a> = detail::parse_event_t</td></tr>
<tr class="memdesc:adfe811a234bbc90f4a0d3c6488272186"><td class="mdescLeft">&#160;</td><td class="mdescRight">parser event types  <br /></td></tr>
<tr class="separator:adfe811a234bbc90f4a0d3c6488272186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c201819ed5c9d9f58b59eb64fb454" id="r_a144c201819ed5c9d9f58b59eb64fb454"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a144c201819ed5c9d9f58b59eb64fb454">parser_callback_t</a> = detail::parser_callback_t&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a144c201819ed5c9d9f58b59eb64fb454"><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element parser callback type  <br /></td></tr>
<tr class="separator:a144c201819ed5c9d9f58b59eb64fb454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7528ae3cfe082b3e6280eb5dfab4700b" id="r_a7528ae3cfe082b3e6280eb5dfab4700b"><td class="memItemLeft" align="right" valign="top">JSON_HEDLEY_RETURNS_NON_NULL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a> () const noexcept</td></tr>
<tr class="memdesc:a7528ae3cfe082b3e6280eb5dfab4700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type as string  <br /></td></tr>
<tr class="separator:a7528ae3cfe082b3e6280eb5dfab4700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1aaddd9686fb1dd50203c2138858df7e" id="r_a1aaddd9686fb1dd50203c2138858df7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1aaddd9686fb1dd50203c2138858df7e">get_allocator</a> ()</td></tr>
<tr class="memdesc:a1aaddd9686fb1dd50203c2138858df7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the allocator associated with the container  <br /></td></tr>
<tr class="separator:a1aaddd9686fb1dd50203c2138858df7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08303da85f75965764bb0c8d8b79a449" id="r_a08303da85f75965764bb0c8d8b79a449"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08303da85f75965764bb0c8d8b79a449">meta</a> ()</td></tr>
<tr class="memdesc:a08303da85f75965764bb0c8d8b79a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns version information on the library  <br /></td></tr>
<tr class="separator:a08303da85f75965764bb0c8d8b79a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae76ffa6335685fa38190a18806d55" id="r_a2eae76ffa6335685fa38190a18806d55"><td class="memItemLeft" align="right" valign="top">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool static SAX bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2eae76ffa6335685fa38190a18806d55">sax_parse</a> (InputType &amp;&amp;i, SAX *sax, input_format_t format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="separator:a2eae76ffa6335685fa38190a18806d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2094d16fe8fd49c20eca61fa88d602" id="r_a4e2094d16fe8fd49c20eca61fa88d602"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , class SAX &gt; </td></tr>
<tr class="memitem:a4e2094d16fe8fd49c20eca61fa88d602"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4e2094d16fe8fd49c20eca61fa88d602">sax_parse</a> (IteratorType first, IteratorType last, SAX *sax, input_format_t format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a4e2094d16fe8fd49c20eca61fa88d602"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <br /></td></tr>
<tr class="separator:a4e2094d16fe8fd49c20eca61fa88d602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ab4a7073c479bb1ef24c23c3d3d67" id="r_a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memTemplParams" colspan="2">template&lt;typename SAX &gt; </td></tr>
<tr class="memitem:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a696ab4a7073c479bb1ef24c23c3d3d67">sax_parse</a> (detail::span_input_adapter &amp;&amp;i, SAX *sax, input_format_t format=input_format_t::json, const bool strict=true, const bool ignore_comments=false)</td></tr>
<tr class="memdesc:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SAX events  <br /></td></tr>
<tr class="separator:a696ab4a7073c479bb1ef24c23c3d3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aba63131a6c69e3f5121632d496c9b708" id="r_aba63131a6c69e3f5121632d496c9b708"><td class="memItemLeft" align="right" valign="top">JSON_PRIVATE_UNLESS_TESTED&#160;</td><td class="memItemRight" valign="bottom">: <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> m_type = value_t::null</td></tr>
<tr class="separator:aba63131a6c69e3f5121632d496c9b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34bc6074bd3f9ac2bdab12ebc02d70f5" id="r_a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="memItemLeft" align="right" valign="top">json_value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = {}</td></tr>
<tr class="memdesc:a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the value of the current element  <br /></td></tr>
<tr class="separator:a34bc6074bd3f9ac2bdab12ebc02d70f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c" id="r_a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a> &gt; </td></tr>
<tr class="memitem:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6275ed57bae6866cdf5db5370a7ad47c">detail::external_constructor</a></td></tr>
<tr class="separator:a6275ed57bae6866cdf5db5370a7ad47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233" id="r_a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a43f901b14cf3f7135269b0c75c9ac233"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a43f901b14cf3f7135269b0c75c9ac233">::nlohmann::json_pointer</a></td></tr>
<tr class="separator:a43f901b14cf3f7135269b0c75c9ac233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf" id="r_ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType &gt; </td></tr>
<tr class="memitem:ac8f3125911eb018ef4ab00d879487baf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8f3125911eb018ef4ab00d879487baf">::nlohmann::detail::parser</a></td></tr>
<tr class="separator:ac8f3125911eb018ef4ab00d879487baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4" id="r_a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a842e5c7ca096025c18b11e715d3401f4"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a842e5c7ca096025c18b11e715d3401f4">::nlohmann::detail::iter_impl</a></td></tr>
<tr class="separator:a842e5c7ca096025c18b11e715d3401f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf" id="r_a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename CharType &gt; </td></tr>
<tr class="memitem:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a69d491bbda88ade6d3c7a2b11309e8bf">::nlohmann::detail::binary_writer</a></td></tr>
<tr class="separator:a69d491bbda88ade6d3c7a2b11309e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b" id="r_aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </td></tr>
<tr class="memitem:aa226ed5103dfd10e27e562d35a3a106b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa226ed5103dfd10e27e562d35a3a106b">::nlohmann::detail::binary_reader</a></td></tr>
<tr class="separator:aa226ed5103dfd10e27e562d35a3a106b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60" id="r_a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a47aabb1eceae32e8a6e8e7f0ff34be60">::nlohmann::detail::json_sax_dom_parser</a></td></tr>
<tr class="separator:a47aabb1eceae32e8a6e8e7f0ff34be60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da" id="r_a95574da8d12905ea99dc348934c837da"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType &gt; </td></tr>
<tr class="memitem:a95574da8d12905ea99dc348934c837da"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a95574da8d12905ea99dc348934c837da">::nlohmann::detail::json_sax_dom_callback_parser</a></td></tr>
<tr class="separator:a95574da8d12905ea99dc348934c837da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcb15d025676b4d3db0f32a50f4393f" id="r_abdcb15d025676b4d3db0f32a50f4393f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abdcb15d025676b4d3db0f32a50f4393f">::nlohmann::detail::exception</a></td></tr>
<tr class="separator:abdcb15d025676b4d3db0f32a50f4393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9907af448f7ff794120033e132025f6" id="r_af9907af448f7ff794120033e132025f6"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af9907af448f7ff794120033e132025f6">operator&lt;&lt;</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;j, std::istream &amp;i)</td></tr>
<tr class="memdesc:af9907af448f7ff794120033e132025f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <br /></td></tr>
<tr class="separator:af9907af448f7ff794120033e132025f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0de29387d532e0bc5f2475cb83995d" id="r_aea0de29387d532e0bc5f2475cb83995d"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:aea0de29387d532e0bc5f2475cb83995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize from stream  <br /></td></tr>
<tr class="separator:aea0de29387d532e0bc5f2475cb83995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">element access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Access to the JSON value. </p>
</td></tr>
<tr class="memitem:a603779687f401ad11de45f8397f92296" id="r_a603779687f401ad11de45f8397f92296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:a603779687f401ad11de45f8397f92296"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <br /></td></tr>
<tr class="separator:a603779687f401ad11de45f8397f92296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e6b7245d17021327eb3962d73ccc54" id="r_a98e6b7245d17021327eb3962d73ccc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a98e6b7245d17021327eb3962d73ccc54">at</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx) const</td></tr>
<tr class="memdesc:a98e6b7245d17021327eb3962d73ccc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element with bounds checking  <br /></td></tr>
<tr class="separator:a98e6b7245d17021327eb3962d73ccc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf1894e1b70a4caebd95adec60e845a" id="r_aedf1894e1b70a4caebd95adec60e845a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aedf1894e1b70a4caebd95adec60e845a">at</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:aedf1894e1b70a4caebd95adec60e845a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <br /></td></tr>
<tr class="separator:aedf1894e1b70a4caebd95adec60e845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc69e86b65aa8b571ccad9d581ca5a2b" id="r_afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afc69e86b65aa8b571ccad9d581ca5a2b">at</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <br /></td></tr>
<tr class="separator:afc69e86b65aa8b571ccad9d581ca5a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32b953a4e343dc7f8ab3465743f399" id="r_afc32b953a4e343dc7f8ab3465743f399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afc32b953a4e343dc7f8ab3465743f399">at</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:afc32b953a4e343dc7f8ab3465743f399"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <br /></td></tr>
<tr class="separator:afc32b953a4e343dc7f8ab3465743f399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee87279fb115f6d57967e6e8f5542faa" id="r_aee87279fb115f6d57967e6e8f5542faa"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aee87279fb115f6d57967e6e8f5542faa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee87279fb115f6d57967e6e8f5542faa">at</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:aee87279fb115f6d57967e6e8f5542faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with bounds checking  <br /></td></tr>
<tr class="separator:aee87279fb115f6d57967e6e8f5542faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dfeae16fa9a8ec1390a27d6a4a58b3" id="r_aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">operator[]</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <br /></td></tr>
<tr class="separator:aa3dfeae16fa9a8ec1390a27d6a4a58b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61677841384622af7c3174f3f10df621" id="r_a61677841384622af7c3174f3f10df621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a61677841384622af7c3174f3f10df621">operator[]</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx) const</td></tr>
<tr class="memdesc:a61677841384622af7c3174f3f10df621"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified array element  <br /></td></tr>
<tr class="separator:a61677841384622af7c3174f3f10df621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272177c4eb206c70f41e35146915b710" id="r_a272177c4eb206c70f41e35146915b710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a272177c4eb206c70f41e35146915b710">operator[]</a> (typename object_t::key_type key)</td></tr>
<tr class="memdesc:a272177c4eb206c70f41e35146915b710"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <br /></td></tr>
<tr class="separator:a272177c4eb206c70f41e35146915b710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b78559cad28275bc515bb2a072605" id="r_af57b78559cad28275bc515bb2a072605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af57b78559cad28275bc515bb2a072605">operator[]</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:af57b78559cad28275bc515bb2a072605"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <br /></td></tr>
<tr class="separator:af57b78559cad28275bc515bb2a072605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb748eeb63f40f12f81f9e9c5d53d127" id="r_abb748eeb63f40f12f81f9e9c5d53d127"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb748eeb63f40f12f81f9e9c5d53d127"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abb748eeb63f40f12f81f9e9c5d53d127">operator[]</a> (T *key)</td></tr>
<tr class="separator:abb748eeb63f40f12f81f9e9c5d53d127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e43d3f7092719836ac3e8249044bb6" id="r_a19e43d3f7092719836ac3e8249044bb6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19e43d3f7092719836ac3e8249044bb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a19e43d3f7092719836ac3e8249044bb6">operator[]</a> (T *key) const</td></tr>
<tr class="separator:a19e43d3f7092719836ac3e8249044bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7e1bd642902ec90f118f00d48c024d" id="r_a5a7e1bd642902ec90f118f00d48c024d"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5a7e1bd642902ec90f118f00d48c024d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a7e1bd642902ec90f118f00d48c024d">operator[]</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a5a7e1bd642902ec90f118f00d48c024d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <br /></td></tr>
<tr class="separator:a5a7e1bd642902ec90f118f00d48c024d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb04aaee2ee66a6c822aaad827123314" id="r_afb04aaee2ee66a6c822aaad827123314"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afb04aaee2ee66a6c822aaad827123314"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afb04aaee2ee66a6c822aaad827123314">operator[]</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:afb04aaee2ee66a6c822aaad827123314"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element  <br /></td></tr>
<tr class="separator:afb04aaee2ee66a6c822aaad827123314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb507ac4a659d45a9ccdfb67a0646ec" id="r_a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">value</a> (const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <br /></td></tr>
<tr class="separator:a3fb507ac4a659d45a9ccdfb67a0646ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460a0f28bedca9050f2259ec6bf86e6" id="r_a1460a0f28bedca9050f2259ec6bf86e6"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1460a0f28bedca9050f2259ec6bf86e6"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1460a0f28bedca9050f2259ec6bf86e6">value</a> (const typename object_t::key_type &amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:a1460a0f28bedca9050f2259ec6bf86e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <br /></td></tr>
<tr class="separator:a1460a0f28bedca9050f2259ec6bf86e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58469bce489ece80e50e7ed59fa09484" id="r_a58469bce489ece80e50e7ed59fa09484"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a58469bce489ece80e50e7ed59fa09484"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a58469bce489ece80e50e7ed59fa09484">value</a> (KeyType &amp;&amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a58469bce489ece80e50e7ed59fa09484"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element with default value  <br /></td></tr>
<tr class="separator:a58469bce489ece80e50e7ed59fa09484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d24993dea7dcd5442465e43b0554cb" id="r_ac7d24993dea7dcd5442465e43b0554cb"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac7d24993dea7dcd5442465e43b0554cb"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac7d24993dea7dcd5442465e43b0554cb">value</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:ac7d24993dea7dcd5442465e43b0554cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <br /></td></tr>
<tr class="separator:ac7d24993dea7dcd5442465e43b0554cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07f0a0e66b05e7b77b95f623cbfac1" id="r_a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memTemplParams" colspan="2">template&lt;class ValueType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8e07f0a0e66b05e7b77b95f623cbfac1">value</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <br /></td></tr>
<tr class="separator:a8e07f0a0e66b05e7b77b95f623cbfac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435aab4d160572776d7e66c3809e4b1" id="r_af435aab4d160572776d7e66c3809e4b1"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af435aab4d160572776d7e66c3809e4b1"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af435aab4d160572776d7e66c3809e4b1">value</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="memdesc:af435aab4d160572776d7e66c3809e4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified object element via JSON Pointer with default value  <br /></td></tr>
<tr class="separator:af435aab4d160572776d7e66c3809e4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7141baa06e635fe37736659a9f1631" id="r_a6c7141baa06e635fe37736659a9f1631"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6c7141baa06e635fe37736659a9f1631"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6c7141baa06e635fe37736659a9f1631">value</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr, const ValueType &amp;default_value) const</td></tr>
<tr class="separator:a6c7141baa06e635fe37736659a9f1631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ea0e7032d5697076d3f2faf318af18" id="r_aa5ea0e7032d5697076d3f2faf318af18"><td class="memTemplParams" colspan="2">template&lt;class ValueType , class BasicJsonType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa5ea0e7032d5697076d3f2faf318af18"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa5ea0e7032d5697076d3f2faf318af18">value</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr, ValueType &amp;&amp;default_value) const</td></tr>
<tr class="separator:aa5ea0e7032d5697076d3f2faf318af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6f631d1a7f8f23772434f22a06108e" id="r_aeb6f631d1a7f8f23772434f22a06108e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeb6f631d1a7f8f23772434f22a06108e">front</a> ()</td></tr>
<tr class="memdesc:aeb6f631d1a7f8f23772434f22a06108e"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <br /></td></tr>
<tr class="separator:aeb6f631d1a7f8f23772434f22a06108e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85577855985468abef750d5265e23c2a" id="r_a85577855985468abef750d5265e23c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85577855985468abef750d5265e23c2a">front</a> () const</td></tr>
<tr class="memdesc:a85577855985468abef750d5265e23c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the first element  <br /></td></tr>
<tr class="separator:a85577855985468abef750d5265e23c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafea743a0a74f86433b8b7cc5bb24bf" id="r_adafea743a0a74f86433b8b7cc5bb24bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adafea743a0a74f86433b8b7cc5bb24bf">back</a> ()</td></tr>
<tr class="memdesc:adafea743a0a74f86433b8b7cc5bb24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <br /></td></tr>
<tr class="separator:adafea743a0a74f86433b8b7cc5bb24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf48c36e00720e01f8f6bbd3df0bf5b" id="r_a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1bf48c36e00720e01f8f6bbd3df0bf5b">back</a> () const</td></tr>
<tr class="memdesc:a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the last element  <br /></td></tr>
<tr class="separator:a1bf48c36e00720e01f8f6bbd3df0bf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5ed019983b582705ef5ee43d15ca24" id="r_a7a5ed019983b582705ef5ee43d15ca24"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7a5ed019983b582705ef5ee43d15ca24"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">erase</a> (IteratorType pos)</td></tr>
<tr class="memdesc:a7a5ed019983b582705ef5ee43d15ca24"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element given an iterator  <br /></td></tr>
<tr class="separator:a7a5ed019983b582705ef5ee43d15ca24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151124c5b91ecb1278c7e191053ce9ca" id="r_a151124c5b91ecb1278c7e191053ce9ca"><td class="memTemplParams" colspan="2">template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a151124c5b91ecb1278c7e191053ce9ca"><td class="memTemplItemLeft" align="right" valign="top">IteratorType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a151124c5b91ecb1278c7e191053ce9ca">erase</a> (IteratorType first, IteratorType last)</td></tr>
<tr class="memdesc:a151124c5b91ecb1278c7e191053ce9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove elements given an iterator range  <br /></td></tr>
<tr class="separator:a151124c5b91ecb1278c7e191053ce9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d29d171d8941523a937bb6b5132b5a7" id="r_a8d29d171d8941523a937bb6b5132b5a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d29d171d8941523a937bb6b5132b5a7">erase</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a8d29d171d8941523a937bb6b5132b5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <br /></td></tr>
<tr class="separator:a8d29d171d8941523a937bb6b5132b5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3054e673f67fa325fbdcd0bf73d03c7b" id="r_a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3054e673f67fa325fbdcd0bf73d03c7b">erase</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON object given a key  <br /></td></tr>
<tr class="separator:a3054e673f67fa325fbdcd0bf73d03c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e480e9d2391485c79747bb756628f61" id="r_a0e480e9d2391485c79747bb756628f61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0e480e9d2391485c79747bb756628f61">erase</a> (const <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> idx)</td></tr>
<tr class="memdesc:a0e480e9d2391485c79747bb756628f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove element from a JSON array given an index  <br /></td></tr>
<tr class="separator:a0e480e9d2391485c79747bb756628f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">exceptions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Classes to implement user-defined exceptions. </p>
</td></tr>
<tr class="memitem:ab671bd0e5eef59e58d362e6cd8937633" id="r_ab671bd0e5eef59e58d362e6cd8937633"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab671bd0e5eef59e58d362e6cd8937633">exception</a> = <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td></tr>
<tr class="separator:ab671bd0e5eef59e58d362e6cd8937633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da064d46469bb762afcecd1c361f1a" id="r_ab0da064d46469bb762afcecd1c361f1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab0da064d46469bb762afcecd1c361f1a">parse_error</a> = <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td></tr>
<tr class="separator:ab0da064d46469bb762afcecd1c361f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbe40f1942d8e38ab2effc7988b05ea" id="r_a9dbe40f1942d8e38ab2effc7988b05ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9dbe40f1942d8e38ab2effc7988b05ea">invalid_iterator</a> = <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td></tr>
<tr class="separator:a9dbe40f1942d8e38ab2effc7988b05ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db56e21a2c72186979c6f6f0469557" id="r_a14db56e21a2c72186979c6f6f0469557"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a14db56e21a2c72186979c6f6f0469557">type_error</a> = <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td></tr>
<tr class="separator:a14db56e21a2c72186979c6f6f0469557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144d3cb5914a0a12c2f5d2b982a2214a" id="r_a144d3cb5914a0a12c2f5d2b982a2214a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a144d3cb5914a0a12c2f5d2b982a2214a">out_of_range</a> = <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td></tr>
<tr class="separator:a144d3cb5914a0a12c2f5d2b982a2214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ef54e2baf390523dd6a5bc4ccccef" id="r_aab2ef54e2baf390523dd6a5bc4ccccef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aab2ef54e2baf390523dd6a5bc4ccccef">other_error</a> = <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td></tr>
<tr class="separator:aab2ef54e2baf390523dd6a5bc4ccccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">container types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The canonic container types to use <a class="el" href="classbasic__json.html">basic_json</a> like any other STL container. </p>
</td></tr>
<tr class="memitem:ad9e6b75c7cc0db798b91e52edca5f4ca" id="r_ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> = <a class="el" href="classbasic__json.html">basic_json</a></td></tr>
<tr class="memdesc:ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <br /></td></tr>
<tr class="separator:ad9e6b75c7cc0db798b91e52edca5f4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f366d506aca733799e4c310927b5d" id="r_aa95f366d506aca733799e4c310927b5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> = <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> &amp;</td></tr>
<tr class="memdesc:aa95f366d506aca733799e4c310927b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element reference  <br /></td></tr>
<tr class="separator:aa95f366d506aca733799e4c310927b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d32cf719260c22b33bab670cd5602b" id="r_ac9d32cf719260c22b33bab670cd5602b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> = const <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a> &amp;</td></tr>
<tr class="memdesc:ac9d32cf719260c22b33bab670cd5602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const reference  <br /></td></tr>
<tr class="separator:ac9d32cf719260c22b33bab670cd5602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe32d636c1b78861884dde9716b22b6" id="r_a2fe32d636c1b78861884dde9716b22b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">difference_type</a> = std::ptrdiff_t</td></tr>
<tr class="memdesc:a2fe32d636c1b78861884dde9716b22b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent differences between iterators  <br /></td></tr>
<tr class="separator:a2fe32d636c1b78861884dde9716b22b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883ac4726a370dbf98474944ec0a0acc" id="r_a883ac4726a370dbf98474944ec0a0acc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a883ac4726a370dbf98474944ec0a0acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type to represent container sizes  <br /></td></tr>
<tr class="separator:a883ac4726a370dbf98474944ec0a0acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485873eed243b6ca7e30c96130a5ec2d" id="r_a485873eed243b6ca7e30c96130a5ec2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> = AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a485873eed243b6ca7e30c96130a5ec2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the allocator type  <br /></td></tr>
<tr class="separator:a485873eed243b6ca7e30c96130a5ec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a5d1bf4e9cd1bdec90e97f4ea6f95" id="r_ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac02a5d1bf4e9cd1bdec90e97f4ea6f95">pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> &gt;::pointer</td></tr>
<tr class="memdesc:ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element pointer  <br /></td></tr>
<tr class="separator:ac02a5d1bf4e9cd1bdec90e97f4ea6f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ac2566e6ab084c5c1e044d132aa4a3" id="r_a28ac2566e6ab084c5c1e044d132aa4a3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a28ac2566e6ab084c5c1e044d132aa4a3">const_pointer</a> = typename std::allocator_traits&lt; <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> &gt;::const_pointer</td></tr>
<tr class="memdesc:a28ac2566e6ab084c5c1e044d132aa4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of an element const pointer  <br /></td></tr>
<tr class="separator:a28ac2566e6ab084c5c1e044d132aa4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2935c91b82c8e586b1dd68ad665075a6" id="r_a2935c91b82c8e586b1dd68ad665075a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> = iter_impl&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a2935c91b82c8e586b1dd68ad665075a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <br /></td></tr>
<tr class="separator:a2935c91b82c8e586b1dd68ad665075a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3470194c24d964e40d9be0b177cbc3" id="r_a8f3470194c24d964e40d9be0b177cbc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> = iter_impl&lt; const <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a8f3470194c24d964e40d9be0b177cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <br /></td></tr>
<tr class="separator:a8f3470194c24d964e40d9be0b177cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac639cd1b4238d158286e7e21b5829709" id="r_ac639cd1b4238d158286e7e21b5829709"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">basic_json::iterator</a> &gt;</td></tr>
<tr class="memdesc:ac639cd1b4238d158286e7e21b5829709"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <br /></td></tr>
<tr class="separator:ac639cd1b4238d158286e7e21b5829709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7d4c7719ab82aa8c77a83642c843f" id="r_a2aa7d4c7719ab82aa8c77a83642c843f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> = json_reverse_iterator&lt; typename <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">basic_json::const_iterator</a> &gt;</td></tr>
<tr class="memdesc:a2aa7d4c7719ab82aa8c77a83642c843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container  <br /></td></tr>
<tr class="separator:a2aa7d4c7719ab82aa8c77a83642c843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON value data types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The data types to store a JSON value. These types are derived from the template arguments passed to class <a class="el" href="classbasic__json.html">basic_json</a>. </p>
</td></tr>
<tr class="memitem:af2fea7b2039e4308b8e8c22a0dd5b570" id="r_af2fea7b2039e4308b8e8c22a0dd5b570"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a> = std::less&lt; StringType &gt;</td></tr>
<tr class="memdesc:af2fea7b2039e4308b8e8c22a0dd5b570"><td class="mdescLeft">&#160;</td><td class="mdescRight">default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a>) may be different.  <br /></td></tr>
<tr class="separator:af2fea7b2039e4308b8e8c22a0dd5b570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770279b71f788fe3f76411eedf5b1956" id="r_a770279b71f788fe3f76411eedf5b1956"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> = ObjectType&lt; StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a>, AllocatorType&lt; std::pair&lt; const StringType, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a770279b71f788fe3f76411eedf5b1956"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an object  <br /></td></tr>
<tr class="separator:a770279b71f788fe3f76411eedf5b1956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf28eb944e7c06aa47f0bc3a9d6f454" id="r_a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> = ArrayType&lt; <a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;</td></tr>
<tr class="memdesc:a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for an array  <br /></td></tr>
<tr class="separator:a7cf28eb944e7c06aa47f0bc3a9d6f454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807932caebf0d62abc8642b9d1a2e5ef" id="r_a807932caebf0d62abc8642b9d1a2e5ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> = StringType</td></tr>
<tr class="memdesc:a807932caebf0d62abc8642b9d1a2e5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a string  <br /></td></tr>
<tr class="separator:a807932caebf0d62abc8642b9d1a2e5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af396ac808d774d4ea0db4c7da11ce569" id="r_af396ac808d774d4ea0db4c7da11ce569"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af396ac808d774d4ea0db4c7da11ce569">boolean_t</a> = BooleanType</td></tr>
<tr class="memdesc:af396ac808d774d4ea0db4c7da11ce569"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a boolean  <br /></td></tr>
<tr class="separator:af396ac808d774d4ea0db4c7da11ce569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b702448867b892700c768db4208a670" id="r_a8b702448867b892700c768db4208a670"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8b702448867b892700c768db4208a670">number_integer_t</a> = NumberIntegerType</td></tr>
<tr class="memdesc:a8b702448867b892700c768db4208a670"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (integer)  <br /></td></tr>
<tr class="separator:a8b702448867b892700c768db4208a670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb9c6a13e947a86e2a13fbe6ebd77f4" id="r_aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aebb9c6a13e947a86e2a13fbe6ebd77f4">number_unsigned_t</a> = NumberUnsignedType</td></tr>
<tr class="memdesc:aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (unsigned)  <br /></td></tr>
<tr class="separator:aebb9c6a13e947a86e2a13fbe6ebd77f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd24dfabbdd1dc35513c82244633ca4" id="r_a1fd24dfabbdd1dc35513c82244633ca4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1fd24dfabbdd1dc35513c82244633ca4">number_float_t</a> = NumberFloatType</td></tr>
<tr class="memdesc:a1fd24dfabbdd1dc35513c82244633ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a number (floating-point)  <br /></td></tr>
<tr class="separator:a1fd24dfabbdd1dc35513c82244633ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabedd827d4943302a4cf0413956341db" id="r_aabedd827d4943302a4cf0413956341db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> = nlohmann::byte_container_with_subtype&lt; BinaryType &gt;</td></tr>
<tr class="memdesc:aabedd827d4943302a4cf0413956341db"><td class="mdescLeft">&#160;</td><td class="mdescRight">a type for a packed binary type  <br /></td></tr>
<tr class="separator:aabedd827d4943302a4cf0413956341db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866de66dd6c55590efa7cf0ef79e74f" id="r_a7866de66dd6c55590efa7cf0ef79e74f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> = detail::actual_object_comparator_t&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt;</td></tr>
<tr class="memdesc:a7866de66dd6c55590efa7cf0ef79e74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">object key comparator type  <br /></td></tr>
<tr class="separator:a7866de66dd6c55590efa7cf0ef79e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">modifiers</h2></td></tr>
<tr class="memitem:aee0ae36cbfb0336832ebc0374c3c7679" id="r_aee0ae36cbfb0336832ebc0374c3c7679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a> (<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> left, <a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> right) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:aee0ae36cbfb0336832ebc0374c3c7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:aee0ae36cbfb0336832ebc0374c3c7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5145a99de8435876192b70378afe097" id="r_ac5145a99de8435876192b70378afe097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac5145a99de8435876192b70378afe097">clear</a> () noexcept</td></tr>
<tr class="memdesc:ac5145a99de8435876192b70378afe097"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the contents  <br /></td></tr>
<tr class="separator:ac5145a99de8435876192b70378afe097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dd9991cbc1c10d35987680038f6359" id="r_ae9dd9991cbc1c10d35987680038f6359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ae9dd9991cbc1c10d35987680038f6359"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <br /></td></tr>
<tr class="separator:ae9dd9991cbc1c10d35987680038f6359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042aa42f535d1dbf2176d159fd3d96eb" id="r_a042aa42f535d1dbf2176d159fd3d96eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a042aa42f535d1dbf2176d159fd3d96eb">operator+=</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a042aa42f535d1dbf2176d159fd3d96eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <br /></td></tr>
<tr class="separator:a042aa42f535d1dbf2176d159fd3d96eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102e459f1d163cea963ed6fdda595cd3" id="r_a102e459f1d163cea963ed6fdda595cd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a102e459f1d163cea963ed6fdda595cd3">push_back</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a102e459f1d163cea963ed6fdda595cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <br /></td></tr>
<tr class="separator:a102e459f1d163cea963ed6fdda595cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf3e602301f1b9fc81c445c8f3bd1a" id="r_afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#afbbf3e602301f1b9fc81c445c8f3bd1a">operator+=</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <br /></td></tr>
<tr class="separator:afbbf3e602301f1b9fc81c445c8f3bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efb88d640b634b77af5825321e6c4ba" id="r_a4efb88d640b634b77af5825321e6c4ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4efb88d640b634b77af5825321e6c4ba">push_back</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a4efb88d640b634b77af5825321e6c4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <br /></td></tr>
<tr class="separator:a4efb88d640b634b77af5825321e6c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024a7d334069a60f8cb95c3f858fc9e6" id="r_a024a7d334069a60f8cb95c3f858fc9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a024a7d334069a60f8cb95c3f858fc9e6">operator+=</a> (const typename object_t::value_type &amp;val)</td></tr>
<tr class="memdesc:a024a7d334069a60f8cb95c3f858fc9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <br /></td></tr>
<tr class="separator:a024a7d334069a60f8cb95c3f858fc9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabd8c4eea861419dc2629610a922e97" id="r_adabd8c4eea861419dc2629610a922e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adabd8c4eea861419dc2629610a922e97">push_back</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:adabd8c4eea861419dc2629610a922e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <br /></td></tr>
<tr class="separator:adabd8c4eea861419dc2629610a922e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3350669b0628bf54a4771512a55f135" id="r_ae3350669b0628bf54a4771512a55f135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ae3350669b0628bf54a4771512a55f135">operator+=</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init)</td></tr>
<tr class="memdesc:ae3350669b0628bf54a4771512a55f135"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object  <br /></td></tr>
<tr class="separator:ae3350669b0628bf54a4771512a55f135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad89dd8715111483428ecf8534b9393" id="r_a7ad89dd8715111483428ecf8534b9393"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a7ad89dd8715111483428ecf8534b9393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7ad89dd8715111483428ecf8534b9393">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7ad89dd8715111483428ecf8534b9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an array  <br /></td></tr>
<tr class="separator:a7ad89dd8715111483428ecf8534b9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e70795da670f11ad7925407d0a7d83c" id="r_a3e70795da670f11ad7925407d0a7d83c"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3e70795da670f11ad7925407d0a7d83c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3e70795da670f11ad7925407d0a7d83c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3e70795da670f11ad7925407d0a7d83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an object to an object if key does not exist  <br /></td></tr>
<tr class="separator:a3e70795da670f11ad7925407d0a7d83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6940b08bda32ce195a9e4508b8aa1126" id="r_a6940b08bda32ce195a9e4508b8aa1126"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6940b08bda32ce195a9e4508b8aa1126"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a6940b08bda32ce195a9e4508b8aa1126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467ec0c7679150140f9d2f85e95bf4b" id="r_a4467ec0c7679150140f9d2f85e95bf4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a4467ec0c7679150140f9d2f85e95bf4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <br /></td></tr>
<tr class="separator:a4467ec0c7679150140f9d2f85e95bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd6ab85d95fa08d0fbce5f957834f28" id="r_a5cd6ab85d95fa08d0fbce5f957834f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5cd6ab85d95fa08d0fbce5f957834f28">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a5cd6ab85d95fa08d0fbce5f957834f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts element into array  <br /></td></tr>
<tr class="separator:a5cd6ab85d95fa08d0fbce5f957834f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7b302f4e6249b8b28dcfbebd934600" id="r_a1d7b302f4e6249b8b28dcfbebd934600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1d7b302f4e6249b8b28dcfbebd934600">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:a1d7b302f4e6249b8b28dcfbebd934600"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts copies of element into array  <br /></td></tr>
<tr class="separator:a1d7b302f4e6249b8b28dcfbebd934600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30d7fc224999adeaa9e4dcd81db0f05" id="r_af30d7fc224999adeaa9e4dcd81db0f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af30d7fc224999adeaa9e4dcd81db0f05">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last)</td></tr>
<tr class="memdesc:af30d7fc224999adeaa9e4dcd81db0f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into array  <br /></td></tr>
<tr class="separator:af30d7fc224999adeaa9e4dcd81db0f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b25eeb503c9f30322b966af0451da38" id="r_a3b25eeb503c9f30322b966af0451da38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3b25eeb503c9f30322b966af0451da38">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> pos, <a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> ilist)</td></tr>
<tr class="memdesc:a3b25eeb503c9f30322b966af0451da38"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts elements from initializer list into array  <br /></td></tr>
<tr class="separator:a3b25eeb503c9f30322b966af0451da38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797b7b5589862535c88b9604c88d8d3e" id="r_a797b7b5589862535c88b9604c88d8d3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a797b7b5589862535c88b9604c88d8d3e">insert</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last)</td></tr>
<tr class="memdesc:a797b7b5589862535c88b9604c88d8d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts range of elements into object  <br /></td></tr>
<tr class="separator:a797b7b5589862535c88b9604c88d8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c13ddcc1eb615dc56ebd7cb44791bd" id="r_aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa1c13ddcc1eb615dc56ebd7cb44791bd">update</a> (<a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> j, bool merge_objects=false)</td></tr>
<tr class="memdesc:aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <br /></td></tr>
<tr class="separator:aa1c13ddcc1eb615dc56ebd7cb44791bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db7c9bf454f893d156a7396d527873b" id="r_a2db7c9bf454f893d156a7396d527873b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2db7c9bf454f893d156a7396d527873b">update</a> (<a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> first, <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> last, bool merge_objects=false)</td></tr>
<tr class="memdesc:a2db7c9bf454f893d156a7396d527873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates a JSON object from another object, overwriting existing keys  <br /></td></tr>
<tr class="separator:a2db7c9bf454f893d156a7396d527873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57541a1c736f6ea94fe4a92dd61b3c37" id="r_a57541a1c736f6ea94fe4a92dd61b3c37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a57541a1c736f6ea94fe4a92dd61b3c37">swap</a> (<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:a57541a1c736f6ea94fe4a92dd61b3c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:a57541a1c736f6ea94fe4a92dd61b3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bc171c2ec496dcc63c9035354d1138" id="r_af1bc171c2ec496dcc63c9035354d1138"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af1bc171c2ec496dcc63c9035354d1138">swap</a> (<a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> &amp;other)</td></tr>
<tr class="memdesc:af1bc171c2ec496dcc63c9035354d1138"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:af1bc171c2ec496dcc63c9035354d1138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2061fc20992f76b6fe4a7d2456391b8f" id="r_a2061fc20992f76b6fe4a7d2456391b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2061fc20992f76b6fe4a7d2456391b8f">swap</a> (<a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> &amp;other)</td></tr>
<tr class="memdesc:a2061fc20992f76b6fe4a7d2456391b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:a2061fc20992f76b6fe4a7d2456391b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa914de665383b10bdd6265e6b63b8d93" id="r_aa914de665383b10bdd6265e6b63b8d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa914de665383b10bdd6265e6b63b8d93">swap</a> (<a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> &amp;other)</td></tr>
<tr class="memdesc:aa914de665383b10bdd6265e6b63b8d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:aa914de665383b10bdd6265e6b63b8d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23296c72c9f837e20cfdc28d8018dd57" id="r_a23296c72c9f837e20cfdc28d8018dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a23296c72c9f837e20cfdc28d8018dd57">swap</a> (<a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp;other)</td></tr>
<tr class="memdesc:a23296c72c9f837e20cfdc28d8018dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:a23296c72c9f837e20cfdc28d8018dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ae0a887a94436f43f26c94aa1f748" id="r_a636ae0a887a94436f43f26c94aa1f748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a636ae0a887a94436f43f26c94aa1f748">swap</a> (typename binary_t::container_type &amp;other)</td></tr>
<tr class="memdesc:a636ae0a887a94436f43f26c94aa1f748"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchanges the values  <br /></td></tr>
<tr class="separator:a636ae0a887a94436f43f26c94aa1f748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lexicographical comparison operators</h2></td></tr>
<tr class="memitem:a7e8bca0d3d745150dbaae538443bb626" id="r_a7e8bca0d3d745150dbaae538443bb626"><td class="memItemLeft" align="right" valign="top">JSON_PRIVATE_UNLESS_TESTED&#160;</td><td class="memItemRight" valign="bottom">: static bool compares_unordered(<a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> lhs</td></tr>
<tr class="separator:a7e8bca0d3d745150dbaae538443bb626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f2e1cec130719f862008b9e16acee" id="r_ac83f2e1cec130719f862008b9e16acee"><td class="memItemLeft" align="right" valign="top">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac83f2e1cec130719f862008b9e16acee">rhs</a></td></tr>
<tr class="separator:ac83f2e1cec130719f862008b9e16acee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6a2b3e624ac8772519963bcfb8fb56" id="r_abe6a2b3e624ac8772519963bcfb8fb56"><td class="memItemLeft" align="right" valign="top">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abe6a2b3e624ac8772519963bcfb8fb56">inverse</a></td></tr>
<tr class="separator:abe6a2b3e624ac8772519963bcfb8fb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">value access</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Direct access to the stored value of a JSON value. </p>
</td></tr>
<tr class="memitem:a206a3748ff1fc676f64f753e203388dd" id="r_a206a3748ff1fc676f64f753e203388dd"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a206a3748ff1fc676f64f753e203388dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a206a3748ff1fc676f64f753e203388dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <br /></td></tr>
<tr class="separator:a206a3748ff1fc676f64f753e203388dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2055fcc0c999d3cb4c211f258695faff" id="r_a2055fcc0c999d3cb4c211f258695faff"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a2055fcc0c999d3cb4c211f258695faff"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2055fcc0c999d3cb4c211f258695faff">get_ptr</a> () const noexcept -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().get_impl_ptr(std::declval&lt; PointerType &gt;()))</td></tr>
<tr class="memdesc:a2055fcc0c999d3cb4c211f258695faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (implicit)  <br /></td></tr>
<tr class="separator:a2055fcc0c999d3cb4c211f258695faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11bff397526e8255d151066caeba48e" id="r_ab11bff397526e8255d151066caeba48e"><td class="memTemplParams" colspan="2">template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </td></tr>
<tr class="memitem:ab11bff397526e8255d151066caeba48e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab11bff397526e8255d151066caeba48e">get</a> () const noexcept(noexcept(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))) -&gt; decltype(std::declval&lt; const basic_json_t &amp; &gt;().template get_impl&lt; ValueType &gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt; 4 &gt; {}))</td></tr>
<tr class="memdesc:ab11bff397526e8255d151066caeba48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a (pointer) value (explicit)  <br /></td></tr>
<tr class="separator:ab11bff397526e8255d151066caeba48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa19a3f6193409abe4bd9014712105" id="r_a35fa19a3f6193409abe4bd9014712105"><td class="memTemplParams" colspan="2">template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a35fa19a3f6193409abe4bd9014712105"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a35fa19a3f6193409abe4bd9014712105">get</a> () noexcept -&gt; decltype(std::declval&lt; basic_json_t &amp; &gt;().template <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a>&lt; PointerType &gt;())</td></tr>
<tr class="memdesc:a35fa19a3f6193409abe4bd9014712105"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer value (explicit)  <br /></td></tr>
<tr class="separator:a35fa19a3f6193409abe4bd9014712105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251b2b7f275328615aed5a0f827e7710" id="r_a251b2b7f275328615aed5a0f827e7710"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a251b2b7f275328615aed5a0f827e7710"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a251b2b7f275328615aed5a0f827e7710">get_to</a> (ValueType &amp;v) const noexcept(noexcept(JSONSerializer&lt; ValueType &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="memdesc:a251b2b7f275328615aed5a0f827e7710"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (explicit)  <br /></td></tr>
<tr class="separator:a251b2b7f275328615aed5a0f827e7710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0131c192963ed4d1148805120aa319" id="r_a9e0131c192963ed4d1148805120aa319"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9e0131c192963ed4d1148805120aa319"><td class="memTemplItemLeft" align="right" valign="top">ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9e0131c192963ed4d1148805120aa319">get_to</a> (ValueType &amp;v) const</td></tr>
<tr class="separator:a9e0131c192963ed4d1148805120aa319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a78b37dee5a709f610375403597bba" id="r_ac6a78b37dee5a709f610375403597bba"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; <a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, Array &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac6a78b37dee5a709f610375403597bba"><td class="memTemplItemLeft" align="right" valign="top">Array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac6a78b37dee5a709f610375403597bba">get_to</a> (T(&amp;v)[N]) const noexcept(noexcept(JSONSerializer&lt; Array &gt;::from_json(std::declval&lt; const basic_json_t &amp; &gt;(), v)))</td></tr>
<tr class="separator:ac6a78b37dee5a709f610375403597bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfdaa5014da75e18dd07cc76e53b237" id="r_a7bfdaa5014da75e18dd07cc76e53b237"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a7bfdaa5014da75e18dd07cc76e53b237"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7bfdaa5014da75e18dd07cc76e53b237">get_ref</a> ()</td></tr>
<tr class="memdesc:a7bfdaa5014da75e18dd07cc76e53b237"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <br /></td></tr>
<tr class="separator:a7bfdaa5014da75e18dd07cc76e53b237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f1f9cf90ed5254e38e6b587fce237d" id="r_a42f1f9cf90ed5254e38e6b587fce237d"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a42f1f9cf90ed5254e38e6b587fce237d"><td class="memTemplItemLeft" align="right" valign="top">ReferenceType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a42f1f9cf90ed5254e38e6b587fce237d">get_ref</a> () const</td></tr>
<tr class="memdesc:a42f1f9cf90ed5254e38e6b587fce237d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a reference value (implicit)  <br /></td></tr>
<tr class="separator:a42f1f9cf90ed5254e38e6b587fce237d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ccb49215a3dcac15438fb94485e86f" id="r_a31ccb49215a3dcac15438fb94485e86f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename std::enable_if&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_pointer&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::nullptr_t &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt; &gt; &gt;, <a class="el" href="structdetail_1_1is__detected__lazy.html">detail::is_detected_lazy</a>&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a31ccb49215a3dcac15438fb94485e86f"><td class="memTemplItemLeft" align="right" valign="top">JSON_EXPLICIT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a31ccb49215a3dcac15438fb94485e86f">operator ValueType</a> () const</td></tr>
<tr class="memdesc:a31ccb49215a3dcac15438fb94485e86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a value (implicit)  <br /></td></tr>
<tr class="separator:a31ccb49215a3dcac15438fb94485e86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4401911681258520903f3c374a9e994" id="r_aa4401911681258520903f3c374a9e994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa4401911681258520903f3c374a9e994">get_binary</a> ()</td></tr>
<tr class="memdesc:aa4401911681258520903f3c374a9e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <br /></td></tr>
<tr class="separator:aa4401911681258520903f3c374a9e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b4244ff0e901156adfad7b027232de" id="r_a44b4244ff0e901156adfad7b027232de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a44b4244ff0e901156adfad7b027232de">get_binary</a> () const</td></tr>
<tr class="memdesc:a44b4244ff0e901156adfad7b027232de"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a binary value  <br /></td></tr>
<tr class="separator:a44b4244ff0e901156adfad7b027232de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">constructors and destructors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Constructors of class <a class="el" href="classbasic__json.html">basic_json</a>, copy/move constructor, copy assignment, static functions creating objects, and the destructor. </p>
</td></tr>
<tr class="memitem:a8d25b7a4a6f6ee355193ee6b461ab3bd" id="r_a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d25b7a4a6f6ee355193ee6b461ab3bd">binary</a> (const typename binary_t::container_type &amp;init)</td></tr>
<tr class="memdesc:a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (without subtype)  <br /></td></tr>
<tr class="separator:a8d25b7a4a6f6ee355193ee6b461ab3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92f5028b858b39e0c49c722ba09793" id="r_a9a92f5028b858b39e0c49c722ba09793"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9a92f5028b858b39e0c49c722ba09793">binary</a> (const typename binary_t::container_type &amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a9a92f5028b858b39e0c49c722ba09793"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <br /></td></tr>
<tr class="separator:a9a92f5028b858b39e0c49c722ba09793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767ec4050ecfb4e4852db24cc939b2b" id="r_a0767ec4050ecfb4e4852db24cc939b2b"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0767ec4050ecfb4e4852db24cc939b2b">binary</a> (typename binary_t::container_type &amp;&amp;init)</td></tr>
<tr class="memdesc:a0767ec4050ecfb4e4852db24cc939b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array  <br /></td></tr>
<tr class="separator:a0767ec4050ecfb4e4852db24cc939b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9ba515c5f51d9c5609583e3d0ada0" id="r_a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ad9ba515c5f51d9c5609583e3d0ada0">binary</a> (typename binary_t::container_type &amp;&amp;init, typename binary_t::subtype_type subtype)</td></tr>
<tr class="memdesc:a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create a binary array (with subtype)  <br /></td></tr>
<tr class="separator:a6ad9ba515c5f51d9c5609583e3d0ada0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a68350d457af1f6ea7f27b6e0a5baf" id="r_a08a68350d457af1f6ea7f27b6e0a5baf"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a08a68350d457af1f6ea7f27b6e0a5baf">array</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a08a68350d457af1f6ea7f27b6e0a5baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an array from an initializer list  <br /></td></tr>
<tr class="separator:a08a68350d457af1f6ea7f27b6e0a5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa3ec9e58f6852709913408519c01c" id="r_a10aa3ec9e58f6852709913408519c01c"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">object</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init={})</td></tr>
<tr class="memdesc:a10aa3ec9e58f6852709913408519c01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicitly create an object from an initializer list  <br /></td></tr>
<tr class="separator:a10aa3ec9e58f6852709913408519c01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee75ecbdc67fc5faa1228c949c59ff27" id="r_aee75ecbdc67fc5faa1228c949c59ff27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aee75ecbdc67fc5faa1228c949c59ff27">basic_json</a> (const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> v)</td></tr>
<tr class="memdesc:aee75ecbdc67fc5faa1228c949c59ff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty value with a given type  <br /></td></tr>
<tr class="separator:aee75ecbdc67fc5faa1228c949c59ff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1bad4745ddb574540f71cdbcd532f" id="r_ac6f1bad4745ddb574540f71cdbcd532f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac6f1bad4745ddb574540f71cdbcd532f">basic_json</a> (std::nullptr_t=nullptr) noexcept</td></tr>
<tr class="memdesc:ac6f1bad4745ddb574540f71cdbcd532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a null object  <br /></td></tr>
<tr class="separator:ac6f1bad4745ddb574540f71cdbcd532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1f9ac7c7ebcff72d00869e974a6249" id="r_a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memTemplParams" colspan="2">template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__compatible__type.html">detail::is_compatible_type</a>&lt; basic_json_t, U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9b1f9ac7c7ebcff72d00869e974a6249">basic_json</a> (CompatibleType &amp;&amp;val) noexcept(noexcept(//NOLINT(bugprone-forwarding-<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>-overload, bugprone-<a class="el" href="classdetail_1_1exception.html">exception</a>-escape) JSONSerializer&lt; U &gt;::to_json(std::declval&lt; basic_json_t &amp; &gt;(), std::forward&lt; CompatibleType &gt;(val))))</td></tr>
<tr class="memdesc:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from compatible types  <br /></td></tr>
<tr class="separator:a9b1f9ac7c7ebcff72d00869e974a6249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94560a1edd72d60310c54c9b2d9f1ad2" id="r_a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="classbasic__json.html">basic_json</a>, BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94560a1edd72d60310c54c9b2d9f1ad2">basic_json</a> (const BasicJsonType &amp;val)</td></tr>
<tr class="memdesc:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an existing one  <br /></td></tr>
<tr class="separator:a94560a1edd72d60310c54c9b2d9f1ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3d71dec8062753efb67860b7cca1a1" id="r_aec3d71dec8062753efb67860b7cca1a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aec3d71dec8062753efb67860b7cca1a1">basic_json</a> (<a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a> init, bool type_deduction=true, <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> manual_type=value_t::array)</td></tr>
<tr class="memdesc:aec3d71dec8062753efb67860b7cca1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a container (array or object) from an initializer list  <br /></td></tr>
<tr class="separator:aec3d71dec8062753efb67860b7cca1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad382c9c9e03c410004150c9d6b9f0bd9" id="r_ad382c9c9e03c410004150c9d6b9f0bd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad382c9c9e03c410004150c9d6b9f0bd9">basic_json</a> (<a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> cnt, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;val)</td></tr>
<tr class="memdesc:ad382c9c9e03c410004150c9d6b9f0bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct an array with count copies of given value  <br /></td></tr>
<tr class="separator:ad382c9c9e03c410004150c9d6b9f0bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f2c1a11dd6e84196132ea77a99572a" id="r_a12f2c1a11dd6e84196132ea77a99572a"><td class="memTemplParams" colspan="2">template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </td></tr>
<tr class="memitem:a12f2c1a11dd6e84196132ea77a99572a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a12f2c1a11dd6e84196132ea77a99572a">basic_json</a> (InputIT first, InputIT last)</td></tr>
<tr class="memdesc:a12f2c1a11dd6e84196132ea77a99572a"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a JSON container given an iterator range  <br /></td></tr>
<tr class="separator:a12f2c1a11dd6e84196132ea77a99572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33adf04c1d841c42c0eeaf05252aedc3" id="r_a33adf04c1d841c42c0eeaf05252aedc3"><td class="memTemplParams" colspan="2">template&lt;typename JsonRef , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1is__json__ref.html">detail::is_json_ref</a>&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a33adf04c1d841c42c0eeaf05252aedc3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a33adf04c1d841c42c0eeaf05252aedc3">basic_json</a> (const JsonRef &amp;ref)</td></tr>
<tr class="separator:a33adf04c1d841c42c0eeaf05252aedc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e476c88b91f1f4329bb4901cafc4c" id="r_ac62e476c88b91f1f4329bb4901cafc4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac62e476c88b91f1f4329bb4901cafc4c">basic_json</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;other)</td></tr>
<tr class="memdesc:ac62e476c88b91f1f4329bb4901cafc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <br /></td></tr>
<tr class="separator:ac62e476c88b91f1f4329bb4901cafc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa269ba998ca2e15b2f596a8c074d125f" id="r_aa269ba998ca2e15b2f596a8c074d125f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa269ba998ca2e15b2f596a8c074d125f">basic_json</a> (<a class="el" href="classbasic__json.html">basic_json</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aa269ba998ca2e15b2f596a8c074d125f"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <br /></td></tr>
<tr class="separator:aa269ba998ca2e15b2f596a8c074d125f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb70d0ea0c23ac40f1f3b67d40c174f" id="r_a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8cb70d0ea0c23ac40f1f3b67d40c174f">operator=</a> (<a class="el" href="classbasic__json.html">basic_json</a> other) noexcept(std::is_nothrow_move_constructible&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>)</td></tr>
<tr class="memdesc:a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment  <br /></td></tr>
<tr class="separator:a8cb70d0ea0c23ac40f1f3b67d40c174f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0209408ec1ed66ea5f89a7d72e57e43" id="r_ad0209408ec1ed66ea5f89a7d72e57e43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad0209408ec1ed66ea5f89a7d72e57e43">~basic_json</a> () noexcept</td></tr>
<tr class="memdesc:ad0209408ec1ed66ea5f89a7d72e57e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <br /></td></tr>
<tr class="separator:ad0209408ec1ed66ea5f89a7d72e57e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">iterators</h2></td></tr>
<tr class="memitem:a091a63384590fe2cf7a122155b30011a" id="r_a091a63384590fe2cf7a122155b30011a"><td class="memItemLeft" align="right" valign="top">static iteration_proxy&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a091a63384590fe2cf7a122155b30011a">iterator_wrapper</a> (<a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> ref) noexcept</td></tr>
<tr class="memdesc:a091a63384590fe2cf7a122155b30011a"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper to access iterator member functions in range-based for  <br /></td></tr>
<tr class="separator:a091a63384590fe2cf7a122155b30011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af373ec8f75f254b79fe1b1ca776797b9" id="r_af373ec8f75f254b79fe1b1ca776797b9"><td class="memItemLeft" align="right" valign="top">static iteration_proxy&lt; <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af373ec8f75f254b79fe1b1ca776797b9">iterator_wrapper</a> (<a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> ref) noexcept</td></tr>
<tr class="memdesc:af373ec8f75f254b79fe1b1ca776797b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper to access iterator member functions in range-based for  <br /></td></tr>
<tr class="separator:af373ec8f75f254b79fe1b1ca776797b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ba4755c9131259324caaa166146513" id="r_af7ba4755c9131259324caaa166146513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a> () noexcept</td></tr>
<tr class="memdesc:af7ba4755c9131259324caaa166146513"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the first element  <br /></td></tr>
<tr class="separator:af7ba4755c9131259324caaa166146513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec74bf7ec122115d615a7f1be4122f9f" id="r_aec74bf7ec122115d615a7f1be4122f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aec74bf7ec122115d615a7f1be4122f9f">begin</a> () const noexcept</td></tr>
<tr class="memdesc:aec74bf7ec122115d615a7f1be4122f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the first element  <br /></td></tr>
<tr class="separator:aec74bf7ec122115d615a7f1be4122f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3451ab7e33828ded865a4c6c2e22463b" id="r_a3451ab7e33828ded865a4c6c2e22463b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a3451ab7e33828ded865a4c6c2e22463b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const iterator to the first element  <br /></td></tr>
<tr class="separator:a3451ab7e33828ded865a4c6c2e22463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e303bfaafda414b4b5821384501bc1" id="r_a06e303bfaafda414b4b5821384501bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a> () noexcept</td></tr>
<tr class="memdesc:a06e303bfaafda414b4b5821384501bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to one past the last element  <br /></td></tr>
<tr class="separator:a06e303bfaafda414b4b5821384501bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0409aa6e94198aaedff3f285d3c98e8c" id="r_a0409aa6e94198aaedff3f285d3c98e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0409aa6e94198aaedff3f285d3c98e8c">end</a> () const noexcept</td></tr>
<tr class="memdesc:a0409aa6e94198aaedff3f285d3c98e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to one past the last element  <br /></td></tr>
<tr class="separator:a0409aa6e94198aaedff3f285d3c98e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f83081d8b64f6dc9b079af13266dc1" id="r_ab4f83081d8b64f6dc9b079af13266dc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a> () const noexcept</td></tr>
<tr class="memdesc:ab4f83081d8b64f6dc9b079af13266dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to one past the last element  <br /></td></tr>
<tr class="separator:ab4f83081d8b64f6dc9b079af13266dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c2b82d885e4765ad078f475c777320" id="r_ac8c2b82d885e4765ad078f475c777320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac8c2b82d885e4765ad078f475c777320">rbegin</a> () noexcept</td></tr>
<tr class="memdesc:ac8c2b82d885e4765ad078f475c777320"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the reverse-beginning  <br /></td></tr>
<tr class="separator:ac8c2b82d885e4765ad078f475c777320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8bf73439e55c11983f51de32614b5" id="r_a9eb8bf73439e55c11983f51de32614b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9eb8bf73439e55c11983f51de32614b5">rbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9eb8bf73439e55c11983f51de32614b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the reverse-beginning  <br /></td></tr>
<tr class="separator:a9eb8bf73439e55c11983f51de32614b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8366e38224d6bb07c9ef7b21d96553" id="r_aaf8366e38224d6bb07c9ef7b21d96553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aaf8366e38224d6bb07c9ef7b21d96553">rend</a> () noexcept</td></tr>
<tr class="memdesc:aaf8366e38224d6bb07c9ef7b21d96553"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the reverse-end  <br /></td></tr>
<tr class="separator:aaf8366e38224d6bb07c9ef7b21d96553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeda19c8edb0398ba1c04575b077391d" id="r_aeeda19c8edb0398ba1c04575b077391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aeeda19c8edb0398ba1c04575b077391d">rend</a> () const noexcept</td></tr>
<tr class="memdesc:aeeda19c8edb0398ba1c04575b077391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the reverse-end  <br /></td></tr>
<tr class="separator:aeeda19c8edb0398ba1c04575b077391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f45b1b03cd315b3700dacb22d1fb3" id="r_aed4f45b1b03cd315b3700dacb22d1fb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aed4f45b1b03cd315b3700dacb22d1fb3">crbegin</a> () const noexcept</td></tr>
<tr class="memdesc:aed4f45b1b03cd315b3700dacb22d1fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const reverse iterator to the last element  <br /></td></tr>
<tr class="separator:aed4f45b1b03cd315b3700dacb22d1fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463e1d370bf75906179dce60ad89a1ea" id="r_a463e1d370bf75906179dce60ad89a1ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a463e1d370bf75906179dce60ad89a1ea">crend</a> () const noexcept</td></tr>
<tr class="memdesc:a463e1d370bf75906179dce60ad89a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const reverse iterator to one before the first  <br /></td></tr>
<tr class="separator:a463e1d370bf75906179dce60ad89a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b219291271e36e427d6b9c9916fec" id="r_a164b219291271e36e427d6b9c9916fec"><td class="memItemLeft" align="right" valign="top">iteration_proxy&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a164b219291271e36e427d6b9c9916fec">items</a> () noexcept</td></tr>
<tr class="memdesc:a164b219291271e36e427d6b9c9916fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to access iterator member functions in range-based for  <br /></td></tr>
<tr class="separator:a164b219291271e36e427d6b9c9916fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b062fb036928f3c4c945c18609ca0ec" id="r_a2b062fb036928f3c4c945c18609ca0ec"><td class="memItemLeft" align="right" valign="top">iteration_proxy&lt; <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2b062fb036928f3c4c945c18609ca0ec">items</a> () const noexcept</td></tr>
<tr class="memdesc:a2b062fb036928f3c4c945c18609ca0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to access iterator member functions in range-based for  <br /></td></tr>
<tr class="separator:a2b062fb036928f3c4c945c18609ca0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">binary serialization/deserialization support</h2></td></tr>
<tr class="memitem:a12a270a8c98f23f838837562ddde18a8" id="r_a12a270a8c98f23f838837562ddde18a8"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a12a270a8c98f23f838837562ddde18a8">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a12a270a8c98f23f838837562ddde18a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a12a270a8c98f23f838837562ddde18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e6116b577c4a402d0bf59ceb1ce3b6" id="r_a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a91e6116b577c4a402d0bf59ceb1ce3b6">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a91e6116b577c4a402d0bf59ceb1ce3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b49f22c2c0ed2c803c695f328ee5f4f" id="r_a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4b49f22c2c0ed2c803c695f328ee5f4f">to_cbor</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; char &gt; o)</td></tr>
<tr class="memdesc:a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a CBOR serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a4b49f22c2c0ed2c803c695f328ee5f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d510f5c39b036deb96e61c8bef19f31" id="r_a4d510f5c39b036deb96e61c8bef19f31"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a4d510f5c39b036deb96e61c8bef19f31">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a4d510f5c39b036deb96e61c8bef19f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a4d510f5c39b036deb96e61c8bef19f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91a270a87e6aec97c18d44aaddf0d33" id="r_ad91a270a87e6aec97c18d44aaddf0d33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad91a270a87e6aec97c18d44aaddf0d33">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:ad91a270a87e6aec97c18d44aaddf0d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <br /></td></tr>
<tr class="separator:ad91a270a87e6aec97c18d44aaddf0d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3ec809212107cb5809c386c5e3dce3" id="r_a7e3ec809212107cb5809c386c5e3dce3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7e3ec809212107cb5809c386c5e3dce3">to_msgpack</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; char &gt; o)</td></tr>
<tr class="memdesc:a7e3ec809212107cb5809c386c5e3dce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a MessagePack serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a7e3ec809212107cb5809c386c5e3dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a0e7569fb3170e0151e4aca3f4bf3b" id="r_a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a74a0e7569fb3170e0151e4aca3f4bf3b">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a74a0e7569fb3170e0151e4aca3f4bf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8" id="r_ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad7567f6b4b51d3bc1cbe6a80cd6ca9a8">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aecae4901eb995b22ee6abccf94122" id="r_a81aecae4901eb995b22ee6abccf94122"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a81aecae4901eb995b22ee6abccf94122">to_ubjson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a81aecae4901eb995b22ee6abccf94122"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a UBJSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a81aecae4901eb995b22ee6abccf94122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b222d92f075b0033a76a60ccb36269c" id="r_a2b222d92f075b0033a76a60ccb36269c"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2b222d92f075b0033a76a60ccb36269c">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a2b222d92f075b0033a76a60ccb36269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a2b222d92f075b0033a76a60ccb36269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a7117f98423b6d92e48951a7e3c55" id="r_a9b4a7117f98423b6d92e48951a7e3c55"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9b4a7117f98423b6d92e48951a7e3c55">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; std::uint8_t &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a9b4a7117f98423b6d92e48951a7e3c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a9b4a7117f98423b6d92e48951a7e3c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c66ff3a69ef4e4d0d1c136d4226c6af" id="r_a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9c66ff3a69ef4e4d0d1c136d4226c6af">to_bjdata</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; char &gt; o, const bool use_size=false, const bool use_type=false)</td></tr>
<tr class="memdesc:a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BJData serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a9c66ff3a69ef4e4d0d1c136d4226c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f418313f92075a0ab72060bfe4de06" id="r_a85f418313f92075a0ab72060bfe4de06"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a85f418313f92075a0ab72060bfe4de06">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j)</td></tr>
<tr class="memdesc:a85f418313f92075a0ab72060bfe4de06"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a85f418313f92075a0ab72060bfe4de06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ff725ab08638fbc83ed7e3c7c41396" id="r_ad5ff725ab08638fbc83ed7e3c7c41396"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad5ff725ab08638fbc83ed7e3c7c41396">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; std::uint8_t &gt; o)</td></tr>
<tr class="memdesc:ad5ff725ab08638fbc83ed7e3c7c41396"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:ad5ff725ab08638fbc83ed7e3c7c41396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bb643538ab0e016a2f319e22bf4c4d" id="r_a62bb643538ab0e016a2f319e22bf4c4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a62bb643538ab0e016a2f319e22bf4c4d">to_bson</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;j, detail::output_adapter&lt; char &gt; o)</td></tr>
<tr class="memdesc:a62bb643538ab0e016a2f319e22bf4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a BSON serialization of a given JSON value  <br /></td></tr>
<tr class="separator:a62bb643538ab0e016a2f319e22bf4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e2d9cbd8a385017bb3d91c45a1753a" id="r_a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a84e2d9cbd8a385017bb3d91c45a1753a">from_cbor</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=cbor_tag_handler_t::error)</td></tr>
<tr class="memdesc:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <br /></td></tr>
<tr class="separator:a84e2d9cbd8a385017bb3d91c45a1753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93872bc620a9bbe028be81a3eaae21f3" id="r_a93872bc620a9bbe028be81a3eaae21f3"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a93872bc620a9bbe028be81a3eaae21f3"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a93872bc620a9bbe028be81a3eaae21f3">from_cbor</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=cbor_tag_handler_t::error)</td></tr>
<tr class="memdesc:a93872bc620a9bbe028be81a3eaae21f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in CBOR format  <br /></td></tr>
<tr class="separator:a93872bc620a9bbe028be81a3eaae21f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcdc5f7b4a7ebf4b2a1a21710ad246d" id="r_a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0dcdc5f7b4a7ebf4b2a1a21710ad246d">from_cbor</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=cbor_tag_handler_t::error)</td></tr>
<tr class="separator:a0dcdc5f7b4a7ebf4b2a1a21710ad246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff52051e3e569f6f801b2d7b66124b1" id="r_adff52051e3e569f6f801b2d7b66124b1"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adff52051e3e569f6f801b2d7b66124b1">from_cbor</a> (detail::span_input_adapter &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a> tag_handler=cbor_tag_handler_t::error)</td></tr>
<tr class="separator:adff52051e3e569f6f801b2d7b66124b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba0ffab9429d589d658d3e053b8273" id="r_a96ba0ffab9429d589d658d3e053b8273"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a96ba0ffab9429d589d658d3e053b8273"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a96ba0ffab9429d589d658d3e053b8273">from_msgpack</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a96ba0ffab9429d589d658d3e053b8273"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <br /></td></tr>
<tr class="separator:a96ba0ffab9429d589d658d3e053b8273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3794747f5b19e0504afa3585476e97" id="r_a7f3794747f5b19e0504afa3585476e97"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a7f3794747f5b19e0504afa3585476e97"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7f3794747f5b19e0504afa3585476e97">from_msgpack</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a7f3794747f5b19e0504afa3585476e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in MessagePack format  <br /></td></tr>
<tr class="separator:a7f3794747f5b19e0504afa3585476e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347f43d4eb713aa711d6c8a5fca41cf" id="r_ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac347f43d4eb713aa711d6c8a5fca41cf">from_msgpack</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:ac347f43d4eb713aa711d6c8a5fca41cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29d7be59d39991efb3a584cd2e6598" id="r_a2a29d7be59d39991efb3a584cd2e6598"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2a29d7be59d39991efb3a584cd2e6598">from_msgpack</a> (detail::span_input_adapter &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a2a29d7be59d39991efb3a584cd2e6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662ee4905d8c2628b3018b378bbd4c9e" id="r_a662ee4905d8c2628b3018b378bbd4c9e"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a662ee4905d8c2628b3018b378bbd4c9e"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a662ee4905d8c2628b3018b378bbd4c9e">from_ubjson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a662ee4905d8c2628b3018b378bbd4c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <br /></td></tr>
<tr class="separator:a662ee4905d8c2628b3018b378bbd4c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36123b583eaae095ee46413e4e380ef" id="r_ad36123b583eaae095ee46413e4e380ef"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:ad36123b583eaae095ee46413e4e380ef"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad36123b583eaae095ee46413e4e380ef">from_ubjson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:ad36123b583eaae095ee46413e4e380ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in UBJSON format  <br /></td></tr>
<tr class="separator:ad36123b583eaae095ee46413e4e380ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5a903e9aad342917fc3e98c070a0d7" id="r_a3d5a903e9aad342917fc3e98c070a0d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d5a903e9aad342917fc3e98c070a0d7"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d5a903e9aad342917fc3e98c070a0d7">from_ubjson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a3d5a903e9aad342917fc3e98c070a0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99be0ee4212c46c20ee32d4a1a90cc6c" id="r_a99be0ee4212c46c20ee32d4a1a90cc6c"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a99be0ee4212c46c20ee32d4a1a90cc6c">from_ubjson</a> (detail::span_input_adapter &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a99be0ee4212c46c20ee32d4a1a90cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeac471308bec4cfe026258f746cfcc" id="r_affeac471308bec4cfe026258f746cfcc"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:affeac471308bec4cfe026258f746cfcc"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#affeac471308bec4cfe026258f746cfcc">from_bjdata</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:affeac471308bec4cfe026258f746cfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <br /></td></tr>
<tr class="separator:affeac471308bec4cfe026258f746cfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c00d3023a03b37d9a362cdf61c17c1" id="r_a94c00d3023a03b37d9a362cdf61c17c1"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a94c00d3023a03b37d9a362cdf61c17c1"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a94c00d3023a03b37d9a362cdf61c17c1">from_bjdata</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a94c00d3023a03b37d9a362cdf61c17c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BJData format  <br /></td></tr>
<tr class="separator:a94c00d3023a03b37d9a362cdf61c17c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac8b0effce93dad2e3eec9c1a7ed129" id="r_a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memTemplParams" colspan="2">template&lt;typename InputType &gt; </td></tr>
<tr class="memitem:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5ac8b0effce93dad2e3eec9c1a7ed129">from_bson</a> (InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <br /></td></tr>
<tr class="separator:a5ac8b0effce93dad2e3eec9c1a7ed129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c87b306915435958b5e584dfb80ce4" id="r_a06c87b306915435958b5e584dfb80ce4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a06c87b306915435958b5e584dfb80ce4"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06c87b306915435958b5e584dfb80ce4">from_bson</a> (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="memdesc:a06c87b306915435958b5e584dfb80ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a JSON value from an input in BSON format  <br /></td></tr>
<tr class="separator:a06c87b306915435958b5e584dfb80ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d6a52ae542b7ffd137e87e72f9bcce" id="r_aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memTemplItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa5d6a52ae542b7ffd137e87e72f9bcce">from_bson</a> (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:aa5d6a52ae542b7ffd137e87e72f9bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868a32e0da318e39872fb825b377bda6" id="r_a868a32e0da318e39872fb825b377bda6"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a868a32e0da318e39872fb825b377bda6">from_bson</a> (detail::span_input_adapter &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</td></tr>
<tr class="separator:a868a32e0da318e39872fb825b377bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Patch functions</h2></td></tr>
<tr class="memitem:aff2204c04cd35b2cef35f44b2b93ffc7" id="r_aff2204c04cd35b2cef35f44b2b93ffc7"><td class="memItemLeft" align="right" valign="top">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">diff</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;source, const <a class="el" href="classbasic__json.html">basic_json</a> &amp;target, const std::string &amp;path=&quot;&quot;)</td></tr>
<tr class="memdesc:aff2204c04cd35b2cef35f44b2b93ffc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a diff as a JSON patch  <br /></td></tr>
<tr class="separator:aff2204c04cd35b2cef35f44b2b93ffc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2ae40925906c7e1d559b8bf12028a7" id="r_adc2ae40925906c7e1d559b8bf12028a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#adc2ae40925906c7e1d559b8bf12028a7">patch_inplace</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;json_patch)</td></tr>
<tr class="memdesc:adc2ae40925906c7e1d559b8bf12028a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON patch in-place without copying the object  <br /></td></tr>
<tr class="separator:adc2ae40925906c7e1d559b8bf12028a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a009b55b9dcdb30352f5f62537931b7" id="r_a5a009b55b9dcdb30352f5f62537931b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a5a009b55b9dcdb30352f5f62537931b7">patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;json_patch) const</td></tr>
<tr class="memdesc:a5a009b55b9dcdb30352f5f62537931b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON patch to a copy of the current object  <br /></td></tr>
<tr class="separator:a5a009b55b9dcdb30352f5f62537931b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">object inspection</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Functions to inspect the type of a JSON value. </p>
</td></tr>
<tr class="memitem:ac38b5f79c16205efb771e99be206b345" id="r_ac38b5f79c16205efb771e99be206b345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac38b5f79c16205efb771e99be206b345">dump</a> (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a> error_handler=error_handler_t::strict) const</td></tr>
<tr class="memdesc:ac38b5f79c16205efb771e99be206b345"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialization  <br /></td></tr>
<tr class="separator:ac38b5f79c16205efb771e99be206b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1338e4eef7282cd57a4a57e034531029" id="r_a1338e4eef7282cd57a4a57e034531029"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">type</a> () const noexcept</td></tr>
<tr class="memdesc:a1338e4eef7282cd57a4a57e034531029"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (explicit)  <br /></td></tr>
<tr class="separator:a1338e4eef7282cd57a4a57e034531029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa8bc506b1519193a7bbc09f8a0f095" id="r_a7fa8bc506b1519193a7bbc09f8a0f095"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a7fa8bc506b1519193a7bbc09f8a0f095">is_primitive</a> () const noexcept</td></tr>
<tr class="memdesc:a7fa8bc506b1519193a7bbc09f8a0f095"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is primitive  <br /></td></tr>
<tr class="separator:a7fa8bc506b1519193a7bbc09f8a0f095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded85ec1014821c21b8a47bc816a6917" id="r_aded85ec1014821c21b8a47bc816a6917"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aded85ec1014821c21b8a47bc816a6917">is_structured</a> () const noexcept</td></tr>
<tr class="memdesc:aded85ec1014821c21b8a47bc816a6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether type is structured  <br /></td></tr>
<tr class="separator:aded85ec1014821c21b8a47bc816a6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed948b2c2e71ce5f5c03b5eeb575df4" id="r_a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is null  <br /></td></tr>
<tr class="separator:a6ed948b2c2e71ce5f5c03b5eeb575df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814771ab0add0def16119c157b44003a" id="r_a814771ab0add0def16119c157b44003a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a814771ab0add0def16119c157b44003a">is_boolean</a> () const noexcept</td></tr>
<tr class="memdesc:a814771ab0add0def16119c157b44003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a boolean  <br /></td></tr>
<tr class="separator:a814771ab0add0def16119c157b44003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84294fe5d1a2822e2f67685f6e8c735" id="r_ab84294fe5d1a2822e2f67685f6e8c735"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">is_number</a> () const noexcept</td></tr>
<tr class="memdesc:ab84294fe5d1a2822e2f67685f6e8c735"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a number  <br /></td></tr>
<tr class="separator:ab84294fe5d1a2822e2f67685f6e8c735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14438fe7c1f5a2f750eb56b8e73e538" id="r_ad14438fe7c1f5a2f750eb56b8e73e538"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ad14438fe7c1f5a2f750eb56b8e73e538">is_number_integer</a> () const noexcept</td></tr>
<tr class="memdesc:ad14438fe7c1f5a2f750eb56b8e73e538"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an integer number  <br /></td></tr>
<tr class="separator:ad14438fe7c1f5a2f750eb56b8e73e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5744d3f2404f2376ab0dbe531e4d3bc" id="r_aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa5744d3f2404f2376ab0dbe531e4d3bc">is_number_unsigned</a> () const noexcept</td></tr>
<tr class="memdesc:aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an unsigned integer number  <br /></td></tr>
<tr class="separator:aa5744d3f2404f2376ab0dbe531e4d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c885a9182fd22b05826ab2a9548f60" id="r_aa8c885a9182fd22b05826ab2a9548f60"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">is_number_float</a> () const noexcept</td></tr>
<tr class="memdesc:aa8c885a9182fd22b05826ab2a9548f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a floating-point number  <br /></td></tr>
<tr class="separator:aa8c885a9182fd22b05826ab2a9548f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af758a912346776b086abb82487b1d73b" id="r_af758a912346776b086abb82487b1d73b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a> () const noexcept</td></tr>
<tr class="memdesc:af758a912346776b086abb82487b1d73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an object  <br /></td></tr>
<tr class="separator:af758a912346776b086abb82487b1d73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ea48a4e802ef81783c0c7ce89aa7bb" id="r_a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a> () const noexcept</td></tr>
<tr class="memdesc:a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is an array  <br /></td></tr>
<tr class="separator:a89ea48a4e802ef81783c0c7ce89aa7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4378552d27c9f15e4cb4ff4c075c94" id="r_a3d4378552d27c9f15e4cb4ff4c075c94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a> () const noexcept</td></tr>
<tr class="memdesc:a3d4378552d27c9f15e4cb4ff4c075c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a string  <br /></td></tr>
<tr class="separator:a3d4378552d27c9f15e4cb4ff4c075c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e81e71e2a263c0431f02f3245a8aa" id="r_aa25e81e71e2a263c0431f02f3245a8aa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a> () const noexcept</td></tr>
<tr class="memdesc:aa25e81e71e2a263c0431f02f3245a8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is a binary array  <br /></td></tr>
<tr class="separator:aa25e81e71e2a263c0431f02f3245a8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7082bb9fa07704c659f6be7c41bc9" id="r_abcc7082bb9fa07704c659f6be7c41bc9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">is_discarded</a> () const noexcept</td></tr>
<tr class="memdesc:abcc7082bb9fa07704c659f6be7c41bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether value is discarded  <br /></td></tr>
<tr class="separator:abcc7082bb9fa07704c659f6be7c41bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab025e8b5ac852c84758f92183b569b99" id="r_ab025e8b5ac852c84758f92183b569b99"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ab025e8b5ac852c84758f92183b569b99">operator value_t</a> () const noexcept</td></tr>
<tr class="memdesc:ab025e8b5ac852c84758f92183b569b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the type of the JSON value (implicit)  <br /></td></tr>
<tr class="separator:ab025e8b5ac852c84758f92183b569b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">lookup</h2></td></tr>
<tr class="memitem:a8ed11f83edce392fd94659b1102d078e" id="r_a8ed11f83edce392fd94659b1102d078e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a> (const typename object_t::key_type &amp;key)</td></tr>
<tr class="memdesc:a8ed11f83edce392fd94659b1102d078e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <br /></td></tr>
<tr class="separator:a8ed11f83edce392fd94659b1102d078e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8085b05e9a2e6f187708bca5e22d04" id="r_a8d8085b05e9a2e6f187708bca5e22d04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8d8085b05e9a2e6f187708bca5e22d04">find</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a8d8085b05e9a2e6f187708bca5e22d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <br /></td></tr>
<tr class="separator:a8d8085b05e9a2e6f187708bca5e22d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e01eb7be2878873ba084c0a0b20442" id="r_a81e01eb7be2878873ba084c0a0b20442"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81e01eb7be2878873ba084c0a0b20442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a81e01eb7be2878873ba084c0a0b20442">find</a> (KeyType &amp;&amp;key)</td></tr>
<tr class="memdesc:a81e01eb7be2878873ba084c0a0b20442"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <br /></td></tr>
<tr class="separator:a81e01eb7be2878873ba084c0a0b20442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42890814a18f9c593f69218706113474" id="r_a42890814a18f9c593f69218706113474"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a42890814a18f9c593f69218706113474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a42890814a18f9c593f69218706113474">find</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a42890814a18f9c593f69218706113474"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an element in a JSON object  <br /></td></tr>
<tr class="separator:a42890814a18f9c593f69218706113474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac122e03d4d28d6a03c01abaa7229d4c7" id="r_ac122e03d4d28d6a03c01abaa7229d4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac122e03d4d28d6a03c01abaa7229d4c7">count</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:ac122e03d4d28d6a03c01abaa7229d4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <br /></td></tr>
<tr class="separator:ac122e03d4d28d6a03c01abaa7229d4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e36a368cbf554fc817b0cb3e37e3a3" id="r_a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a06e36a368cbf554fc817b0cb3e37e3a3">count</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of occurrences of a key in a JSON object  <br /></td></tr>
<tr class="separator:a06e36a368cbf554fc817b0cb3e37e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815a53b61818c87cf677f4a1ea5b7e8" id="r_a3815a53b61818c87cf677f4a1ea5b7e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a3815a53b61818c87cf677f4a1ea5b7e8">contains</a> (const typename object_t::key_type &amp;key) const</td></tr>
<tr class="memdesc:a3815a53b61818c87cf677f4a1ea5b7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <br /></td></tr>
<tr class="separator:a3815a53b61818c87cf677f4a1ea5b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dbcc61c27689659fa1d94a19bd2560" id="r_a56dbcc61c27689659fa1d94a19bd2560"><td class="memTemplParams" colspan="2">template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a56dbcc61c27689659fa1d94a19bd2560"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a56dbcc61c27689659fa1d94a19bd2560">contains</a> (KeyType &amp;&amp;key) const</td></tr>
<tr class="memdesc:a56dbcc61c27689659fa1d94a19bd2560"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object  <br /></td></tr>
<tr class="separator:a56dbcc61c27689659fa1d94a19bd2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7241e94ede5aacd7efca401cf0638a" id="r_a0d7241e94ede5aacd7efca401cf0638a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0d7241e94ede5aacd7efca401cf0638a">contains</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a0d7241e94ede5aacd7efca401cf0638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the existence of an element in a JSON object given a JSON pointer  <br /></td></tr>
<tr class="separator:a0d7241e94ede5aacd7efca401cf0638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b0b7791993c4ae48532f9b427bc518" id="r_a74b0b7791993c4ae48532f9b427bc518"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74b0b7791993c4ae48532f9b427bc518"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a74b0b7791993c4ae48532f9b427bc518">contains</a> (const typename ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr) const</td></tr>
<tr class="separator:a74b0b7791993c4ae48532f9b427bc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">capacity</h2></td></tr>
<tr class="memitem:aec22254018236106f357bc3ed7c20399" id="r_aec22254018236106f357bc3ed7c20399"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aec22254018236106f357bc3ed7c20399">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aec22254018236106f357bc3ed7c20399"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether the container is empty.  <br /></td></tr>
<tr class="separator:aec22254018236106f357bc3ed7c20399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769537e4631ccd39b5ab3753547a8274" id="r_a769537e4631ccd39b5ab3753547a8274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a> () const noexcept</td></tr>
<tr class="memdesc:a769537e4631ccd39b5ab3753547a8274"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of elements  <br /></td></tr>
<tr class="separator:a769537e4631ccd39b5ab3753547a8274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d46cece4c9f4700e4d6ac9565bde067" id="r_a6d46cece4c9f4700e4d6ac9565bde067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6d46cece4c9f4700e4d6ac9565bde067">max_size</a> () const noexcept</td></tr>
<tr class="memdesc:a6d46cece4c9f4700e4d6ac9565bde067"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the maximum possible number of elements  <br /></td></tr>
<tr class="separator:a6d46cece4c9f4700e4d6ac9565bde067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Pointer functions</h2></td></tr>
<tr class="memitem:a2f0b9af87d5c9c8bed6dc0e165af3147" id="r_a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a2f0b9af87d5c9c8bed6dc0e165af3147">operator[]</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr)</td></tr>
<tr class="memdesc:a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <br /></td></tr>
<tr class="separator:a2f0b9af87d5c9c8bed6dc0e165af3147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca526e935364213525dd8e23397472c" id="r_a6ca526e935364213525dd8e23397472c"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6ca526e935364213525dd8e23397472c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a6ca526e935364213525dd8e23397472c">operator[]</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr)</td></tr>
<tr class="separator:a6ca526e935364213525dd8e23397472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba36b6659d266fd0299446a20b611d9" id="r_a9ba36b6659d266fd0299446a20b611d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9ba36b6659d266fd0299446a20b611d9">operator[]</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:a9ba36b6659d266fd0299446a20b611d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <br /></td></tr>
<tr class="separator:a9ba36b6659d266fd0299446a20b611d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed2a2a59c3437b4b57e4f0b03e4333a" id="r_a8ed2a2a59c3437b4b57e4f0b03e4333a"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8ed2a2a59c3437b4b57e4f0b03e4333a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a8ed2a2a59c3437b4b57e4f0b03e4333a">operator[]</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr) const</td></tr>
<tr class="separator:a8ed2a2a59c3437b4b57e4f0b03e4333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5249193b987b187efa74353c9b5b43" id="r_a0a5249193b987b187efa74353c9b5b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a0a5249193b987b187efa74353c9b5b43">at</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr)</td></tr>
<tr class="memdesc:a0a5249193b987b187efa74353c9b5b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <br /></td></tr>
<tr class="separator:a0a5249193b987b187efa74353c9b5b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1daebc285b407ce97a080a90ead681a" id="r_af1daebc285b407ce97a080a90ead681a"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af1daebc285b407ce97a080a90ead681a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#af1daebc285b407ce97a080a90ead681a">at</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr)</td></tr>
<tr class="separator:af1daebc285b407ce97a080a90ead681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d4becb69fb528514395b46d123b69a" id="r_ac7d4becb69fb528514395b46d123b69a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#ac7d4becb69fb528514395b46d123b69a">at</a> (const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;ptr) const</td></tr>
<tr class="memdesc:ac7d4becb69fb528514395b46d123b69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">access specified element via JSON Pointer  <br /></td></tr>
<tr class="separator:ac7d4becb69fb528514395b46d123b69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a6aa1ba673eda8f96506b8dfc243df" id="r_aa4a6aa1ba673eda8f96506b8dfc243df"><td class="memTemplParams" colspan="2">template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa4a6aa1ba673eda8f96506b8dfc243df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbasic__json.html#aa4a6aa1ba673eda8f96506b8dfc243df">at</a> (const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;ptr) const</td></tr>
<tr class="separator:aa4a6aa1ba673eda8f96506b8dfc243df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331162af6752277de4d1e476bb3f6bb" id="r_a9331162af6752277de4d1e476bb3f6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a9331162af6752277de4d1e476bb3f6bb">flatten</a> () const</td></tr>
<tr class="memdesc:a9331162af6752277de4d1e476bb3f6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return flattened JSON value  <br /></td></tr>
<tr class="separator:a9331162af6752277de4d1e476bb3f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ef6a13e3205323b67700c3e5e672c9" id="r_a91ef6a13e3205323b67700c3e5e672c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbasic__json.html">basic_json</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a91ef6a13e3205323b67700c3e5e672c9">unflatten</a> () const</td></tr>
<tr class="memdesc:a91ef6a13e3205323b67700c3e5e672c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">unflatten a previously flattened JSON value  <br /></td></tr>
<tr class="separator:a91ef6a13e3205323b67700c3e5e672c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">JSON Merge Patch functions</h2></td></tr>
<tr class="memitem:a1c7ab88eb6d043b434cd9e0b68ec7321" id="r_a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbasic__json.html#a1c7ab88eb6d043b434cd9e0b68ec7321">merge_patch</a> (const <a class="el" href="classbasic__json.html">basic_json</a> &amp;apply_patch)</td></tr>
<tr class="memdesc:a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies a JSON Merge Patch  <br /></td></tr>
<tr class="separator:a1c7ab88eb6d043b434cd9e0b68ec7321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType = std::vector&lt;std::uint8_t&gt;&gt;<br />
class basic_json&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;</div><p>namespace for Niels Lohmann </p>
<p>a class to store JSON values </p><dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/">https://json.nlohmann.me/api/basic_json/</a></dd>
<dd>
<a href="https://github.com/nlohmann">https://github.com/nlohmann</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0</dd></dl>
<p>a class to store JSON values</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19273">19273</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a485873eed243b6ca7e30c96130a5ec2d" name="a485873eed243b6ca7e30c96130a5ec2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485873eed243b6ca7e30c96130a5ec2d">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::allocator_type =  AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the allocator type </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19395">19395</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7cf28eb944e7c06aa47f0bc3a9d6f454" name="a7cf28eb944e7c06aa47f0bc3a9d6f454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf28eb944e7c06aa47f0bc3a9d6f454">&#9670;&#160;</a></span>array_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::array_t =  ArrayType&lt;<a class="el" href="classbasic__json.html">basic_json</a>, AllocatorType&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array_t/">https://json.nlohmann.me/api/basic_json/array_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19519">19519</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aabedd827d4943302a4cf0413956341db" name="aabedd827d4943302a4cf0413956341db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabedd827d4943302a4cf0413956341db">&#9670;&#160;</a></span>binary_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary_t =  nlohmann::byte_container_with_subtype&lt;BinaryType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a packed binary type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary_t/">https://json.nlohmann.me/api/basic_json/binary_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19543">19543</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af396ac808d774d4ea0db4c7da11ce569" name="af396ac808d774d4ea0db4c7da11ce569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396ac808d774d4ea0db4c7da11ce569">&#9670;&#160;</a></span>boolean_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::boolean_t =  BooleanType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/boolean_t/">https://json.nlohmann.me/api/basic_json/boolean_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19527">19527</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2373759df24fffb094fd7789c726abe1" name="a2373759df24fffb094fd7789c726abe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2373759df24fffb094fd7789c726abe1">&#9670;&#160;</a></span>cbor_tag_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cbor_tag_handler_t =  <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">detail::cbor_tag_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat CBOR tags </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19346">19346</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8f3470194c24d964e40d9be0b177cbc3" name="a8f3470194c24d964e40d9be0b177cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3470194c24d964e40d9be0b177cbc3">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_iterator =  iter_impl&lt;const <a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19405">19405</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a28ac2566e6ab084c5c1e044d132aa4a3" name="a28ac2566e6ab084c5c1e044d132aa4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ac2566e6ab084c5c1e044d132aa4a3">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_pointer =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19400">19400</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac9d32cf719260c22b33bab670cd5602b" name="ac9d32cf719260c22b33bab670cd5602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d32cf719260c22b33bab670cd5602b">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_reference =  const <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element const reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19387">19387</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2aa7d4c7719ab82aa8c77a83642c843f" name="a2aa7d4c7719ab82aa8c77a83642c843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa7d4c7719ab82aa8c77a83642c843f">&#9670;&#160;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::const_reverse_iterator =  json_reverse_iterator&lt;typename <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">basic_json::const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a const reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19409">19409</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af2fea7b2039e4308b8e8c22a0dd5b570" name="af2fea7b2039e4308b8e8c22a0dd5b570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fea7b2039e4308b8e8c22a0dd5b570">&#9670;&#160;</a></span>default_object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::default_object_comparator_t =  std::less&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default object key comparator type The actual object key comparator type (<a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a>) may be different. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/default_object_comparator_t/">https://json.nlohmann.me/api/basic_json/default_object_comparator_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19506">19506</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2fe32d636c1b78861884dde9716b22b6" name="a2fe32d636c1b78861884dde9716b22b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe32d636c1b78861884dde9716b22b6">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::difference_type =  std::ptrdiff_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent differences between iterators </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19390">19390</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abbc0836764d6ba2580ee0c775ceeeab7" name="abbc0836764d6ba2580ee0c775ceeeab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc0836764d6ba2580ee0c775ceeeab7">&#9670;&#160;</a></span>error_handler_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::error_handler_t =  <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">detail::error_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to treat decoding errors </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19344">19344</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab671bd0e5eef59e58d362e6cd8937633" name="ab671bd0e5eef59e58d362e6cd8937633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab671bd0e5eef59e58d362e6cd8937633">&#9670;&#160;</a></span>exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::exception =  <a class="el" href="classdetail_1_1exception.html">detail::exception</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19362">19362</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2063ed828cd027216c549ac48527a562" name="a2063ed828cd027216c549ac48527a562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2063ed828cd027216c549ac48527a562">&#9670;&#160;</a></span>initializer_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::initializer_list_t =  std::initializer_list&lt;<a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>helper type for initializer lists of <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> values </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19348">19348</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0bcf8e1a03522bf1ea9bb6fb49251dab" name="a0bcf8e1a03522bf1ea9bb6fb49251dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcf8e1a03522bf1ea9bb6fb49251dab">&#9670;&#160;</a></span>input_format_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::input_format_t =  detail::input_format_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19350">19350</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a9dbe40f1942d8e38ab2effc7988b05ea" name="a9dbe40f1942d8e38ab2effc7988b05ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbe40f1942d8e38ab2effc7988b05ea">&#9670;&#160;</a></span>invalid_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::invalid_iterator =  <a class="el" href="classdetail_1_1invalid__iterator.html">detail::invalid_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19364">19364</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a2935c91b82c8e586b1dd68ad665075a6" name="a2935c91b82c8e586b1dd68ad665075a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2935c91b82c8e586b1dd68ad665075a6">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator =  iter_impl&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19403">19403</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7c7e3533ab09b9e9d24a516379961a93" name="a7c7e3533ab09b9e9d24a516379961a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7e3533ab09b9e9d24a516379961a93">&#9670;&#160;</a></span>json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classjson__pointer.html">::json_pointer</a> =  ::nlohmann::json_pointer&lt;StringType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JSON Pointer, see nlohmann::json_pointer. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19340">19340</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a0c291e7719ceccef199189e5ee4ecd4f" name="a0c291e7719ceccef199189e5ee4ecd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c291e7719ceccef199189e5ee4ecd4f">&#9670;&#160;</a></span>json_sax_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::json_sax_t =  <a class="el" href="structjson__sax.html">json_sax</a>&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAX interface type, see nlohmann::json_sax. </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19352">19352</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a5e8738738b9e5c4cdc6519e3799de38a" name="a5e8738738b9e5c4cdc6519e3799de38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8738738b9e5c4cdc6519e3799de38a">&#9670;&#160;</a></span>json_serializer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename SFINAE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::json_serializer =  JSONSerializer&lt;T, SFINAE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19342">19342</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a1fd24dfabbdd1dc35513c82244633ca4" name="a1fd24dfabbdd1dc35513c82244633ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd24dfabbdd1dc35513c82244633ca4">&#9670;&#160;</a></span>number_float_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_float_t =  NumberFloatType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (floating-point) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_float_t/">https://json.nlohmann.me/api/basic_json/number_float_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19539">19539</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a8b702448867b892700c768db4208a670" name="a8b702448867b892700c768db4208a670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b702448867b892700c768db4208a670">&#9670;&#160;</a></span>number_integer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_integer_t =  NumberIntegerType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (integer) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_integer_t/">https://json.nlohmann.me/api/basic_json/number_integer_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19531">19531</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aebb9c6a13e947a86e2a13fbe6ebd77f4" name="aebb9c6a13e947a86e2a13fbe6ebd77f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb9c6a13e947a86e2a13fbe6ebd77f4">&#9670;&#160;</a></span>number_unsigned_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::number_unsigned_t =  NumberUnsignedType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a number (unsigned) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/number_unsigned_t/">https://json.nlohmann.me/api/basic_json/number_unsigned_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19535">19535</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a7866de66dd6c55590efa7cf0ef79e74f" name="a7866de66dd6c55590efa7cf0ef79e74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7866de66dd6c55590efa7cf0ef79e74f">&#9670;&#160;</a></span>object_comparator_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object_comparator_t =  detail::actual_object_comparator_t&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>object key comparator type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_comparator_t/">https://json.nlohmann.me/api/basic_json/object_comparator_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19547">19547</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a770279b71f788fe3f76411eedf5b1956" name="a770279b71f788fe3f76411eedf5b1956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770279b71f788fe3f76411eedf5b1956">&#9670;&#160;</a></span>object_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object_t =  ObjectType&lt;StringType, <a class="el" href="classbasic__json.html">basic_json</a>, <a class="el" href="classbasic__json.html#af2fea7b2039e4308b8e8c22a0dd5b570">default_object_comparator_t</a>, AllocatorType&lt;std::pair&lt;const StringType, <a class="el" href="classbasic__json.html">basic_json</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object_t/">https://json.nlohmann.me/api/basic_json/object_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19511">19511</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aab2ef54e2baf390523dd6a5bc4ccccef" name="aab2ef54e2baf390523dd6a5bc4ccccef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2ef54e2baf390523dd6a5bc4ccccef">&#9670;&#160;</a></span>other_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::other_error =  <a class="el" href="classdetail_1_1other__error.html">detail::other_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19367">19367</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a144d3cb5914a0a12c2f5d2b982a2214a" name="a144d3cb5914a0a12c2f5d2b982a2214a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144d3cb5914a0a12c2f5d2b982a2214a">&#9670;&#160;</a></span>out_of_range</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::out_of_range =  <a class="el" href="classdetail_1_1out__of__range.html">detail::out_of_range</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19366">19366</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ab0da064d46469bb762afcecd1c361f1a" name="ab0da064d46469bb762afcecd1c361f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da064d46469bb762afcecd1c361f1a">&#9670;&#160;</a></span>parse_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse_error =  <a class="el" href="classdetail_1_1parse__error.html">detail::parse_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19363">19363</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="adfe811a234bbc90f4a0d3c6488272186" name="adfe811a234bbc90f4a0d3c6488272186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe811a234bbc90f4a0d3c6488272186">&#9670;&#160;</a></span>parse_event_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parse_event_t =  detail::parse_event_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parser event types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parse_event_t/">https://json.nlohmann.me/api/basic_json/parse_event_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19966">19966</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a144c201819ed5c9d9f58b59eb64fb454" name="a144c201819ed5c9d9f58b59eb64fb454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c201819ed5c9d9f58b59eb64fb454">&#9670;&#160;</a></span>parser_callback_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::parser_callback_t =  detail::parser_callback_t&lt;<a class="el" href="classbasic__json.html">basic_json</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>per-element parser callback type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/parser_callback_t/">https://json.nlohmann.me/api/basic_json/parser_callback_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19970">19970</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac02a5d1bf4e9cd1bdec90e97f4ea6f95" name="ac02a5d1bf4e9cd1bdec90e97f4ea6f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02a5d1bf4e9cd1bdec90e97f4ea6f95">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::pointer =  typename std::allocator_traits&lt;<a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>&gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element pointer </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19398">19398</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aa95f366d506aca733799e4c310927b5d" name="aa95f366d506aca733799e4c310927b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95f366d506aca733799e4c310927b5d">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::reference =  <a class="el" href="classbasic__json.html#ad9e6b75c7cc0db798b91e52edca5f4ca">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of an element reference </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19385">19385</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac639cd1b4238d158286e7e21b5829709" name="ac639cd1b4238d158286e7e21b5829709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac639cd1b4238d158286e7e21b5829709">&#9670;&#160;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::reverse_iterator =  json_reverse_iterator&lt;typename <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">basic_json::iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a reverse iterator for a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19407">19407</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a883ac4726a370dbf98474944ec0a0acc" name="a883ac4726a370dbf98474944ec0a0acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883ac4726a370dbf98474944ec0a0acc">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::size_type =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type to represent container sizes </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19392">19392</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a807932caebf0d62abc8642b9d1a2e5ef" name="a807932caebf0d62abc8642b9d1a2e5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807932caebf0d62abc8642b9d1a2e5ef">&#9670;&#160;</a></span>string_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::string_t =  StringType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a type for a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/string_t/">https://json.nlohmann.me/api/basic_json/string_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19523">19523</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a14db56e21a2c72186979c6f6f0469557" name="a14db56e21a2c72186979c6f6f0469557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db56e21a2c72186979c6f6f0469557">&#9670;&#160;</a></span>type_error</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type_error =  <a class="el" href="classdetail_1_1type__error.html">detail::type_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19365">19365</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aea7fcb38964d53d35e84a80b8b1e8d11" name="aea7fcb38964d53d35e84a80b8b1e8d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7fcb38964d53d35e84a80b8b1e8d11">&#9670;&#160;</a></span>value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value_t =  <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19338">19338</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ad9e6b75c7cc0db798b91e52edca5f4ca" name="ad9e6b75c7cc0db798b91e52edca5f4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e6b75c7cc0db798b91e52edca5f4ca">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value_type =  <a class="el" href="classbasic__json.html">basic_json</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type of elements in a <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a> container </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19382">19382</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee75ecbdc67fc5faa1228c949c59ff27" name="aee75ecbdc67fc5faa1228c949c59ff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee75ecbdc67fc5faa1228c949c59ff27">&#9670;&#160;</a></span>basic_json() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create an empty value with a given type </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19983">19983</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">19984</span>        : m_type(v), <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>(v)</div>
<div class="line"><span class="lineno">19985</span>    {</div>
<div class="line"><span class="lineno">19986</span>        assert_invariant();</div>
<div class="line"><span class="lineno">19987</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a34bc6074bd3f9ac2bdab12ebc02d70f5"><div class="ttname"><a href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">basic_json::m_value</a></div><div class="ttdeci">json_value m_value</div><div class="ttdoc">the value of the current element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23365">json.hpp:23365</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6f1bad4745ddb574540f71cdbcd532f" name="ac6f1bad4745ddb574540f71cdbcd532f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f1bad4745ddb574540f71cdbcd532f">&#9670;&#160;</a></span>basic_json() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a null object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19991">19991</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">19992</span>        : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::null)</div>
<div class="line"><span class="lineno">19993</span>    {</div>
<div class="line"><span class="lineno">19994</span>        assert_invariant();</div>
<div class="line"><span class="lineno">19995</span>    }</div>
<div class="ttc" id="aclassbasic__json_html"><div class="ttname"><a href="classbasic__json.html">basic_json</a></div><div class="ttdoc">namespace for Niels Lohmann</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19273">json.hpp:19274</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b1f9ac7c7ebcff72d00869e974a6249" name="a9b1f9ac7c7ebcff72d00869e974a6249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1f9ac7c7ebcff72d00869e974a6249">&#9670;&#160;</a></span>basic_json() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename CompatibleType , typename U  = detail::uncvref_t&lt;CompatibleType&gt;, detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1is__compatible__type.html">detail::is_compatible_type</a>&lt; basic_json_t, U &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">CompatibleType &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from compatible types </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20003">20003</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20006</span>    {</div>
<div class="line"><span class="lineno">20007</span>        JSONSerializer&lt;U&gt;::to_json(*<span class="keyword">this</span>, std::forward&lt;CompatibleType&gt;(val));</div>
<div class="line"><span class="lineno">20008</span>        set_parents();</div>
<div class="line"><span class="lineno">20009</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20010</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94560a1edd72d60310c54c9b2d9f1ad2" name="a94560a1edd72d60310c54c9b2d9f1ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94560a1edd72d60310c54c9b2d9f1ad2">&#9670;&#160;</a></span>basic_json() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;!std::is_same&lt; <a class="el" href="classbasic__json.html">basic_json</a>, BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const BasicJsonType &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an existing one </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20017">20017</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20018</span>    {</div>
<div class="line"><span class="lineno">20019</span>        <span class="keyword">using </span>other_boolean_t = <span class="keyword">typename</span> BasicJsonType::boolean_t;</div>
<div class="line"><span class="lineno">20020</span>        <span class="keyword">using </span>other_number_float_t = <span class="keyword">typename</span> BasicJsonType::number_float_t;</div>
<div class="line"><span class="lineno">20021</span>        <span class="keyword">using </span>other_number_integer_t = <span class="keyword">typename</span> BasicJsonType::number_integer_t;</div>
<div class="line"><span class="lineno">20022</span>        <span class="keyword">using </span>other_number_unsigned_t = <span class="keyword">typename</span> BasicJsonType::number_unsigned_t;</div>
<div class="line"><span class="lineno">20023</span>        <span class="keyword">using </span>other_string_t = <span class="keyword">typename</span> BasicJsonType::string_t;</div>
<div class="line"><span class="lineno">20024</span>        <span class="keyword">using </span>other_object_t = <span class="keyword">typename</span> BasicJsonType::object_t;</div>
<div class="line"><span class="lineno">20025</span>        <span class="keyword">using </span>other_array_t = <span class="keyword">typename</span> BasicJsonType::array_t;</div>
<div class="line"><span class="lineno">20026</span>        <span class="keyword">using </span>other_binary_t = <span class="keyword">typename</span> BasicJsonType::binary_t;</div>
<div class="line"><span class="lineno">20027</span> </div>
<div class="line"><span class="lineno">20028</span>        <span class="keywordflow">switch</span> (val.type())</div>
<div class="line"><span class="lineno">20029</span>        {</div>
<div class="line"><span class="lineno">20030</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">20031</span>                JSONSerializer&lt;other_boolean_t&gt;::to_json(*<span class="keyword">this</span>, val.template get&lt;other_boolean_t&gt;());</div>
<div class="line"><span class="lineno">20032</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20033</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">20034</span>                JSONSerializer&lt;other_number_float_t&gt;::to_json(*<span class="keyword">this</span>, val.template get&lt;other_number_float_t&gt;());</div>
<div class="line"><span class="lineno">20035</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20036</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">20037</span>                JSONSerializer&lt;other_number_integer_t&gt;::to_json(*<span class="keyword">this</span>, val.template get&lt;other_number_integer_t&gt;());</div>
<div class="line"><span class="lineno">20038</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20039</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">20040</span>                JSONSerializer&lt;other_number_unsigned_t&gt;::to_json(*<span class="keyword">this</span>, val.template get&lt;other_number_unsigned_t&gt;());</div>
<div class="line"><span class="lineno">20041</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20042</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">20043</span>                JSONSerializer&lt;other_string_t&gt;::to_json(*<span class="keyword">this</span>, val.template get_ref&lt;const other_string_t&amp;&gt;());</div>
<div class="line"><span class="lineno">20044</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20045</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">20046</span>                JSONSerializer&lt;other_object_t&gt;::to_json(*<span class="keyword">this</span>, val.template get_ref&lt;const other_object_t&amp;&gt;());</div>
<div class="line"><span class="lineno">20047</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20048</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">20049</span>                JSONSerializer&lt;other_array_t&gt;::to_json(*<span class="keyword">this</span>, val.template get_ref&lt;const other_array_t&amp;&gt;());</div>
<div class="line"><span class="lineno">20050</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20051</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">20052</span>                JSONSerializer&lt;other_binary_t&gt;::to_json(*<span class="keyword">this</span>, val.template get_ref&lt;const other_binary_t&amp;&gt;());</div>
<div class="line"><span class="lineno">20053</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20054</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">20055</span>                *<span class="keyword">this</span> = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">20056</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20057</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">20058</span>                m_type = value_t::discarded;</div>
<div class="line"><span class="lineno">20059</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20060</span>            <span class="keywordflow">default</span>:            <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">20061</span>                JSON_ASSERT(<span class="keyword">false</span>); <span class="comment">// NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">20062</span>        }</div>
<div class="line"><span class="lineno">20063</span>        JSON_ASSERT(m_type == val.type());</div>
<div class="line"><span class="lineno">20064</span>        set_parents();</div>
<div class="line"><span class="lineno">20065</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20066</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec3d71dec8062753efb67860b7cca1a1" name="aec3d71dec8062753efb67860b7cca1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3d71dec8062753efb67860b7cca1a1">&#9670;&#160;</a></span>basic_json() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_deduction</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>&#160;</td>
          <td class="paramname"><em>manual_type</em> = <code>value_t::array</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a container (array or object) from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20070">20070</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20073</span>    {</div>
<div class="line"><span class="lineno">20074</span>        <span class="comment">// check if each element is an array with two elements whose first</span></div>
<div class="line"><span class="lineno">20075</span>        <span class="comment">// element is a string</span></div>
<div class="line"><span class="lineno">20076</span>        <span class="keywordtype">bool</span> is_an_object = std::all_of(init.begin(), init.end(),</div>
<div class="line"><span class="lineno">20077</span>                                        [](<span class="keyword">const</span> <a class="code hl_class" href="classdetail_1_1json__ref.html">detail::json_ref&lt;basic_json&gt;</a>&amp; element_ref)</div>
<div class="line"><span class="lineno">20078</span>        {</div>
<div class="line"><span class="lineno">20079</span>            return element_ref-&gt;is_array() &amp;&amp; element_ref-&gt;size() == 2 &amp;&amp; (*element_ref)[0].is_string();</div>
<div class="line"><span class="lineno">20080</span>        });</div>
<div class="line"><span class="lineno">20081</span> </div>
<div class="line"><span class="lineno">20082</span>        <span class="comment">// adjust type if type deduction is not wanted</span></div>
<div class="line"><span class="lineno">20083</span>        <span class="keywordflow">if</span> (!type_deduction)</div>
<div class="line"><span class="lineno">20084</span>        {</div>
<div class="line"><span class="lineno">20085</span>            <span class="comment">// if array is wanted, do not create an object though possible</span></div>
<div class="line"><span class="lineno">20086</span>            <span class="keywordflow">if</span> (manual_type == value_t::array)</div>
<div class="line"><span class="lineno">20087</span>            {</div>
<div class="line"><span class="lineno">20088</span>                is_an_object = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">20089</span>            }</div>
<div class="line"><span class="lineno">20090</span> </div>
<div class="line"><span class="lineno">20091</span>            <span class="comment">// if object is wanted but impossible, throw an exception</span></div>
<div class="line"><span class="lineno">20092</span>            <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object &amp;&amp; !is_an_object))</div>
<div class="line"><span class="lineno">20093</span>            {</div>
<div class="line"><span class="lineno">20094</span>                JSON_THROW(type_error::create(301, <span class="stringliteral">&quot;cannot create object from initializer list&quot;</span>, <span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno">20095</span>            }</div>
<div class="line"><span class="lineno">20096</span>        }</div>
<div class="line"><span class="lineno">20097</span> </div>
<div class="line"><span class="lineno">20098</span>        <span class="keywordflow">if</span> (is_an_object)</div>
<div class="line"><span class="lineno">20099</span>        {</div>
<div class="line"><span class="lineno">20100</span>            <span class="comment">// the initializer list is a list of pairs -&gt; create object</span></div>
<div class="line"><span class="lineno">20101</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">20102</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::object;</div>
<div class="line"><span class="lineno">20103</span> </div>
<div class="line"><span class="lineno">20104</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; element_ref : init)</div>
<div class="line"><span class="lineno">20105</span>            {</div>
<div class="line"><span class="lineno">20106</span>                <span class="keyword">auto</span> element = element_ref.moved_or_copied();</div>
<div class="line"><span class="lineno">20107</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;emplace(</div>
<div class="line"><span class="lineno">20108</span>                    std::move(*((*element.m_value.array)[0].m_value.string)),</div>
<div class="line"><span class="lineno">20109</span>                    std::move((*element.m_value.array)[1]));</div>
<div class="line"><span class="lineno">20110</span>            }</div>
<div class="line"><span class="lineno">20111</span>        }</div>
<div class="line"><span class="lineno">20112</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">20113</span>        {</div>
<div class="line"><span class="lineno">20114</span>            <span class="comment">// the initializer list describes an array -&gt; create array</span></div>
<div class="line"><span class="lineno">20115</span>            m_type = value_t::array;</div>
<div class="line"><span class="lineno">20116</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array = create&lt;array_t&gt;(init.begin(), init.end());</div>
<div class="line"><span class="lineno">20117</span>        }</div>
<div class="line"><span class="lineno">20118</span> </div>
<div class="line"><span class="lineno">20119</span>        set_parents();</div>
<div class="line"><span class="lineno">20120</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20121</span>    }</div>
<div class="ttc" id="aclassdetail_1_1json__ref_html"><div class="ttname"><a href="classdetail_1_1json__ref.html">detail::json_ref</a></div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l14695">json.hpp:14696</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad382c9c9e03c410004150c9d6b9f0bd9" name="ad382c9c9e03c410004150c9d6b9f0bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad382c9c9e03c410004150c9d6b9f0bd9">&#9670;&#160;</a></span>basic_json() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct an array with count copies of given value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20185">20185</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20186</span>        : m_type(value_t::array)</div>
<div class="line"><span class="lineno">20187</span>    {</div>
<div class="line"><span class="lineno">20188</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array = create&lt;array_t&gt;(cnt, val);</div>
<div class="line"><span class="lineno">20189</span>        set_parents();</div>
<div class="line"><span class="lineno">20190</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20191</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a12f2c1a11dd6e84196132ea77a99572a" name="a12f2c1a11dd6e84196132ea77a99572a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f2c1a11dd6e84196132ea77a99572a">&#9670;&#160;</a></span>basic_json() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class InputIT , typename std::enable_if&lt; std::is_same&lt; InputIT, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; InputIT, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct a JSON container given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20198">20198</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20199</span>    {</div>
<div class="line"><span class="lineno">20200</span>        JSON_ASSERT(first.m_object != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">20201</span>        JSON_ASSERT(last.m_object != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">20202</span> </div>
<div class="line"><span class="lineno">20203</span>        <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><span class="lineno">20204</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))</div>
<div class="line"><span class="lineno">20205</span>        {</div>
<div class="line"><span class="lineno">20206</span>            JSON_THROW(invalid_iterator::create(201, <span class="stringliteral">&quot;iterators are not compatible&quot;</span>, <span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno">20207</span>        }</div>
<div class="line"><span class="lineno">20208</span> </div>
<div class="line"><span class="lineno">20209</span>        <span class="comment">// copy type from first iterator</span></div>
<div class="line"><span class="lineno">20210</span>        m_type = first.m_object-&gt;m_type;</div>
<div class="line"><span class="lineno">20211</span> </div>
<div class="line"><span class="lineno">20212</span>        <span class="comment">// check if iterator range is complete for primitive values</span></div>
<div class="line"><span class="lineno">20213</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">20214</span>        {</div>
<div class="line"><span class="lineno">20215</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">20216</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">20217</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">20218</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">20219</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">20220</span>            {</div>
<div class="line"><span class="lineno">20221</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()</div>
<div class="line"><span class="lineno">20222</span>                                         || !last.m_it.primitive_iterator.is_end()))</div>
<div class="line"><span class="lineno">20223</span>                {</div>
<div class="line"><span class="lineno">20224</span>                    JSON_THROW(invalid_iterator::create(204, <span class="stringliteral">&quot;iterators out of range&quot;</span>, first.m_object));</div>
<div class="line"><span class="lineno">20225</span>                }</div>
<div class="line"><span class="lineno">20226</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20227</span>            }</div>
<div class="line"><span class="lineno">20228</span> </div>
<div class="line"><span class="lineno">20229</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">20230</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">20231</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">20232</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">20233</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">20234</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">20235</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20236</span>        }</div>
<div class="line"><span class="lineno">20237</span> </div>
<div class="line"><span class="lineno">20238</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">20239</span>        {</div>
<div class="line"><span class="lineno">20240</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">20241</span>            {</div>
<div class="line"><span class="lineno">20242</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_integer = first.m_object-&gt;m_value.number_integer;</div>
<div class="line"><span class="lineno">20243</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20244</span>            }</div>
<div class="line"><span class="lineno">20245</span> </div>
<div class="line"><span class="lineno">20246</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">20247</span>            {</div>
<div class="line"><span class="lineno">20248</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_unsigned = first.m_object-&gt;m_value.number_unsigned;</div>
<div class="line"><span class="lineno">20249</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20250</span>            }</div>
<div class="line"><span class="lineno">20251</span> </div>
<div class="line"><span class="lineno">20252</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">20253</span>            {</div>
<div class="line"><span class="lineno">20254</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_float = first.m_object-&gt;m_value.number_float;</div>
<div class="line"><span class="lineno">20255</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20256</span>            }</div>
<div class="line"><span class="lineno">20257</span> </div>
<div class="line"><span class="lineno">20258</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">20259</span>            {</div>
<div class="line"><span class="lineno">20260</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.boolean = first.m_object-&gt;m_value.boolean;</div>
<div class="line"><span class="lineno">20261</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20262</span>            }</div>
<div class="line"><span class="lineno">20263</span> </div>
<div class="line"><span class="lineno">20264</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">20265</span>            {</div>
<div class="line"><span class="lineno">20266</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *first.m_object-&gt;m_value.string;</div>
<div class="line"><span class="lineno">20267</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20268</span>            }</div>
<div class="line"><span class="lineno">20269</span> </div>
<div class="line"><span class="lineno">20270</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">20271</span>            {</div>
<div class="line"><span class="lineno">20272</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object = create&lt;object_t&gt;(first.m_it.object_iterator,</div>
<div class="line"><span class="lineno">20273</span>                                                  last.m_it.object_iterator);</div>
<div class="line"><span class="lineno">20274</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20275</span>            }</div>
<div class="line"><span class="lineno">20276</span> </div>
<div class="line"><span class="lineno">20277</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">20278</span>            {</div>
<div class="line"><span class="lineno">20279</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array = create&lt;array_t&gt;(first.m_it.array_iterator,</div>
<div class="line"><span class="lineno">20280</span>                                                last.m_it.array_iterator);</div>
<div class="line"><span class="lineno">20281</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20282</span>            }</div>
<div class="line"><span class="lineno">20283</span> </div>
<div class="line"><span class="lineno">20284</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">20285</span>            {</div>
<div class="line"><span class="lineno">20286</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *first.m_object-&gt;m_value.binary;</div>
<div class="line"><span class="lineno">20287</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20288</span>            }</div>
<div class="line"><span class="lineno">20289</span> </div>
<div class="line"><span class="lineno">20290</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">20291</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">20292</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">20293</span>                JSON_THROW(invalid_iterator::create(206, detail::concat(<span class="stringliteral">&quot;cannot construct with iterators from &quot;</span>, first.m_object-&gt;type_name()), first.m_object));</div>
<div class="line"><span class="lineno">20294</span>        }</div>
<div class="line"><span class="lineno">20295</span> </div>
<div class="line"><span class="lineno">20296</span>        set_parents();</div>
<div class="line"><span class="lineno">20297</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20298</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33adf04c1d841c42c0eeaf05252aedc3" name="a33adf04c1d841c42c0eeaf05252aedc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33adf04c1d841c42c0eeaf05252aedc3">&#9670;&#160;</a></span>basic_json() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename JsonRef , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1is__json__ref.html">detail::is_json_ref</a>&lt; JsonRef &gt;, std::is_same&lt; typename JsonRef::value_type, <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const JsonRef &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20308">20308</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20308</span>: <a class="code hl_class" href="classbasic__json.html">basic_json</a>(ref.moved_or_copied()) {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac62e476c88b91f1f4329bb4901cafc4c" name="ac62e476c88b91f1f4329bb4901cafc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62e476c88b91f1f4329bb4901cafc4c">&#9670;&#160;</a></span>basic_json() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20312">20312</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20313</span>        : m_type(other.m_type)</div>
<div class="line"><span class="lineno">20314</span>    {</div>
<div class="line"><span class="lineno">20315</span>        <span class="comment">// check of passed value is valid</span></div>
<div class="line"><span class="lineno">20316</span>        other.assert_invariant();</div>
<div class="line"><span class="lineno">20317</span> </div>
<div class="line"><span class="lineno">20318</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">20319</span>        {</div>
<div class="line"><span class="lineno">20320</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">20321</span>            {</div>
<div class="line"><span class="lineno">20322</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object;</div>
<div class="line"><span class="lineno">20323</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20324</span>            }</div>
<div class="line"><span class="lineno">20325</span> </div>
<div class="line"><span class="lineno">20326</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">20327</span>            {</div>
<div class="line"><span class="lineno">20328</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array;</div>
<div class="line"><span class="lineno">20329</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20330</span>            }</div>
<div class="line"><span class="lineno">20331</span> </div>
<div class="line"><span class="lineno">20332</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">20333</span>            {</div>
<div class="line"><span class="lineno">20334</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string;</div>
<div class="line"><span class="lineno">20335</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20336</span>            }</div>
<div class="line"><span class="lineno">20337</span> </div>
<div class="line"><span class="lineno">20338</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">20339</span>            {</div>
<div class="line"><span class="lineno">20340</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.boolean;</div>
<div class="line"><span class="lineno">20341</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20342</span>            }</div>
<div class="line"><span class="lineno">20343</span> </div>
<div class="line"><span class="lineno">20344</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">20345</span>            {</div>
<div class="line"><span class="lineno">20346</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_integer;</div>
<div class="line"><span class="lineno">20347</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20348</span>            }</div>
<div class="line"><span class="lineno">20349</span> </div>
<div class="line"><span class="lineno">20350</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">20351</span>            {</div>
<div class="line"><span class="lineno">20352</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_unsigned;</div>
<div class="line"><span class="lineno">20353</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20354</span>            }</div>
<div class="line"><span class="lineno">20355</span> </div>
<div class="line"><span class="lineno">20356</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">20357</span>            {</div>
<div class="line"><span class="lineno">20358</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_float;</div>
<div class="line"><span class="lineno">20359</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20360</span>            }</div>
<div class="line"><span class="lineno">20361</span> </div>
<div class="line"><span class="lineno">20362</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">20363</span>            {</div>
<div class="line"><span class="lineno">20364</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = *other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary;</div>
<div class="line"><span class="lineno">20365</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20366</span>            }</div>
<div class="line"><span class="lineno">20367</span> </div>
<div class="line"><span class="lineno">20368</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">20369</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">20370</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">20371</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">20372</span>        }</div>
<div class="line"><span class="lineno">20373</span> </div>
<div class="line"><span class="lineno">20374</span>        set_parents();</div>
<div class="line"><span class="lineno">20375</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20376</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa269ba998ca2e15b2f596a8c074d125f" name="aa269ba998ca2e15b2f596a8c074d125f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa269ba998ca2e15b2f596a8c074d125f">&#9670;&#160;</a></span>basic_json() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;<a class="el" href="classbasic__json.html">::basic_json</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/basic_json/">https://json.nlohmann.me/api/basic_json/basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20380">20380</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20381</span>        : m_type(std::move(other.m_type)),</div>
<div class="line"><span class="lineno">20382</span>          <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>(std::move(other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>))</div>
<div class="line"><span class="lineno">20383</span>    {</div>
<div class="line"><span class="lineno">20384</span>        <span class="comment">// check that passed value is valid</span></div>
<div class="line"><span class="lineno">20385</span>        other.assert_invariant(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">20386</span> </div>
<div class="line"><span class="lineno">20387</span>        <span class="comment">// invalidate payload</span></div>
<div class="line"><span class="lineno">20388</span>        other.m_type = value_t::null;</div>
<div class="line"><span class="lineno">20389</span>        other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = {};</div>
<div class="line"><span class="lineno">20390</span> </div>
<div class="line"><span class="lineno">20391</span>        set_parents();</div>
<div class="line"><span class="lineno">20392</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20393</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0209408ec1ed66ea5f89a7d72e57e43" name="ad0209408ec1ed66ea5f89a7d72e57e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0209408ec1ed66ea5f89a7d72e57e43">&#9670;&#160;</a></span>~basic_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::~<a class="el" href="classbasic__json.html">basic_json</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/~basic_json/">https://json.nlohmann.me/api/basic_json/~basic_json/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20418">20418</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20419</span>    {</div>
<div class="line"><span class="lineno">20420</span>        assert_invariant(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">20421</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.destroy(m_type);</div>
<div class="line"><span class="lineno">20422</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08a68350d457af1f6ea7f27b6e0a5baf" name="a08a68350d457af1f6ea7f27b6e0a5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a68350d457af1f6ea7f27b6e0a5baf">&#9670;&#160;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an array from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/array/">https://json.nlohmann.me/api/basic_json/array/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20170">20170</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20170</span>                                                      {})</div>
<div class="line"><span class="lineno">20171</span>    {</div>
<div class="line"><span class="lineno">20172</span>        <span class="keywordflow">return</span> <a class="code hl_class" href="classbasic__json.html">basic_json</a>(init, <span class="keyword">false</span>, value_t::array);</div>
<div class="line"><span class="lineno">20173</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af1daebc285b407ce97a080a90ead681a" name="af1daebc285b407ce97a080a90ead681a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1daebc285b407ce97a080a90ead681a">&#9670;&#160;</a></span>at() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23800">23800</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23801</span>    {</div>
<div class="line"><span class="lineno">23802</span>        <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23803</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4a6aa1ba673eda8f96506b8dfc243df" name="aa4a6aa1ba673eda8f96506b8dfc243df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a6aa1ba673eda8f96506b8dfc243df">&#9670;&#160;</a></span>at() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23814">23814</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23815</span>    {</div>
<div class="line"><span class="lineno">23816</span>        <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23817</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a5249193b987b187efa74353c9b5b43" name="a0a5249193b987b187efa74353c9b5b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5249193b987b187efa74353c9b5b43">&#9670;&#160;</a></span>at() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23793">23793</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23794</span>    {</div>
<div class="line"><span class="lineno">23795</span>        <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23796</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7d4becb69fb528514395b46d123b69a" name="ac7d4becb69fb528514395b46d123b69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d4becb69fb528514395b46d123b69a">&#9670;&#160;</a></span>at() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23807">23807</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23808</span>    {</div>
<div class="line"><span class="lineno">23809</span>        <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23810</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedf1894e1b70a4caebd95adec60e845a" name="aedf1894e1b70a4caebd95adec60e845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf1894e1b70a4caebd95adec60e845a">&#9670;&#160;</a></span>at() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21150">21150</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21151</span>    {</div>
<div class="line"><span class="lineno">21152</span>        <span class="comment">// at only works for objects</span></div>
<div class="line"><span class="lineno">21153</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21154</span>        {</div>
<div class="line"><span class="lineno">21155</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21156</span>        }</div>
<div class="line"><span class="lineno">21157</span> </div>
<div class="line"><span class="lineno">21158</span>        <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key);</div>
<div class="line"><span class="lineno">21159</span>        <span class="keywordflow">if</span> (it == <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end())</div>
<div class="line"><span class="lineno">21160</span>        {</div>
<div class="line"><span class="lineno">21161</span>            JSON_THROW(out_of_range::create(403, detail::concat(<span class="stringliteral">&quot;key &#39;&quot;</span>, key, <span class="stringliteral">&quot;&#39; not found&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21162</span>        }</div>
<div class="line"><span class="lineno">21163</span>        <span class="keywordflow">return</span> set_parent(it-&gt;second);</div>
<div class="line"><span class="lineno">21164</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a7528ae3cfe082b3e6280eb5dfab4700b"><div class="ttname"><a href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">basic_json::type_name</a></div><div class="ttdeci">JSON_HEDLEY_RETURNS_NON_NULL const char * type_name() const noexcept</div><div class="ttdoc">return the type as string</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23329">json.hpp:23329</a></div></div>
<div class="ttc" id="aclassbasic__json_html_af758a912346776b086abb82487b1d73b"><div class="ttname"><a href="classbasic__json.html#af758a912346776b086abb82487b1d73b">basic_json::is_object</a></div><div class="ttdeci">constexpr bool is_object() const noexcept</div><div class="ttdoc">return whether value is an object</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20522">json.hpp:20522</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc32b953a4e343dc7f8ab3465743f399" name="afc32b953a4e343dc7f8ab3465743f399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32b953a4e343dc7f8ab3465743f399">&#9670;&#160;</a></span>at() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21188">21188</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21189</span>    {</div>
<div class="line"><span class="lineno">21190</span>        <span class="comment">// at only works for objects</span></div>
<div class="line"><span class="lineno">21191</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21192</span>        {</div>
<div class="line"><span class="lineno">21193</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21194</span>        }</div>
<div class="line"><span class="lineno">21195</span> </div>
<div class="line"><span class="lineno">21196</span>        <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key);</div>
<div class="line"><span class="lineno">21197</span>        <span class="keywordflow">if</span> (it == <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end())</div>
<div class="line"><span class="lineno">21198</span>        {</div>
<div class="line"><span class="lineno">21199</span>            JSON_THROW(out_of_range::create(403, detail::concat(<span class="stringliteral">&quot;key &#39;&quot;</span>, key, <span class="stringliteral">&quot;&#39; not found&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21200</span>        }</div>
<div class="line"><span class="lineno">21201</span>        <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><span class="lineno">21202</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afc69e86b65aa8b571ccad9d581ca5a2b" name="afc69e86b65aa8b571ccad9d581ca5a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc69e86b65aa8b571ccad9d581ca5a2b">&#9670;&#160;</a></span>at() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21170">21170</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21171</span>    {</div>
<div class="line"><span class="lineno">21172</span>        <span class="comment">// at only works for objects</span></div>
<div class="line"><span class="lineno">21173</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21174</span>        {</div>
<div class="line"><span class="lineno">21175</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21176</span>        }</div>
<div class="line"><span class="lineno">21177</span> </div>
<div class="line"><span class="lineno">21178</span>        <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21179</span>        <span class="keywordflow">if</span> (it == <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end())</div>
<div class="line"><span class="lineno">21180</span>        {</div>
<div class="line"><span class="lineno">21181</span>            JSON_THROW(out_of_range::create(403, detail::concat(<span class="stringliteral">&quot;key &#39;&quot;</span>, <a class="code hl_typedef" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>(std::forward&lt;KeyType&gt;(key)), <span class="stringliteral">&quot;&#39; not found&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21182</span>        }</div>
<div class="line"><span class="lineno">21183</span>        <span class="keywordflow">return</span> set_parent(it-&gt;second);</div>
<div class="line"><span class="lineno">21184</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a807932caebf0d62abc8642b9d1a2e5ef"><div class="ttname"><a href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">basic_json::string_t</a></div><div class="ttdeci">StringType string_t</div><div class="ttdoc">a type for a string</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19523">json.hpp:19523</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee87279fb115f6d57967e6e8f5542faa" name="aee87279fb115f6d57967e6e8f5542faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee87279fb115f6d57967e6e8f5542faa">&#9670;&#160;</a></span>at() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21208">21208</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21209</span>    {</div>
<div class="line"><span class="lineno">21210</span>        <span class="comment">// at only works for objects</span></div>
<div class="line"><span class="lineno">21211</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21212</span>        {</div>
<div class="line"><span class="lineno">21213</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21214</span>        }</div>
<div class="line"><span class="lineno">21215</span> </div>
<div class="line"><span class="lineno">21216</span>        <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21217</span>        <span class="keywordflow">if</span> (it == <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end())</div>
<div class="line"><span class="lineno">21218</span>        {</div>
<div class="line"><span class="lineno">21219</span>            JSON_THROW(out_of_range::create(403, detail::concat(<span class="stringliteral">&quot;key &#39;&quot;</span>, <a class="code hl_typedef" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>(std::forward&lt;KeyType&gt;(key)), <span class="stringliteral">&quot;&#39; not found&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21220</span>        }</div>
<div class="line"><span class="lineno">21221</span>        <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><span class="lineno">21222</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a603779687f401ad11de45f8397f92296" name="a603779687f401ad11de45f8397f92296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603779687f401ad11de45f8397f92296">&#9670;&#160;</a></span>at() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21104">21104</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21105</span>    {</div>
<div class="line"><span class="lineno">21106</span>        <span class="comment">// at only works for arrays</span></div>
<div class="line"><span class="lineno">21107</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">21108</span>        {</div>
<div class="line"><span class="lineno">21109</span>            JSON_TRY</div>
<div class="line"><span class="lineno">21110</span>            {</div>
<div class="line"><span class="lineno">21111</span>                <span class="keywordflow">return</span> set_parent(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;at(idx));</div>
<div class="line"><span class="lineno">21112</span>            }</div>
<div class="line"><span class="lineno">21113</span>            JSON_CATCH (std::out_of_range&amp;)</div>
<div class="line"><span class="lineno">21114</span>            {</div>
<div class="line"><span class="lineno">21115</span>                <span class="comment">// create better exception explanation</span></div>
<div class="line"><span class="lineno">21116</span>                JSON_THROW(out_of_range::create(401, detail::concat(<span class="stringliteral">&quot;array index &quot;</span>, std::to_string(idx), <span class="stringliteral">&quot; is out of range&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21117</span>            }</div>
<div class="line"><span class="lineno">21118</span>        }</div>
<div class="line"><span class="lineno">21119</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">21120</span>        {</div>
<div class="line"><span class="lineno">21121</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21122</span>        }</div>
<div class="line"><span class="lineno">21123</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a89ea48a4e802ef81783c0c7ce89aa7bb"><div class="ttname"><a href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">basic_json::is_array</a></div><div class="ttdeci">constexpr bool is_array() const noexcept</div><div class="ttdoc">return whether value is an array</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20529">json.hpp:20529</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a98e6b7245d17021327eb3962d73ccc54" name="a98e6b7245d17021327eb3962d73ccc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e6b7245d17021327eb3962d73ccc54">&#9670;&#160;</a></span>at() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element with bounds checking </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/at/">https://json.nlohmann.me/api/basic_json/at/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21127">21127</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21128</span>    {</div>
<div class="line"><span class="lineno">21129</span>        <span class="comment">// at only works for arrays</span></div>
<div class="line"><span class="lineno">21130</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">21131</span>        {</div>
<div class="line"><span class="lineno">21132</span>            JSON_TRY</div>
<div class="line"><span class="lineno">21133</span>            {</div>
<div class="line"><span class="lineno">21134</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;at(idx);</div>
<div class="line"><span class="lineno">21135</span>            }</div>
<div class="line"><span class="lineno">21136</span>            JSON_CATCH (std::out_of_range&amp;)</div>
<div class="line"><span class="lineno">21137</span>            {</div>
<div class="line"><span class="lineno">21138</span>                <span class="comment">// create better exception explanation</span></div>
<div class="line"><span class="lineno">21139</span>                JSON_THROW(out_of_range::create(401, detail::concat(<span class="stringliteral">&quot;array index &quot;</span>, std::to_string(idx), <span class="stringliteral">&quot; is out of range&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21140</span>            }</div>
<div class="line"><span class="lineno">21141</span>        }</div>
<div class="line"><span class="lineno">21142</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">21143</span>        {</div>
<div class="line"><span class="lineno">21144</span>            JSON_THROW(type_error::create(304, detail::concat(<span class="stringliteral">&quot;cannot use at() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21145</span>        }</div>
<div class="line"><span class="lineno">21146</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adafea743a0a74f86433b8b7cc5bb24bf" name="adafea743a0a74f86433b8b7cc5bb24bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafea743a0a74f86433b8b7cc5bb24bf">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21574">21574</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21575</span>    {</div>
<div class="line"><span class="lineno">21576</span>        <span class="keyword">auto</span> tmp = <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>();</div>
<div class="line"><span class="lineno">21577</span>        --tmp;</div>
<div class="line"><span class="lineno">21578</span>        <span class="keywordflow">return</span> *tmp;</div>
<div class="line"><span class="lineno">21579</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a06e303bfaafda414b4b5821384501bc1"><div class="ttname"><a href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">basic_json::end</a></div><div class="ttdeci">iterator end() noexcept</div><div class="ttdoc">returns an iterator to one past the last element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21961">json.hpp:21961</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bf48c36e00720e01f8f6bbd3df0bf5b" name="a1bf48c36e00720e01f8f6bbd3df0bf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf48c36e00720e01f8f6bbd3df0bf5b">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/back/">https://json.nlohmann.me/api/basic_json/back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21583">21583</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21584</span>    {</div>
<div class="line"><span class="lineno">21585</span>        <span class="keyword">auto</span> tmp = <a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>();</div>
<div class="line"><span class="lineno">21586</span>        --tmp;</div>
<div class="line"><span class="lineno">21587</span>        <span class="keywordflow">return</span> *tmp;</div>
<div class="line"><span class="lineno">21588</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_ab4f83081d8b64f6dc9b079af13266dc1"><div class="ttname"><a href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">basic_json::cend</a></div><div class="ttdeci">const_iterator cend() const noexcept</div><div class="ttdoc">returns an iterator to one past the last element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21977">json.hpp:21977</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec74bf7ec122115d615a7f1be4122f9f" name="aec74bf7ec122115d615a7f1be4122f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec74bf7ec122115d615a7f1be4122f9f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/begin/">https://json.nlohmann.me/api/basic_json/begin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21945">21945</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21946</span>    {</div>
<div class="line"><span class="lineno">21947</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a>();</div>
<div class="line"><span class="lineno">21948</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a3451ab7e33828ded865a4c6c2e22463b"><div class="ttname"><a href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">basic_json::cbegin</a></div><div class="ttdeci">const_iterator cbegin() const noexcept</div><div class="ttdoc">returns a const iterator to the first element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21952">json.hpp:21952</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af7ba4755c9131259324caaa166146513" name="af7ba4755c9131259324caaa166146513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ba4755c9131259324caaa166146513">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/begin/">https://json.nlohmann.me/api/basic_json/begin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21936">21936</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21937</span>    {</div>
<div class="line"><span class="lineno">21938</span>        <a class="code hl_typedef" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21939</span>        result.set_begin();</div>
<div class="line"><span class="lineno">21940</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21941</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a2935c91b82c8e586b1dd68ad665075a6"><div class="ttname"><a href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">basic_json::iterator</a></div><div class="ttdeci">iter_impl&lt; basic_json &gt; iterator</div><div class="ttdoc">an iterator for a basic_json container</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19403">json.hpp:19403</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d25b7a4a6f6ee355193ee6b461ab3bd" name="a8d25b7a4a6f6ee355193ee6b461ab3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d25b7a4a6f6ee355193ee6b461ab3bd">&#9670;&#160;</a></span>binary() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (without subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20126">20126</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20127</span>    {</div>
<div class="line"><span class="lineno">20128</span>        <span class="keyword">auto</span> res = <a class="code hl_class" href="classbasic__json.html">basic_json</a>();</div>
<div class="line"><span class="lineno">20129</span>        res.m_type = value_t::binary;</div>
<div class="line"><span class="lineno">20130</span>        res.m_value = init;</div>
<div class="line"><span class="lineno">20131</span>        <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">20132</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a92f5028b858b39e0c49c722ba09793" name="a9a92f5028b858b39e0c49c722ba09793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92f5028b858b39e0c49c722ba09793">&#9670;&#160;</a></span>binary() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">const typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20137">20137</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20138</span>    {</div>
<div class="line"><span class="lineno">20139</span>        <span class="keyword">auto</span> res = <a class="code hl_class" href="classbasic__json.html">basic_json</a>();</div>
<div class="line"><span class="lineno">20140</span>        res.m_type = value_t::binary;</div>
<div class="line"><span class="lineno">20141</span>        res.m_value = <a class="code hl_typedef" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a>(init, subtype);</div>
<div class="line"><span class="lineno">20142</span>        <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">20143</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aabedd827d4943302a4cf0413956341db"><div class="ttname"><a href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">basic_json::binary_t</a></div><div class="ttdeci">nlohmann::byte_container_with_subtype&lt; BinaryType &gt; binary_t</div><div class="ttdoc">a type for a packed binary type</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19543">json.hpp:19543</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0767ec4050ecfb4e4852db24cc939b2b" name="a0767ec4050ecfb4e4852db24cc939b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0767ec4050ecfb4e4852db24cc939b2b">&#9670;&#160;</a></span>binary() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20148">20148</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20149</span>    {</div>
<div class="line"><span class="lineno">20150</span>        <span class="keyword">auto</span> res = <a class="code hl_class" href="classbasic__json.html">basic_json</a>();</div>
<div class="line"><span class="lineno">20151</span>        res.m_type = value_t::binary;</div>
<div class="line"><span class="lineno">20152</span>        res.m_value = std::move(init);</div>
<div class="line"><span class="lineno">20153</span>        <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">20154</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ad9ba515c5f51d9c5609583e3d0ada0" name="a6ad9ba515c5f51d9c5609583e3d0ada0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad9ba515c5f51d9c5609583e3d0ada0">&#9670;&#160;</a></span>binary() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename binary_t::subtype_type&#160;</td>
          <td class="paramname"><em>subtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create a binary array (with subtype) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/binary/">https://json.nlohmann.me/api/basic_json/binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20159">20159</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20160</span>    {</div>
<div class="line"><span class="lineno">20161</span>        <span class="keyword">auto</span> res = <a class="code hl_class" href="classbasic__json.html">basic_json</a>();</div>
<div class="line"><span class="lineno">20162</span>        res.m_type = value_t::binary;</div>
<div class="line"><span class="lineno">20163</span>        res.m_value = <a class="code hl_typedef" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a>(std::move(init), subtype);</div>
<div class="line"><span class="lineno">20164</span>        <span class="keywordflow">return</span> res;</div>
<div class="line"><span class="lineno">20165</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3451ab7e33828ded865a4c6c2e22463b" name="a3451ab7e33828ded865a4c6c2e22463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3451ab7e33828ded865a4c6c2e22463b">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a const iterator to the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/cbegin/">https://json.nlohmann.me/api/basic_json/cbegin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21952">21952</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21953</span>    {</div>
<div class="line"><span class="lineno">21954</span>        <a class="code hl_typedef" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21955</span>        result.set_begin();</div>
<div class="line"><span class="lineno">21956</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21957</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a8f3470194c24d964e40d9be0b177cbc3"><div class="ttname"><a href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">basic_json::const_iterator</a></div><div class="ttdeci">iter_impl&lt; const basic_json &gt; const_iterator</div><div class="ttdoc">a const iterator for a basic_json container</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19405">json.hpp:19405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4f83081d8b64f6dc9b079af13266dc1" name="ab4f83081d8b64f6dc9b079af13266dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f83081d8b64f6dc9b079af13266dc1">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to one past the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/cend/">https://json.nlohmann.me/api/basic_json/cend/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21977">21977</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21978</span>    {</div>
<div class="line"><span class="lineno">21979</span>        <a class="code hl_typedef" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21980</span>        result.set_end();</div>
<div class="line"><span class="lineno">21981</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21982</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac5145a99de8435876192b70378afe097" name="ac5145a99de8435876192b70378afe097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5145a99de8435876192b70378afe097">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clears the contents </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/clear/">https://json.nlohmann.me/api/basic_json/clear/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22197">22197</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22198</span>    {</div>
<div class="line"><span class="lineno">22199</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">22200</span>        {</div>
<div class="line"><span class="lineno">22201</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">22202</span>            {</div>
<div class="line"><span class="lineno">22203</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_integer = 0;</div>
<div class="line"><span class="lineno">22204</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22205</span>            }</div>
<div class="line"><span class="lineno">22206</span> </div>
<div class="line"><span class="lineno">22207</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">22208</span>            {</div>
<div class="line"><span class="lineno">22209</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_unsigned = 0;</div>
<div class="line"><span class="lineno">22210</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22211</span>            }</div>
<div class="line"><span class="lineno">22212</span> </div>
<div class="line"><span class="lineno">22213</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">22214</span>            {</div>
<div class="line"><span class="lineno">22215</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_float = 0.0;</div>
<div class="line"><span class="lineno">22216</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22217</span>            }</div>
<div class="line"><span class="lineno">22218</span> </div>
<div class="line"><span class="lineno">22219</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">22220</span>            {</div>
<div class="line"><span class="lineno">22221</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.boolean = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">22222</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22223</span>            }</div>
<div class="line"><span class="lineno">22224</span> </div>
<div class="line"><span class="lineno">22225</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">22226</span>            {</div>
<div class="line"><span class="lineno">22227</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string-&gt;clear();</div>
<div class="line"><span class="lineno">22228</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22229</span>            }</div>
<div class="line"><span class="lineno">22230</span> </div>
<div class="line"><span class="lineno">22231</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">22232</span>            {</div>
<div class="line"><span class="lineno">22233</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary-&gt;clear();</div>
<div class="line"><span class="lineno">22234</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22235</span>            }</div>
<div class="line"><span class="lineno">22236</span> </div>
<div class="line"><span class="lineno">22237</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">22238</span>            {</div>
<div class="line"><span class="lineno">22239</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;clear();</div>
<div class="line"><span class="lineno">22240</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22241</span>            }</div>
<div class="line"><span class="lineno">22242</span> </div>
<div class="line"><span class="lineno">22243</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">22244</span>            {</div>
<div class="line"><span class="lineno">22245</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;clear();</div>
<div class="line"><span class="lineno">22246</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22247</span>            }</div>
<div class="line"><span class="lineno">22248</span> </div>
<div class="line"><span class="lineno">22249</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">22250</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">22251</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">22252</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">22253</span>        }</div>
<div class="line"><span class="lineno">22254</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7241e94ede5aacd7efca401cf0638a" name="a0d7241e94ede5aacd7efca401cf0638a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7241e94ede5aacd7efca401cf0638a">&#9670;&#160;</a></span>contains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object given a JSON pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21912">21912</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21913</span>    {</div>
<div class="line"><span class="lineno">21914</span>        <span class="keywordflow">return</span> ptr.contains(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21915</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74b0b7791993c4ae48532f9b427bc518" name="a74b0b7791993c4ae48532f9b427bc518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b0b7791993c4ae48532f9b427bc518">&#9670;&#160;</a></span>contains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const typename ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21919">21919</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21920</span>    {</div>
<div class="line"><span class="lineno">21921</span>        <span class="keywordflow">return</span> ptr.contains(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21922</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3815a53b61818c87cf677f4a1ea5b7e8" name="a3815a53b61818c87cf677f4a1ea5b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3815a53b61818c87cf677f4a1ea5b7e8">&#9670;&#160;</a></span>contains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21896">21896</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21897</span>    {</div>
<div class="line"><span class="lineno">21898</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>() &amp;&amp; <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key) != <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end();</div>
<div class="line"><span class="lineno">21899</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a56dbcc61c27689659fa1d94a19bd2560" name="a56dbcc61c27689659fa1d94a19bd2560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dbcc61c27689659fa1d94a19bd2560">&#9670;&#160;</a></span>contains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check the existence of an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/contains/">https://json.nlohmann.me/api/basic_json/contains/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21905">21905</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21906</span>    {</div>
<div class="line"><span class="lineno">21907</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>() &amp;&amp; <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key)) != <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end();</div>
<div class="line"><span class="lineno">21908</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac122e03d4d28d6a03c01abaa7229d4c7" name="ac122e03d4d28d6a03c01abaa7229d4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac122e03d4d28d6a03c01abaa7229d4c7">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21878">21878</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21879</span>    {</div>
<div class="line"><span class="lineno">21880</span>        <span class="comment">// return 0 for all nonobject types</span></div>
<div class="line"><span class="lineno">21881</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>() ? <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;count(key) : 0;</div>
<div class="line"><span class="lineno">21882</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06e36a368cbf554fc817b0cb3e37e3a3" name="a06e36a368cbf554fc817b0cb3e37e3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e36a368cbf554fc817b0cb3e37e3a3">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of occurrences of a key in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/count/">https://json.nlohmann.me/api/basic_json/count/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21888">21888</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21889</span>    {</div>
<div class="line"><span class="lineno">21890</span>        <span class="comment">// return 0 for all nonobject types</span></div>
<div class="line"><span class="lineno">21891</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>() ? <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;count(std::forward&lt;KeyType&gt;(key)) : 0;</div>
<div class="line"><span class="lineno">21892</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed4f45b1b03cd315b3700dacb22d1fb3" name="aed4f45b1b03cd315b3700dacb22d1fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4f45b1b03cd315b3700dacb22d1fb3">&#9670;&#160;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a const reverse iterator to the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/crbegin/">https://json.nlohmann.me/api/basic_json/crbegin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22014">22014</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22015</span>    {</div>
<div class="line"><span class="lineno">22016</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>(<a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>());</div>
<div class="line"><span class="lineno">22017</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a2aa7d4c7719ab82aa8c77a83642c843f"><div class="ttname"><a href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">basic_json::const_reverse_iterator</a></div><div class="ttdeci">json_reverse_iterator&lt; typename basic_json::const_iterator &gt; const_reverse_iterator</div><div class="ttdoc">a const reverse iterator for a basic_json container</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19409">json.hpp:19409</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a463e1d370bf75906179dce60ad89a1ea" name="a463e1d370bf75906179dce60ad89a1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463e1d370bf75906179dce60ad89a1ea">&#9670;&#160;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a const reverse iterator to one before the first </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/crend/">https://json.nlohmann.me/api/basic_json/crend/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22021">22021</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22022</span>    {</div>
<div class="line"><span class="lineno">22023</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a>(<a class="code hl_function" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a>());</div>
<div class="line"><span class="lineno">22024</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff2204c04cd35b2cef35f44b2b93ffc7" name="aff2204c04cd35b2cef35f44b2b93ffc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2204c04cd35b2cef35f44b2b93ffc7">&#9670;&#160;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a diff as a JSON patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/diff/">https://json.nlohmann.me/api/basic_json/diff/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24127">24127</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">24129</span>    {</div>
<div class="line"><span class="lineno">24130</span>        <span class="comment">// the patch</span></div>
<div class="line"><span class="lineno">24131</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result(value_t::array);</div>
<div class="line"><span class="lineno">24132</span> </div>
<div class="line"><span class="lineno">24133</span>        <span class="comment">// if the values are the same, return empty patch</span></div>
<div class="line"><span class="lineno">24134</span>        <span class="keywordflow">if</span> (source == target)</div>
<div class="line"><span class="lineno">24135</span>        {</div>
<div class="line"><span class="lineno">24136</span>            <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">24137</span>        }</div>
<div class="line"><span class="lineno">24138</span> </div>
<div class="line"><span class="lineno">24139</span>        <span class="keywordflow">if</span> (source.<a class="code hl_function" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">type</a>() != target.<a class="code hl_function" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">type</a>())</div>
<div class="line"><span class="lineno">24140</span>        {</div>
<div class="line"><span class="lineno">24141</span>            <span class="comment">// different types: replace value</span></div>
<div class="line"><span class="lineno">24142</span>            result.push_back(</div>
<div class="line"><span class="lineno">24143</span>            {</div>
<div class="line"><span class="lineno">24144</span>                {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;replace&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path}, {<span class="stringliteral">&quot;value&quot;</span>, target}</div>
<div class="line"><span class="lineno">24145</span>            });</div>
<div class="line"><span class="lineno">24146</span>            <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">24147</span>        }</div>
<div class="line"><span class="lineno">24148</span> </div>
<div class="line"><span class="lineno">24149</span>        <span class="keywordflow">switch</span> (source.<a class="code hl_function" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">type</a>())</div>
<div class="line"><span class="lineno">24150</span>        {</div>
<div class="line"><span class="lineno">24151</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">24152</span>            {</div>
<div class="line"><span class="lineno">24153</span>                <span class="comment">// first pass: traverse common elements</span></div>
<div class="line"><span class="lineno">24154</span>                std::size_t i = 0;</div>
<div class="line"><span class="lineno">24155</span>                <span class="keywordflow">while</span> (i &lt; source.<a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>() &amp;&amp; i &lt; target.<a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>())</div>
<div class="line"><span class="lineno">24156</span>                {</div>
<div class="line"><span class="lineno">24157</span>                    <span class="comment">// recursive call to compare array values at index i</span></div>
<div class="line"><span class="lineno">24158</span>                    <span class="keyword">auto</span> temp_diff = <a class="code hl_function" href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">diff</a>(source[i], target[i], detail::concat(path, <span class="charliteral">&#39;/&#39;</span>, std::to_string(i)));</div>
<div class="line"><span class="lineno">24159</span>                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());</div>
<div class="line"><span class="lineno">24160</span>                    ++i;</div>
<div class="line"><span class="lineno">24161</span>                }</div>
<div class="line"><span class="lineno">24162</span> </div>
<div class="line"><span class="lineno">24163</span>                <span class="comment">// We now reached the end of at least one array</span></div>
<div class="line"><span class="lineno">24164</span>                <span class="comment">// in a second pass, traverse the remaining elements</span></div>
<div class="line"><span class="lineno">24165</span> </div>
<div class="line"><span class="lineno">24166</span>                <span class="comment">// remove my remaining elements</span></div>
<div class="line"><span class="lineno">24167</span>                <span class="keyword">const</span> <span class="keyword">auto</span> end_index = <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">difference_type</a><span class="keyword">&gt;</span>(result.size());</div>
<div class="line"><span class="lineno">24168</span>                <span class="keywordflow">while</span> (i &lt; source.<a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>())</div>
<div class="line"><span class="lineno">24169</span>                {</div>
<div class="line"><span class="lineno">24170</span>                    <span class="comment">// add operations in reverse order to avoid invalid</span></div>
<div class="line"><span class="lineno">24171</span>                    <span class="comment">// indices</span></div>
<div class="line"><span class="lineno">24172</span>                    result.insert(result.begin() + end_index, <a class="code hl_function" href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">object</a>(</div>
<div class="line"><span class="lineno">24173</span>                    {</div>
<div class="line"><span class="lineno">24174</span>                        {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;remove&quot;</span>},</div>
<div class="line"><span class="lineno">24175</span>                        {<span class="stringliteral">&quot;path&quot;</span>, detail::concat(path, <span class="charliteral">&#39;/&#39;</span>, std::to_string(i))}</div>
<div class="line"><span class="lineno">24176</span>                    }));</div>
<div class="line"><span class="lineno">24177</span>                    ++i;</div>
<div class="line"><span class="lineno">24178</span>                }</div>
<div class="line"><span class="lineno">24179</span> </div>
<div class="line"><span class="lineno">24180</span>                <span class="comment">// add other remaining elements</span></div>
<div class="line"><span class="lineno">24181</span>                <span class="keywordflow">while</span> (i &lt; target.<a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>())</div>
<div class="line"><span class="lineno">24182</span>                {</div>
<div class="line"><span class="lineno">24183</span>                    result.push_back(</div>
<div class="line"><span class="lineno">24184</span>                    {</div>
<div class="line"><span class="lineno">24185</span>                        {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>},</div>
<div class="line"><span class="lineno">24186</span>                        {<span class="stringliteral">&quot;path&quot;</span>, detail::concat(path, <span class="stringliteral">&quot;/-&quot;</span>)},</div>
<div class="line"><span class="lineno">24187</span>                        {<span class="stringliteral">&quot;value&quot;</span>, target[i]}</div>
<div class="line"><span class="lineno">24188</span>                    });</div>
<div class="line"><span class="lineno">24189</span>                    ++i;</div>
<div class="line"><span class="lineno">24190</span>                }</div>
<div class="line"><span class="lineno">24191</span> </div>
<div class="line"><span class="lineno">24192</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24193</span>            }</div>
<div class="line"><span class="lineno">24194</span> </div>
<div class="line"><span class="lineno">24195</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">24196</span>            {</div>
<div class="line"><span class="lineno">24197</span>                <span class="comment">// first pass: traverse this object&#39;s elements</span></div>
<div class="line"><span class="lineno">24198</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = source.<a class="code hl_function" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a>(); it != source.<a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>(); ++it)</div>
<div class="line"><span class="lineno">24199</span>                {</div>
<div class="line"><span class="lineno">24200</span>                    <span class="comment">// escape the key name to be used in a JSON patch</span></div>
<div class="line"><span class="lineno">24201</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> path_key = detail::concat(path, <span class="charliteral">&#39;/&#39;</span>, <a class="code hl_function" href="namespacedetail.html#af2a9ce4740e0b45d33129e2c8e53a0a8">detail::escape</a>(it.key()));</div>
<div class="line"><span class="lineno">24202</span> </div>
<div class="line"><span class="lineno">24203</span>                    <span class="keywordflow">if</span> (target.<a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(it.key()) != target.<a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">24204</span>                    {</div>
<div class="line"><span class="lineno">24205</span>                        <span class="comment">// recursive call to compare object values at key it</span></div>
<div class="line"><span class="lineno">24206</span>                        <span class="keyword">auto</span> temp_diff = <a class="code hl_function" href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">diff</a>(it.value(), target[it.key()], path_key);</div>
<div class="line"><span class="lineno">24207</span>                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());</div>
<div class="line"><span class="lineno">24208</span>                    }</div>
<div class="line"><span class="lineno">24209</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">24210</span>                    {</div>
<div class="line"><span class="lineno">24211</span>                        <span class="comment">// found a key that is not in o -&gt; remove it</span></div>
<div class="line"><span class="lineno">24212</span>                        result.push_back(<span class="keywordtype">object</span>(</div>
<div class="line"><span class="lineno">24213</span>                        {</div>
<div class="line"><span class="lineno">24214</span>                            {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;remove&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path_key}</div>
<div class="line"><span class="lineno">24215</span>                        }));</div>
<div class="line"><span class="lineno">24216</span>                    }</div>
<div class="line"><span class="lineno">24217</span>                }</div>
<div class="line"><span class="lineno">24218</span> </div>
<div class="line"><span class="lineno">24219</span>                <span class="comment">// second pass: traverse other object&#39;s elements</span></div>
<div class="line"><span class="lineno">24220</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = target.<a class="code hl_function" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a>(); it != target.<a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>(); ++it)</div>
<div class="line"><span class="lineno">24221</span>                {</div>
<div class="line"><span class="lineno">24222</span>                    <span class="keywordflow">if</span> (source.<a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(it.key()) == source.<a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">24223</span>                    {</div>
<div class="line"><span class="lineno">24224</span>                        <span class="comment">// found a key that is not in this -&gt; add it</span></div>
<div class="line"><span class="lineno">24225</span>                        <span class="keyword">const</span> <span class="keyword">auto</span> path_key = detail::concat(path, <span class="charliteral">&#39;/&#39;</span>, <a class="code hl_function" href="namespacedetail.html#af2a9ce4740e0b45d33129e2c8e53a0a8">detail::escape</a>(it.key()));</div>
<div class="line"><span class="lineno">24226</span>                        result.push_back(</div>
<div class="line"><span class="lineno">24227</span>                        {</div>
<div class="line"><span class="lineno">24228</span>                            {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;add&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path_key},</div>
<div class="line"><span class="lineno">24229</span>                            {<span class="stringliteral">&quot;value&quot;</span>, it.value()}</div>
<div class="line"><span class="lineno">24230</span>                        });</div>
<div class="line"><span class="lineno">24231</span>                    }</div>
<div class="line"><span class="lineno">24232</span>                }</div>
<div class="line"><span class="lineno">24233</span> </div>
<div class="line"><span class="lineno">24234</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24235</span>            }</div>
<div class="line"><span class="lineno">24236</span> </div>
<div class="line"><span class="lineno">24237</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">24238</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">24239</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">24240</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">24241</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">24242</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">24243</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">24244</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">24245</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">24246</span>            {</div>
<div class="line"><span class="lineno">24247</span>                <span class="comment">// both primitive type: replace value</span></div>
<div class="line"><span class="lineno">24248</span>                result.push_back(</div>
<div class="line"><span class="lineno">24249</span>                {</div>
<div class="line"><span class="lineno">24250</span>                    {<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;replace&quot;</span>}, {<span class="stringliteral">&quot;path&quot;</span>, path}, {<span class="stringliteral">&quot;value&quot;</span>, target}</div>
<div class="line"><span class="lineno">24251</span>                });</div>
<div class="line"><span class="lineno">24252</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24253</span>            }</div>
<div class="line"><span class="lineno">24254</span>        }</div>
<div class="line"><span class="lineno">24255</span> </div>
<div class="line"><span class="lineno">24256</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">24257</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a10aa3ec9e58f6852709913408519c01c"><div class="ttname"><a href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">basic_json::object</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json object(initializer_list_t init={})</div><div class="ttdoc">explicitly create an object from an initializer list</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20178">json.hpp:20178</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a1338e4eef7282cd57a4a57e034531029"><div class="ttname"><a href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">basic_json::type</a></div><div class="ttdeci">constexpr value_t type() const noexcept</div><div class="ttdoc">return the type of the JSON value (explicit)</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20459">json.hpp:20459</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a2fe32d636c1b78861884dde9716b22b6"><div class="ttname"><a href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">basic_json::difference_type</a></div><div class="ttdeci">std::ptrdiff_t difference_type</div><div class="ttdoc">a type to represent differences between iterators</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19390">json.hpp:19390</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a769537e4631ccd39b5ab3753547a8274"><div class="ttname"><a href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">basic_json::size</a></div><div class="ttdeci">size_type size() const noexcept</div><div class="ttdoc">returns the number of elements</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22114">json.hpp:22114</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a8ed11f83edce392fd94659b1102d078e"><div class="ttname"><a href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">basic_json::find</a></div><div class="ttdeci">iterator find(const typename object_t::key_type &amp;key)</div><div class="ttdoc">find an element in a JSON object</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21818">json.hpp:21818</a></div></div>
<div class="ttc" id="aclassbasic__json_html_aff2204c04cd35b2cef35f44b2b93ffc7"><div class="ttname"><a href="classbasic__json.html#aff2204c04cd35b2cef35f44b2b93ffc7">basic_json::diff</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json diff(const basic_json &amp;source, const basic_json &amp;target, const std::string &amp;path=&quot;&quot;)</div><div class="ttdoc">creates a diff as a JSON patch</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l24127">json.hpp:24127</a></div></div>
<div class="ttc" id="anamespacedetail_html_af2a9ce4740e0b45d33129e2c8e53a0a8"><div class="ttname"><a href="namespacedetail.html#af2a9ce4740e0b45d33129e2c8e53a0a8">detail::escape</a></div><div class="ttdeci">StringType escape(StringType s)</div><div class="ttdoc">string escaping as described in RFC 6901 (Sect. 4)</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l02974">json.hpp:2974</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac38b5f79c16205efb771e99be206b345" name="ac38b5f79c16205efb771e99be206b345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38b5f79c16205efb771e99be206b345">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>indent_char</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ensure_ascii</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298">error_handler_t</a>&#160;</td>
          <td class="paramname"><em>error_handler</em> = <code>error_handler_t::strict</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialization </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/dump/">https://json.nlohmann.me/api/basic_json/dump/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20437">20437</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20441</span>    {</div>
<div class="line"><span class="lineno">20442</span>        <a class="code hl_typedef" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> result;</div>
<div class="line"><span class="lineno">20443</span>        serializer s(detail::output_adapter&lt;char, string_t&gt;(result), indent_char, error_handler);</div>
<div class="line"><span class="lineno">20444</span> </div>
<div class="line"><span class="lineno">20445</span>        <span class="keywordflow">if</span> (indent &gt;= 0)</div>
<div class="line"><span class="lineno">20446</span>        {</div>
<div class="line"><span class="lineno">20447</span>            s.dump(*<span class="keyword">this</span>, <span class="keyword">true</span>, ensure_ascii, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(indent));</div>
<div class="line"><span class="lineno">20448</span>        }</div>
<div class="line"><span class="lineno">20449</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">20450</span>        {</div>
<div class="line"><span class="lineno">20451</span>            s.dump(*<span class="keyword">this</span>, <span class="keyword">false</span>, ensure_ascii, 0);</div>
<div class="line"><span class="lineno">20452</span>        }</div>
<div class="line"><span class="lineno">20453</span> </div>
<div class="line"><span class="lineno">20454</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">20455</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e70795da670f11ad7925407d0a7d83c" name="a3e70795da670f11ad7925407d0a7d83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e70795da670f11ad7925407d0a7d83c">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a>, bool &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object if key does not exist </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace/">https://json.nlohmann.me/api/basic_json/emplace/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22404">22404</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22405</span>    {</div>
<div class="line"><span class="lineno">22406</span>        <span class="comment">// emplace only works for null objects or arrays</span></div>
<div class="line"><span class="lineno">22407</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!(<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())))</div>
<div class="line"><span class="lineno">22408</span>        {</div>
<div class="line"><span class="lineno">22409</span>            JSON_THROW(type_error::create(311, detail::concat(<span class="stringliteral">&quot;cannot use emplace() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22410</span>        }</div>
<div class="line"><span class="lineno">22411</span> </div>
<div class="line"><span class="lineno">22412</span>        <span class="comment">// transform null object into an object</span></div>
<div class="line"><span class="lineno">22413</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22414</span>        {</div>
<div class="line"><span class="lineno">22415</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">22416</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::object;</div>
<div class="line"><span class="lineno">22417</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22418</span>        }</div>
<div class="line"><span class="lineno">22419</span> </div>
<div class="line"><span class="lineno">22420</span>        <span class="comment">// add element to array (perfect forwarding)</span></div>
<div class="line"><span class="lineno">22421</span>        <span class="keyword">auto</span> res = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;emplace(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><span class="lineno">22422</span>        set_parent(res.first-&gt;second);</div>
<div class="line"><span class="lineno">22423</span> </div>
<div class="line"><span class="lineno">22424</span>        <span class="comment">// create result iterator and set iterator to the result of emplace</span></div>
<div class="line"><span class="lineno">22425</span>        <span class="keyword">auto</span> it = <a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>();</div>
<div class="line"><span class="lineno">22426</span>        it.m_it.object_iterator = res.first;</div>
<div class="line"><span class="lineno">22427</span> </div>
<div class="line"><span class="lineno">22428</span>        <span class="comment">// return pair of iterator and boolean</span></div>
<div class="line"><span class="lineno">22429</span>        <span class="keywordflow">return</span> {it, res.second};</div>
<div class="line"><span class="lineno">22430</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a6ed948b2c2e71ce5f5c03b5eeb575df4"><div class="ttname"><a href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">basic_json::is_null</a></div><div class="ttdeci">constexpr bool is_null() const noexcept</div><div class="ttdoc">return whether value is null</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20480">json.hpp:20480</a></div></div>
<div class="ttc" id="aclassbasic__json_html_af7ba4755c9131259324caaa166146513"><div class="ttname"><a href="classbasic__json.html#af7ba4755c9131259324caaa166146513">basic_json::begin</a></div><div class="ttdeci">iterator begin() noexcept</div><div class="ttdoc">returns an iterator to the first element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21936">json.hpp:21936</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ad89dd8715111483428ecf8534b9393" name="a7ad89dd8715111483428ecf8534b9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad89dd8715111483428ecf8534b9393">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/emplace_back/">https://json.nlohmann.me/api/basic_json/emplace_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22379">22379</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22380</span>    {</div>
<div class="line"><span class="lineno">22381</span>        <span class="comment">// emplace_back only works for null objects or arrays</span></div>
<div class="line"><span class="lineno">22382</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!(<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>())))</div>
<div class="line"><span class="lineno">22383</span>        {</div>
<div class="line"><span class="lineno">22384</span>            JSON_THROW(type_error::create(311, detail::concat(<span class="stringliteral">&quot;cannot use emplace_back() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22385</span>        }</div>
<div class="line"><span class="lineno">22386</span> </div>
<div class="line"><span class="lineno">22387</span>        <span class="comment">// transform null object into an array</span></div>
<div class="line"><span class="lineno">22388</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22389</span>        {</div>
<div class="line"><span class="lineno">22390</span>            m_type = value_t::array;</div>
<div class="line"><span class="lineno">22391</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::array;</div>
<div class="line"><span class="lineno">22392</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22393</span>        }</div>
<div class="line"><span class="lineno">22394</span> </div>
<div class="line"><span class="lineno">22395</span>        <span class="comment">// add element to array (perfect forwarding)</span></div>
<div class="line"><span class="lineno">22396</span>        <span class="keyword">const</span> <span class="keyword">auto</span> old_capacity = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;capacity();</div>
<div class="line"><span class="lineno">22397</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;emplace_back(std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><span class="lineno">22398</span>        <span class="keywordflow">return</span> set_parent(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;back(), old_capacity);</div>
<div class="line"><span class="lineno">22399</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec22254018236106f357bc3ed7c20399" name="aec22254018236106f357bc3ed7c20399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec22254018236106f357bc3ed7c20399">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether the container is empty. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/empty/">https://json.nlohmann.me/api/basic_json/empty/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22075">22075</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22076</span>    {</div>
<div class="line"><span class="lineno">22077</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">22078</span>        {</div>
<div class="line"><span class="lineno">22079</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">22080</span>            {</div>
<div class="line"><span class="lineno">22081</span>                <span class="comment">// null values are empty</span></div>
<div class="line"><span class="lineno">22082</span>                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">22083</span>            }</div>
<div class="line"><span class="lineno">22084</span> </div>
<div class="line"><span class="lineno">22085</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">22086</span>            {</div>
<div class="line"><span class="lineno">22087</span>                <span class="comment">// delegate call to array_t::empty()</span></div>
<div class="line"><span class="lineno">22088</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;empty();</div>
<div class="line"><span class="lineno">22089</span>            }</div>
<div class="line"><span class="lineno">22090</span> </div>
<div class="line"><span class="lineno">22091</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">22092</span>            {</div>
<div class="line"><span class="lineno">22093</span>                <span class="comment">// delegate call to object_t::empty()</span></div>
<div class="line"><span class="lineno">22094</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;empty();</div>
<div class="line"><span class="lineno">22095</span>            }</div>
<div class="line"><span class="lineno">22096</span> </div>
<div class="line"><span class="lineno">22097</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">22098</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">22099</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">22100</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">22101</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">22102</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">22103</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">22104</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">22105</span>            {</div>
<div class="line"><span class="lineno">22106</span>                <span class="comment">// all other types are nonempty</span></div>
<div class="line"><span class="lineno">22107</span>                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">22108</span>            }</div>
<div class="line"><span class="lineno">22109</span>        }</div>
<div class="line"><span class="lineno">22110</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0409aa6e94198aaedff3f285d3c98e8c" name="a0409aa6e94198aaedff3f285d3c98e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0409aa6e94198aaedff3f285d3c98e8c">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to one past the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/end/">https://json.nlohmann.me/api/basic_json/end/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21970">21970</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21971</span>    {</div>
<div class="line"><span class="lineno">21972</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>();</div>
<div class="line"><span class="lineno">21973</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06e303bfaafda414b4b5821384501bc1" name="a06e303bfaafda414b4b5821384501bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e303bfaafda414b4b5821384501bc1">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to one past the last element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/end/">https://json.nlohmann.me/api/basic_json/end/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21961">21961</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21962</span>    {</div>
<div class="line"><span class="lineno">21963</span>        <a class="code hl_typedef" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21964</span>        result.set_end();</div>
<div class="line"><span class="lineno">21965</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21966</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0e480e9d2391485c79747bb756628f61" name="a0e480e9d2391485c79747bb756628f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e480e9d2391485c79747bb756628f61">&#9670;&#160;</a></span>erase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON array given an index </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21788">21788</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21789</span>    {</div>
<div class="line"><span class="lineno">21790</span>        <span class="comment">// this erase only works for arrays</span></div>
<div class="line"><span class="lineno">21791</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">21792</span>        {</div>
<div class="line"><span class="lineno">21793</span>            <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(idx &gt;= <a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>()))</div>
<div class="line"><span class="lineno">21794</span>            {</div>
<div class="line"><span class="lineno">21795</span>                JSON_THROW(out_of_range::create(401, detail::concat(<span class="stringliteral">&quot;array index &quot;</span>, std::to_string(idx), <span class="stringliteral">&quot; is out of range&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21796</span>            }</div>
<div class="line"><span class="lineno">21797</span> </div>
<div class="line"><span class="lineno">21798</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;erase(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;begin() + <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">difference_type</a><span class="keyword">&gt;</span>(idx));</div>
<div class="line"><span class="lineno">21799</span>        }</div>
<div class="line"><span class="lineno">21800</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">21801</span>        {</div>
<div class="line"><span class="lineno">21802</span>            JSON_THROW(type_error::create(307, detail::concat(<span class="stringliteral">&quot;cannot use erase() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21803</span>        }</div>
<div class="line"><span class="lineno">21804</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d29d171d8941523a937bb6b5132b5a7" name="a8d29d171d8941523a937bb6b5132b5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d29d171d8941523a937bb6b5132b5a7">&#9670;&#160;</a></span>erase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21770">21770</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21771</span>    {</div>
<div class="line"><span class="lineno">21772</span>        <span class="comment">// the indirection via erase_internal() is added to avoid making this</span></div>
<div class="line"><span class="lineno">21773</span>        <span class="comment">// function a template and thus de-rank it during overload resolution</span></div>
<div class="line"><span class="lineno">21774</span>        <span class="keywordflow">return</span> erase_internal(key);</div>
<div class="line"><span class="lineno">21775</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a151124c5b91ecb1278c7e191053ce9ca" name="a151124c5b91ecb1278c7e191053ce9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151124c5b91ecb1278c7e191053ce9ca">&#9670;&#160;</a></span>erase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove elements given an iterator range </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21665">21665</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21666</span>    {</div>
<div class="line"><span class="lineno">21667</span>        <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><span class="lineno">21668</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(<span class="keyword">this</span> != first.m_object || <span class="keyword">this</span> != last.m_object))</div>
<div class="line"><span class="lineno">21669</span>        {</div>
<div class="line"><span class="lineno">21670</span>            JSON_THROW(invalid_iterator::create(203, <span class="stringliteral">&quot;iterators do not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21671</span>        }</div>
<div class="line"><span class="lineno">21672</span> </div>
<div class="line"><span class="lineno">21673</span>        IteratorType result = <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>();</div>
<div class="line"><span class="lineno">21674</span> </div>
<div class="line"><span class="lineno">21675</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">21676</span>        {</div>
<div class="line"><span class="lineno">21677</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">21678</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">21679</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">21680</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">21681</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">21682</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">21683</span>            {</div>
<div class="line"><span class="lineno">21684</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()</div>
<div class="line"><span class="lineno">21685</span>                                       || !last.m_it.primitive_iterator.is_end()))</div>
<div class="line"><span class="lineno">21686</span>                {</div>
<div class="line"><span class="lineno">21687</span>                    JSON_THROW(invalid_iterator::create(204, <span class="stringliteral">&quot;iterators out of range&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21688</span>                }</div>
<div class="line"><span class="lineno">21689</span> </div>
<div class="line"><span class="lineno">21690</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a>())</div>
<div class="line"><span class="lineno">21691</span>                {</div>
<div class="line"><span class="lineno">21692</span>                    AllocatorType&lt;string_t&gt; alloc;</div>
<div class="line"><span class="lineno">21693</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::destroy(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string);</div>
<div class="line"><span class="lineno">21694</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::deallocate(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string, 1);</div>
<div class="line"><span class="lineno">21695</span>                    <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">21696</span>                }</div>
<div class="line"><span class="lineno">21697</span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>())</div>
<div class="line"><span class="lineno">21698</span>                {</div>
<div class="line"><span class="lineno">21699</span>                    AllocatorType&lt;binary_t&gt; alloc;</div>
<div class="line"><span class="lineno">21700</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::destroy(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary);</div>
<div class="line"><span class="lineno">21701</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::deallocate(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary, 1);</div>
<div class="line"><span class="lineno">21702</span>                    <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">21703</span>                }</div>
<div class="line"><span class="lineno">21704</span> </div>
<div class="line"><span class="lineno">21705</span>                m_type = value_t::null;</div>
<div class="line"><span class="lineno">21706</span>                assert_invariant();</div>
<div class="line"><span class="lineno">21707</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21708</span>            }</div>
<div class="line"><span class="lineno">21709</span> </div>
<div class="line"><span class="lineno">21710</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">21711</span>            {</div>
<div class="line"><span class="lineno">21712</span>                result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;erase(first.m_it.object_iterator,</div>
<div class="line"><span class="lineno">21713</span>                                              last.m_it.object_iterator);</div>
<div class="line"><span class="lineno">21714</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21715</span>            }</div>
<div class="line"><span class="lineno">21716</span> </div>
<div class="line"><span class="lineno">21717</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">21718</span>            {</div>
<div class="line"><span class="lineno">21719</span>                result.m_it.array_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;erase(first.m_it.array_iterator,</div>
<div class="line"><span class="lineno">21720</span>                                             last.m_it.array_iterator);</div>
<div class="line"><span class="lineno">21721</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21722</span>            }</div>
<div class="line"><span class="lineno">21723</span> </div>
<div class="line"><span class="lineno">21724</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">21725</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">21726</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">21727</span>                JSON_THROW(type_error::create(307, detail::concat(<span class="stringliteral">&quot;cannot use erase() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21728</span>        }</div>
<div class="line"><span class="lineno">21729</span> </div>
<div class="line"><span class="lineno">21730</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21731</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a3d4378552d27c9f15e4cb4ff4c075c94"><div class="ttname"><a href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">basic_json::is_string</a></div><div class="ttdeci">constexpr bool is_string() const noexcept</div><div class="ttdoc">return whether value is a string</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20536">json.hpp:20536</a></div></div>
<div class="ttc" id="aclassbasic__json_html_aa25e81e71e2a263c0431f02f3245a8aa"><div class="ttname"><a href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">basic_json::is_binary</a></div><div class="ttdeci">constexpr bool is_binary() const noexcept</div><div class="ttdoc">return whether value is a binary array</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20543">json.hpp:20543</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a5ed019983b582705ef5ee43d15ca24" name="a7a5ed019983b582705ef5ee43d15ca24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5ed019983b582705ef5ee43d15ca24">&#9670;&#160;</a></span>erase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , detail::enable_if_t&lt; std::is_same&lt; IteratorType, typename basic_json_t::iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>||std::is_same&lt; IteratorType, typename basic_json_t::const_iterator &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IteratorType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element given an iterator </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21595">21595</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21596</span>    {</div>
<div class="line"><span class="lineno">21597</span>        <span class="comment">// make sure iterator fits the current value</span></div>
<div class="line"><span class="lineno">21598</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(<span class="keyword">this</span> != pos.m_object))</div>
<div class="line"><span class="lineno">21599</span>        {</div>
<div class="line"><span class="lineno">21600</span>            JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21601</span>        }</div>
<div class="line"><span class="lineno">21602</span> </div>
<div class="line"><span class="lineno">21603</span>        IteratorType result = <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>();</div>
<div class="line"><span class="lineno">21604</span> </div>
<div class="line"><span class="lineno">21605</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">21606</span>        {</div>
<div class="line"><span class="lineno">21607</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">21608</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">21609</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">21610</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">21611</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">21612</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">21613</span>            {</div>
<div class="line"><span class="lineno">21614</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))</div>
<div class="line"><span class="lineno">21615</span>                {</div>
<div class="line"><span class="lineno">21616</span>                    JSON_THROW(invalid_iterator::create(205, <span class="stringliteral">&quot;iterator out of range&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21617</span>                }</div>
<div class="line"><span class="lineno">21618</span> </div>
<div class="line"><span class="lineno">21619</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a>())</div>
<div class="line"><span class="lineno">21620</span>                {</div>
<div class="line"><span class="lineno">21621</span>                    AllocatorType&lt;string_t&gt; alloc;</div>
<div class="line"><span class="lineno">21622</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::destroy(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string);</div>
<div class="line"><span class="lineno">21623</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::deallocate(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string, 1);</div>
<div class="line"><span class="lineno">21624</span>                    <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">21625</span>                }</div>
<div class="line"><span class="lineno">21626</span>                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>())</div>
<div class="line"><span class="lineno">21627</span>                {</div>
<div class="line"><span class="lineno">21628</span>                    AllocatorType&lt;binary_t&gt; alloc;</div>
<div class="line"><span class="lineno">21629</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::destroy(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary);</div>
<div class="line"><span class="lineno">21630</span>                    std::allocator_traits&lt;<span class="keyword">decltype</span>(alloc)&gt;::deallocate(alloc, <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary, 1);</div>
<div class="line"><span class="lineno">21631</span>                    <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">21632</span>                }</div>
<div class="line"><span class="lineno">21633</span> </div>
<div class="line"><span class="lineno">21634</span>                m_type = value_t::null;</div>
<div class="line"><span class="lineno">21635</span>                assert_invariant();</div>
<div class="line"><span class="lineno">21636</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21637</span>            }</div>
<div class="line"><span class="lineno">21638</span> </div>
<div class="line"><span class="lineno">21639</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">21640</span>            {</div>
<div class="line"><span class="lineno">21641</span>                result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;erase(pos.m_it.object_iterator);</div>
<div class="line"><span class="lineno">21642</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21643</span>            }</div>
<div class="line"><span class="lineno">21644</span> </div>
<div class="line"><span class="lineno">21645</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">21646</span>            {</div>
<div class="line"><span class="lineno">21647</span>                result.m_it.array_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;erase(pos.m_it.array_iterator);</div>
<div class="line"><span class="lineno">21648</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">21649</span>            }</div>
<div class="line"><span class="lineno">21650</span> </div>
<div class="line"><span class="lineno">21651</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">21652</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">21653</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">21654</span>                JSON_THROW(type_error::create(307, detail::concat(<span class="stringliteral">&quot;cannot use erase() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21655</span>        }</div>
<div class="line"><span class="lineno">21656</span> </div>
<div class="line"><span class="lineno">21657</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21658</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3054e673f67fa325fbdcd0bf73d03c7b" name="a3054e673f67fa325fbdcd0bf73d03c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3054e673f67fa325fbdcd0bf73d03c7b">&#9670;&#160;</a></span>erase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove element from a JSON object given a key </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/erase/">https://json.nlohmann.me/api/basic_json/erase/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21781">21781</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21782</span>    {</div>
<div class="line"><span class="lineno">21783</span>        <span class="keywordflow">return</span> erase_internal(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21784</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ed11f83edce392fd94659b1102d078e" name="a8ed11f83edce392fd94659b1102d078e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed11f83edce392fd94659b1102d078e">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21818">21818</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21819</span>    {</div>
<div class="line"><span class="lineno">21820</span>        <span class="keyword">auto</span> result = <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>();</div>
<div class="line"><span class="lineno">21821</span> </div>
<div class="line"><span class="lineno">21822</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">21823</span>        {</div>
<div class="line"><span class="lineno">21824</span>            result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key);</div>
<div class="line"><span class="lineno">21825</span>        }</div>
<div class="line"><span class="lineno">21826</span> </div>
<div class="line"><span class="lineno">21827</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21828</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d8085b05e9a2e6f187708bca5e22d04" name="a8d8085b05e9a2e6f187708bca5e22d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8085b05e9a2e6f187708bca5e22d04">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21832">21832</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21833</span>    {</div>
<div class="line"><span class="lineno">21834</span>        <span class="keyword">auto</span> result = <a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>();</div>
<div class="line"><span class="lineno">21835</span> </div>
<div class="line"><span class="lineno">21836</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">21837</span>        {</div>
<div class="line"><span class="lineno">21838</span>            result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key);</div>
<div class="line"><span class="lineno">21839</span>        }</div>
<div class="line"><span class="lineno">21840</span> </div>
<div class="line"><span class="lineno">21841</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21842</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a81e01eb7be2878873ba084c0a0b20442" name="a81e01eb7be2878873ba084c0a0b20442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e01eb7be2878873ba084c0a0b20442">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21848">21848</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21849</span>    {</div>
<div class="line"><span class="lineno">21850</span>        <span class="keyword">auto</span> result = <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>();</div>
<div class="line"><span class="lineno">21851</span> </div>
<div class="line"><span class="lineno">21852</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">21853</span>        {</div>
<div class="line"><span class="lineno">21854</span>            result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21855</span>        }</div>
<div class="line"><span class="lineno">21856</span> </div>
<div class="line"><span class="lineno">21857</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21858</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a42890814a18f9c593f69218706113474" name="a42890814a18f9c593f69218706113474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42890814a18f9c593f69218706113474">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find an element in a JSON object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/find/">https://json.nlohmann.me/api/basic_json/find/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21864">21864</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21865</span>    {</div>
<div class="line"><span class="lineno">21866</span>        <span class="keyword">auto</span> result = <a class="code hl_function" href="classbasic__json.html#ab4f83081d8b64f6dc9b079af13266dc1">cend</a>();</div>
<div class="line"><span class="lineno">21867</span> </div>
<div class="line"><span class="lineno">21868</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">21869</span>        {</div>
<div class="line"><span class="lineno">21870</span>            result.m_it.object_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21871</span>        }</div>
<div class="line"><span class="lineno">21872</span> </div>
<div class="line"><span class="lineno">21873</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">21874</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9331162af6752277de4d1e476bb3f6bb" name="a9331162af6752277de4d1e476bb3f6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9331162af6752277de4d1e476bb3f6bb">&#9670;&#160;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return flattened JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/flatten/">https://json.nlohmann.me/api/basic_json/flatten/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23821">23821</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23822</span>    {</div>
<div class="line"><span class="lineno">23823</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result(value_t::object);</div>
<div class="line"><span class="lineno">23824</span>        json_pointer::flatten(<span class="stringliteral">&quot;&quot;</span>, *<span class="keyword">this</span>, result);</div>
<div class="line"><span class="lineno">23825</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23826</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="affeac471308bec4cfe026258f746cfcc" name="affeac471308bec4cfe026258f746cfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affeac471308bec4cfe026258f746cfcc">&#9670;&#160;</a></span>from_bjdata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23675">23675</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23678</span>    {</div>
<div class="line"><span class="lineno">23679</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23680</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23681</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23682</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23683</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23684</span>    }</div>
<div class="ttc" id="aclassdetail_1_1json__sax__dom__parser_html"><div class="ttname"><a href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser</a></div><div class="ttdoc">SAX implementation to create a JSON value from SAX events.</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l06730">json.hpp:6731</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a94c00d3023a03b37d9a362cdf61c17c1" name="a94c00d3023a03b37d9a362cdf61c17c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c00d3023a03b37d9a362cdf61c17c1">&#9670;&#160;</a></span>from_bjdata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bjdata </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BJData format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bjdata/">https://json.nlohmann.me/api/basic_json/from_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23690">23690</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23693</span>    {</div>
<div class="line"><span class="lineno">23694</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23695</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23696</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23697</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23698</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23699</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5d6a52ae542b7ffd137e87e72f9bcce" name="aa5d6a52ae542b7ffd137e87e72f9bcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d6a52ae542b7ffd137e87e72f9bcce">&#9670;&#160;</a></span>from_bson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23734">23734</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23737</span>    {</div>
<div class="line"><span class="lineno">23738</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a5ac8b0effce93dad2e3eec9c1a7ed129">from_bson</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><span class="lineno">23739</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a5ac8b0effce93dad2e3eec9c1a7ed129"><div class="ttname"><a href="classbasic__json.html#a5ac8b0effce93dad2e3eec9c1a7ed129">basic_json::from_bson</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_bson(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">create a JSON value from an input in BSON format</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23705">json.hpp:23705</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a868a32e0da318e39872fb825b377bda6" name="a868a32e0da318e39872fb825b377bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868a32e0da318e39872fb825b377bda6">&#9670;&#160;</a></span>from_bson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">detail::span_input_adapter &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23743">23743</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23746</span>    {</div>
<div class="line"><span class="lineno">23747</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23748</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23749</span>        <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><span class="lineno">23750</span>        <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23751</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23752</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23753</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ac8b0effce93dad2e3eec9c1a7ed129" name="a5ac8b0effce93dad2e3eec9c1a7ed129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac8b0effce93dad2e3eec9c1a7ed129">&#9670;&#160;</a></span>from_bson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23705">23705</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23708</span>    {</div>
<div class="line"><span class="lineno">23709</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23710</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23711</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23712</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23713</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23714</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06c87b306915435958b5e584dfb80ce4" name="a06c87b306915435958b5e584dfb80ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c87b306915435958b5e584dfb80ce4">&#9670;&#160;</a></span>from_bson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_bson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in BSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_bson/">https://json.nlohmann.me/api/basic_json/from_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23720">23720</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23723</span>    {</div>
<div class="line"><span class="lineno">23724</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23725</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23726</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23727</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23728</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23729</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0dcdc5f7b4a7ebf4b2a1a21710ad246d" name="a0dcdc5f7b4a7ebf4b2a1a21710ad246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcdc5f7b4a7ebf4b2a1a21710ad246d">&#9670;&#160;</a></span>from_cbor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code>cbor_tag_handler_t::error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23538">23538</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23542</span>    {</div>
<div class="line"><span class="lineno">23543</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a84e2d9cbd8a385017bb3d91c45a1753a">from_cbor</a>(ptr, ptr + len, strict, allow_exceptions, tag_handler);</div>
<div class="line"><span class="lineno">23544</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a84e2d9cbd8a385017bb3d91c45a1753a"><div class="ttname"><a href="classbasic__json.html#a84e2d9cbd8a385017bb3d91c45a1753a">basic_json::from_cbor</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_cbor(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true, const cbor_tag_handler_t tag_handler=cbor_tag_handler_t::error)</div><div class="ttdoc">create a JSON value from an input in CBOR format</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23507">json.hpp:23507</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adff52051e3e569f6f801b2d7b66124b1" name="adff52051e3e569f6f801b2d7b66124b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff52051e3e569f6f801b2d7b66124b1">&#9670;&#160;</a></span>from_cbor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">detail::span_input_adapter &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code>cbor_tag_handler_t::error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23549">23549</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23553</span>    {</div>
<div class="line"><span class="lineno">23554</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23555</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23556</span>        <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><span class="lineno">23557</span>        <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23558</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><span class="lineno">23559</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23560</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a84e2d9cbd8a385017bb3d91c45a1753a" name="a84e2d9cbd8a385017bb3d91c45a1753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e2d9cbd8a385017bb3d91c45a1753a">&#9670;&#160;</a></span>from_cbor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code>cbor_tag_handler_t::error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23507">23507</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23511</span>    {</div>
<div class="line"><span class="lineno">23512</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23513</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23514</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23515</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><span class="lineno">23516</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23517</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a93872bc620a9bbe028be81a3eaae21f3" name="a93872bc620a9bbe028be81a3eaae21f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93872bc620a9bbe028be81a3eaae21f3">&#9670;&#160;</a></span>from_cbor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_cbor </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedetail.html#a7c070b2bf3d61e3d8b8013f6fb18d592">cbor_tag_handler_t</a>&#160;</td>
          <td class="paramname"><em>tag_handler</em> = <code>cbor_tag_handler_t::error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in CBOR format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_cbor/">https://json.nlohmann.me/api/basic_json/from_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23523">23523</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23527</span>    {</div>
<div class="line"><span class="lineno">23528</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23529</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23530</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23531</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &amp;sdp, strict, tag_handler);</div>
<div class="line"><span class="lineno">23532</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23533</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac347f43d4eb713aa711d6c8a5fca41cf" name="ac347f43d4eb713aa711d6c8a5fca41cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347f43d4eb713aa711d6c8a5fca41cf">&#9670;&#160;</a></span>from_msgpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23595">23595</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23598</span>    {</div>
<div class="line"><span class="lineno">23599</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a96ba0ffab9429d589d658d3e053b8273">from_msgpack</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><span class="lineno">23600</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a96ba0ffab9429d589d658d3e053b8273"><div class="ttname"><a href="classbasic__json.html#a96ba0ffab9429d589d658d3e053b8273">basic_json::from_msgpack</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_msgpack(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">create a JSON value from an input in MessagePack format</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23566">json.hpp:23566</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a29d7be59d39991efb3a584cd2e6598" name="a2a29d7be59d39991efb3a584cd2e6598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29d7be59d39991efb3a584cd2e6598">&#9670;&#160;</a></span>from_msgpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">detail::span_input_adapter &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23604">23604</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23607</span>    {</div>
<div class="line"><span class="lineno">23608</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23609</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23610</span>        <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><span class="lineno">23611</span>        <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23612</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23613</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23614</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a96ba0ffab9429d589d658d3e053b8273" name="a96ba0ffab9429d589d658d3e053b8273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ba0ffab9429d589d658d3e053b8273">&#9670;&#160;</a></span>from_msgpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23566">23566</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23569</span>    {</div>
<div class="line"><span class="lineno">23570</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23571</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23572</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23573</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23574</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23575</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f3794747f5b19e0504afa3585476e97" name="a7f3794747f5b19e0504afa3585476e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3794747f5b19e0504afa3585476e97">&#9670;&#160;</a></span>from_msgpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_msgpack </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in MessagePack format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_msgpack/">https://json.nlohmann.me/api/basic_json/from_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23581">23581</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23584</span>    {</div>
<div class="line"><span class="lineno">23585</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23586</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23587</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23588</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23589</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23590</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d5a903e9aad342917fc3e98c070a0d7" name="a3d5a903e9aad342917fc3e98c070a0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5a903e9aad342917fc3e98c070a0d7">&#9670;&#160;</a></span>from_ubjson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23649">23649</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23652</span>    {</div>
<div class="line"><span class="lineno">23653</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a662ee4905d8c2628b3018b378bbd4c9e">from_ubjson</a>(ptr, ptr + len, strict, allow_exceptions);</div>
<div class="line"><span class="lineno">23654</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a662ee4905d8c2628b3018b378bbd4c9e"><div class="ttname"><a href="classbasic__json.html#a662ee4905d8c2628b3018b378bbd4c9e">basic_json::from_ubjson</a></div><div class="ttdeci">static JSON_HEDLEY_WARN_UNUSED_RESULT basic_json from_ubjson(InputType &amp;&amp;i, const bool strict=true, const bool allow_exceptions=true)</div><div class="ttdoc">create a JSON value from an input in UBJSON format</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23620">json.hpp:23620</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a99be0ee4212c46c20ee32d4a1a90cc6c" name="a99be0ee4212c46c20ee32d4a1a90cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99be0ee4212c46c20ee32d4a1a90cc6c">&#9670;&#160;</a></span>from_ubjson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">detail::span_input_adapter &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23658">23658</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23661</span>    {</div>
<div class="line"><span class="lineno">23662</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23663</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23664</span>        <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><span class="lineno">23665</span>        <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23666</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23667</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23668</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a662ee4905d8c2628b3018b378bbd4c9e" name="a662ee4905d8c2628b3018b378bbd4c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662ee4905d8c2628b3018b378bbd4c9e">&#9670;&#160;</a></span>from_ubjson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23620">23620</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23623</span>    {</div>
<div class="line"><span class="lineno">23624</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23625</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23626</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23627</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23628</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23629</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad36123b583eaae095ee46413e4e380ef" name="ad36123b583eaae095ee46413e4e380ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36123b583eaae095ee46413e4e380ef">&#9670;&#160;</a></span>from_ubjson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::from_ubjson </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>allow_exceptions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a JSON value from an input in UBJSON format </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/from_ubjson/">https://json.nlohmann.me/api/basic_json/from_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23635">23635</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23638</span>    {</div>
<div class="line"><span class="lineno">23639</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">23640</span>        <a class="code hl_class" href="classdetail_1_1json__sax__dom__parser.html">detail::json_sax_dom_parser&lt;basic_json&gt;</a> sdp(result, allow_exceptions);</div>
<div class="line"><span class="lineno">23641</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23642</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> res = binary_reader&lt;decltype(ia)&gt;(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &amp;sdp, strict);</div>
<div class="line"><span class="lineno">23643</span>        <span class="keywordflow">return</span> res ? result : <a class="code hl_class" href="classbasic__json.html">basic_json</a>(value_t::discarded);</div>
<div class="line"><span class="lineno">23644</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb6f631d1a7f8f23772434f22a06108e" name="aeb6f631d1a7f8f23772434f22a06108e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6f631d1a7f8f23772434f22a06108e">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21560">21560</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21561</span>    {</div>
<div class="line"><span class="lineno">21562</span>        <span class="keywordflow">return</span> *<a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>();</div>
<div class="line"><span class="lineno">21563</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85577855985468abef750d5265e23c2a" name="a85577855985468abef750d5265e23c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85577855985468abef750d5265e23c2a">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access the first element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/front/">https://json.nlohmann.me/api/basic_json/front/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21567">21567</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21568</span>    {</div>
<div class="line"><span class="lineno">21569</span>        <span class="keywordflow">return</span> *<a class="code hl_function" href="classbasic__json.html#a3451ab7e33828ded865a4c6c2e22463b">cbegin</a>();</div>
<div class="line"><span class="lineno">21570</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab11bff397526e8255d151066caeba48e" name="ab11bff397526e8255d151066caeba48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11bff397526e8255d151066caeba48e">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueTypeCV , typename ValueType  = detail::uncvref_t&lt;ValueTypeCV&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(<a class="el" href="structdetail_1_1priority__tag.html">detail::priority_tag</a>&lt;4&gt; {}))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a (pointer) value (explicit) </p>
<p>Performs explicit type conversion between the JSON value and a compatible value if required.</p>
<ul>
<li>If the requested type is a pointer to the internally stored JSON value that pointer is returned. No copies are made.</li>
<li>If the requested type is the current <a class="el" href="classbasic__json.html">basic_json</a>, or a different <a class="el" href="classbasic__json.html">basic_json</a> convertible from the current <a class="el" href="classbasic__json.html">basic_json</a>.</li>
<li>Otherwise the value is converted by calling the json_serializer&lt;ValueType&gt; <code>from_json()</code> method.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueTypeCV</td><td>the provided value type </td></tr>
    <tr><td class="paramname">ValueType</td><td>the returned value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>if necessary</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">what</td><td>json_serializer&lt;ValueType&gt; <code>from_json()</code> method throws if conversion is required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>version 2.1.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20909">20909</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20910</span>                                                                                                  {})))</div>
<div class="line"><span class="lineno">20911</span>    -&gt; <span class="keyword">decltype</span>(std::declval&lt;const basic_json_t&amp;&gt;().template get_impl&lt;ValueType&gt;(<a class="code hl_struct" href="structdetail_1_1priority__tag.html">detail::priority_tag&lt;4&gt;</a> {}))</div>
<div class="line"><span class="lineno">20912</span>    {</div>
<div class="line"><span class="lineno">20913</span>        <span class="comment">// we cannot static_assert on ValueTypeCV being non-const, because</span></div>
<div class="line"><span class="lineno">20914</span>        <span class="comment">// there is support for get&lt;const basic_json_t&gt;(), which is why we</span></div>
<div class="line"><span class="lineno">20915</span>        <span class="comment">// still need the uncvref</span></div>
<div class="line"><span class="lineno">20916</span>        <span class="keyword">static_assert</span>(!std::is_reference&lt;ValueTypeCV&gt;::value,</div>
<div class="line"><span class="lineno">20917</span>                      <span class="stringliteral">&quot;get() cannot be used with reference types, you might want to use get_ref()&quot;</span>);</div>
<div class="line"><span class="lineno">20918</span>        <span class="keywordflow">return</span> get_impl&lt;ValueType&gt;(<a class="code hl_struct" href="structdetail_1_1priority__tag.html">detail::priority_tag&lt;4&gt;</a> {});</div>
<div class="line"><span class="lineno">20919</span>    }</div>
<div class="ttc" id="astructdetail_1_1priority__tag_html"><div class="ttname"><a href="structdetail_1_1priority__tag.html">detail::priority_tag</a></div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l03190">json.hpp:3190</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a35fa19a3f6193409abe4bd9014712105" name="a35fa19a3f6193409abe4bd9014712105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fa19a3f6193409abe4bd9014712105">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().template <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr</a>&lt;PointerType&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (explicit) </p>
<p>Explicit pointer access to the internally stored JSON value. No copies are made.</p>
<dl class="section warning"><dt>Warning</dt><dd>The pointer becomes invalid if the underlying JSON object changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointerType</td><td>pointer type; must be a pointer to <a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a>, <a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a>, <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>, <a class="el" href="classbasic__json.html#af396ac808d774d4ea0db4c7da11ce569">boolean_t</a>, <a class="el" href="classbasic__json.html#a8b702448867b892700c768db4208a670">number_integer_t</a>, <a class="el" href="classbasic__json.html#aebb9c6a13e947a86e2a13fbe6ebd77f4">number_unsigned_t</a>, or <a class="el" href="classbasic__json.html#a1fd24dfabbdd1dc35513c82244633ca4">number_float_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the internally stored JSON value if the requested pointer type <em>PointerType</em> fits to the JSON value; <code>nullptr</code> otherwise</dd></dl>
<p>@complexity Constant.</p>
<p>@liveexample{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a <code>nullptr</code> is returned if the value and the requested pointer type does not match.,get__PointerType}</p>
<dl class="section see"><dt>See also</dt><dd>see <a class="el" href="classbasic__json.html#a206a3748ff1fc676f64f753e203388dd">get_ptr()</a> for explicit pointer-member access</dd></dl>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20950">20950</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20951</span>    {</div>
<div class="line"><span class="lineno">20952</span>        <span class="comment">// delegate the call to get_ptr</span></div>
<div class="line"><span class="lineno">20953</span>        <span class="keywordflow">return</span> get_ptr&lt;PointerType&gt;();</div>
<div class="line"><span class="lineno">20954</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1aaddd9686fb1dd50203c2138858df7e" name="a1aaddd9686fb1dd50203c2138858df7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaddd9686fb1dd50203c2138858df7e">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the allocator associated with the container </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_allocator/">https://json.nlohmann.me/api/basic_json/get_allocator/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19416">19416</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">19417</span>    {</div>
<div class="line"><span class="lineno">19418</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">allocator_type</a>();</div>
<div class="line"><span class="lineno">19419</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a485873eed243b6ca7e30c96130a5ec2d"><div class="ttname"><a href="classbasic__json.html#a485873eed243b6ca7e30c96130a5ec2d">basic_json::allocator_type</a></div><div class="ttdeci">AllocatorType&lt; basic_json &gt; allocator_type</div><div class="ttdoc">the allocator type</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19395">json.hpp:19395</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4401911681258520903f3c374a9e994" name="aa4401911681258520903f3c374a9e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4401911681258520903f3c374a9e994">&#9670;&#160;</a></span>get_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21069">21069</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21070</span>    {</div>
<div class="line"><span class="lineno">21071</span>        <span class="keywordflow">if</span> (!<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>())</div>
<div class="line"><span class="lineno">21072</span>        {</div>
<div class="line"><span class="lineno">21073</span>            JSON_THROW(type_error::create(302, detail::concat(<span class="stringliteral">&quot;type must be binary, but is &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21074</span>        }</div>
<div class="line"><span class="lineno">21075</span> </div>
<div class="line"><span class="lineno">21076</span>        <span class="keywordflow">return</span> *get_ptr&lt;binary_t*&gt;();</div>
<div class="line"><span class="lineno">21077</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a44b4244ff0e901156adfad7b027232de" name="a44b4244ff0e901156adfad7b027232de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b4244ff0e901156adfad7b027232de">&#9670;&#160;</a></span>get_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a binary value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_binary/">https://json.nlohmann.me/api/basic_json/get_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21081">21081</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21082</span>    {</div>
<div class="line"><span class="lineno">21083</span>        <span class="keywordflow">if</span> (!<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>())</div>
<div class="line"><span class="lineno">21084</span>        {</div>
<div class="line"><span class="lineno">21085</span>            JSON_THROW(type_error::create(302, detail::concat(<span class="stringliteral">&quot;type must be binary, but is &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21086</span>        }</div>
<div class="line"><span class="lineno">21087</span> </div>
<div class="line"><span class="lineno">21088</span>        <span class="keywordflow">return</span> *get_ptr&lt;const binary_t*&gt;();</div>
<div class="line"><span class="lineno">21089</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2055fcc0c999d3cb4c211f258695faff" name="a2055fcc0c999d3cb4c211f258695faff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2055fcc0c999d3cb4c211f258695faff">&#9670;&#160;</a></span>get_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20721">20721</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20722</span>    {</div>
<div class="line"><span class="lineno">20723</span>        <span class="comment">// delegate the call to get_impl_ptr&lt;&gt;() const</span></div>
<div class="line"><span class="lineno">20724</span>        <span class="keywordflow">return</span> get_impl_ptr(<span class="keyword">static_cast&lt;</span>PointerType<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno">20725</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a206a3748ff1fc676f64f753e203388dd" name="a206a3748ff1fc676f64f753e203388dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206a3748ff1fc676f64f753e203388dd">&#9670;&#160;</a></span>get_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename PointerType , typename std::enable_if&lt; std::is_pointer&lt; PointerType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;basic_json_t&amp;&gt;().get_impl_ptr(std::declval&lt;PointerType&gt;()))
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pointer value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ptr/">https://json.nlohmann.me/api/basic_json/get_ptr/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20710">20710</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20711</span>    {</div>
<div class="line"><span class="lineno">20712</span>        <span class="comment">// delegate the call to get_impl_ptr&lt;&gt;()</span></div>
<div class="line"><span class="lineno">20713</span>        <span class="keywordflow">return</span> get_impl_ptr(<span class="keyword">static_cast&lt;</span>PointerType<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno">20714</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7bfdaa5014da75e18dd07cc76e53b237" name="a7bfdaa5014da75e18dd07cc76e53b237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfdaa5014da75e18dd07cc76e53b237">&#9670;&#160;</a></span>get_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20999">20999</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21000</span>    {</div>
<div class="line"><span class="lineno">21001</span>        <span class="comment">// delegate call to get_ref_impl</span></div>
<div class="line"><span class="lineno">21002</span>        <span class="keywordflow">return</span> get_ref_impl&lt;ReferenceType&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21003</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a42f1f9cf90ed5254e38e6b587fce237d" name="a42f1f9cf90ed5254e38e6b587fce237d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f1f9cf90ed5254e38e6b587fce237d">&#9670;&#160;</a></span>get_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ReferenceType , typename std::enable_if&lt; std::is_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;std::is_const&lt; typename std::remove_reference&lt; ReferenceType &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a> &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a reference value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_ref/">https://json.nlohmann.me/api/basic_json/get_ref/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21010">21010</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21011</span>    {</div>
<div class="line"><span class="lineno">21012</span>        <span class="comment">// delegate call to get_ref_impl</span></div>
<div class="line"><span class="lineno">21013</span>        <span class="keywordflow">return</span> get_ref_impl&lt;ReferenceType&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">21014</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6a78b37dee5a709f610375403597bba" name="ac6a78b37dee5a709f610375403597bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a78b37dee5a709f610375403597bba">&#9670;&#160;</a></span>get_to() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename Array  = T (&amp;)[N], detail::enable_if_t&lt; <a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, Array &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Array <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>v</em>[N]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20987">20987</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20990</span>    {</div>
<div class="line"><span class="lineno">20991</span>        JSONSerializer&lt;Array&gt;::from_json(*<span class="keyword">this</span>, v);</div>
<div class="line"><span class="lineno">20992</span>        <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">20993</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e0131c192963ed4d1148805120aa319" name="a9e0131c192963ed4d1148805120aa319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0131c192963ed4d1148805120aa319">&#9670;&#160;</a></span>get_to() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20976">20976</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20977</span>    {</div>
<div class="line"><span class="lineno">20978</span>        v = *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">20979</span>        <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">20980</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a251b2b7f275328615aed5a0f827e7710" name="a251b2b7f275328615aed5a0f827e7710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251b2b7f275328615aed5a0f827e7710">&#9670;&#160;</a></span>get_to() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a> &amp;&amp;<a class="el" href="structdetail_1_1has__from__json.html">detail::has_from_json</a>&lt; basic_json_t, ValueType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::get_to </td>
          <td>(</td>
          <td class="paramtype">ValueType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/get_to/">https://json.nlohmann.me/api/basic_json/get_to/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20963">20963</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20965</span>    {</div>
<div class="line"><span class="lineno">20966</span>        JSONSerializer&lt;ValueType&gt;::from_json(*<span class="keyword">this</span>, v);</div>
<div class="line"><span class="lineno">20967</span>        <span class="keywordflow">return</span> v;</div>
<div class="line"><span class="lineno">20968</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a797b7b5589862535c88b9604c88d8d3e" name="a797b7b5589862535c88b9604c88d8d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797b7b5589862535c88b9604c88d8d3e">&#9670;&#160;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22553">22553</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22554</span>    {</div>
<div class="line"><span class="lineno">22555</span>        <span class="comment">// insert only works for objects</span></div>
<div class="line"><span class="lineno">22556</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">22557</span>        {</div>
<div class="line"><span class="lineno">22558</span>            JSON_THROW(type_error::create(309, detail::concat(<span class="stringliteral">&quot;cannot use insert() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22559</span>        }</div>
<div class="line"><span class="lineno">22560</span> </div>
<div class="line"><span class="lineno">22561</span>        <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><span class="lineno">22562</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))</div>
<div class="line"><span class="lineno">22563</span>        {</div>
<div class="line"><span class="lineno">22564</span>            JSON_THROW(invalid_iterator::create(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22565</span>        }</div>
<div class="line"><span class="lineno">22566</span> </div>
<div class="line"><span class="lineno">22567</span>        <span class="comment">// passed iterators must belong to objects</span></div>
<div class="line"><span class="lineno">22568</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()))</div>
<div class="line"><span class="lineno">22569</span>        {</div>
<div class="line"><span class="lineno">22570</span>            JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterators first and last must point to objects&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22571</span>        }</div>
<div class="line"><span class="lineno">22572</span> </div>
<div class="line"><span class="lineno">22573</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;insert(first.m_it.object_iterator, last.m_it.object_iterator);</div>
<div class="line"><span class="lineno">22574</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5cd6ab85d95fa08d0fbce5f957834f28" name="a5cd6ab85d95fa08d0fbce5f957834f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd6ab85d95fa08d0fbce5f957834f28">&#9670;&#160;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22475">22475</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22476</span>    {</div>
<div class="line"><span class="lineno">22477</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">insert</a>(pos, val);</div>
<div class="line"><span class="lineno">22478</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a4467ec0c7679150140f9d2f85e95bf4b"><div class="ttname"><a href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">basic_json::insert</a></div><div class="ttdeci">iterator insert(const_iterator pos, const basic_json &amp;val)</div><div class="ttdoc">inserts element into array</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22455">json.hpp:22455</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4467ec0c7679150140f9d2f85e95bf4b" name="a4467ec0c7679150140f9d2f85e95bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4467ec0c7679150140f9d2f85e95bf4b">&#9670;&#160;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22455">22455</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22456</span>    {</div>
<div class="line"><span class="lineno">22457</span>        <span class="comment">// insert only works for arrays</span></div>
<div class="line"><span class="lineno">22458</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">22459</span>        {</div>
<div class="line"><span class="lineno">22460</span>            <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><span class="lineno">22461</span>            <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><span class="lineno">22462</span>            {</div>
<div class="line"><span class="lineno">22463</span>                JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22464</span>            }</div>
<div class="line"><span class="lineno">22465</span> </div>
<div class="line"><span class="lineno">22466</span>            <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><span class="lineno">22467</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a>(pos, val);</div>
<div class="line"><span class="lineno">22468</span>        }</div>
<div class="line"><span class="lineno">22469</span> </div>
<div class="line"><span class="lineno">22470</span>        JSON_THROW(type_error::create(309, detail::concat(<span class="stringliteral">&quot;cannot use insert() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22471</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a6940b08bda32ce195a9e4508b8aa1126"><div class="ttname"><a href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">basic_json::insert_iterator</a></div><div class="ttdeci">iterator insert_iterator(const_iterator pos, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22436">json.hpp:22436</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af30d7fc224999adeaa9e4dcd81db0f05" name="af30d7fc224999adeaa9e4dcd81db0f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30d7fc224999adeaa9e4dcd81db0f05">&#9670;&#160;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts range of elements into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22502">22502</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22503</span>    {</div>
<div class="line"><span class="lineno">22504</span>        <span class="comment">// insert only works for arrays</span></div>
<div class="line"><span class="lineno">22505</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">22506</span>        {</div>
<div class="line"><span class="lineno">22507</span>            JSON_THROW(type_error::create(309, detail::concat(<span class="stringliteral">&quot;cannot use insert() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22508</span>        }</div>
<div class="line"><span class="lineno">22509</span> </div>
<div class="line"><span class="lineno">22510</span>        <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><span class="lineno">22511</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><span class="lineno">22512</span>        {</div>
<div class="line"><span class="lineno">22513</span>            JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22514</span>        }</div>
<div class="line"><span class="lineno">22515</span> </div>
<div class="line"><span class="lineno">22516</span>        <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><span class="lineno">22517</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))</div>
<div class="line"><span class="lineno">22518</span>        {</div>
<div class="line"><span class="lineno">22519</span>            JSON_THROW(invalid_iterator::create(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22520</span>        }</div>
<div class="line"><span class="lineno">22521</span> </div>
<div class="line"><span class="lineno">22522</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(first.m_object == <span class="keyword">this</span>))</div>
<div class="line"><span class="lineno">22523</span>        {</div>
<div class="line"><span class="lineno">22524</span>            JSON_THROW(invalid_iterator::create(211, <span class="stringliteral">&quot;passed iterators may not belong to container&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22525</span>        }</div>
<div class="line"><span class="lineno">22526</span> </div>
<div class="line"><span class="lineno">22527</span>        <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><span class="lineno">22528</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a>(pos, first.m_it.array_iterator, last.m_it.array_iterator);</div>
<div class="line"><span class="lineno">22529</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b25eeb503c9f30322b966af0451da38" name="a3b25eeb503c9f30322b966af0451da38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b25eeb503c9f30322b966af0451da38">&#9670;&#160;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts elements from initializer list into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22533">22533</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22534</span>    {</div>
<div class="line"><span class="lineno">22535</span>        <span class="comment">// insert only works for arrays</span></div>
<div class="line"><span class="lineno">22536</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">22537</span>        {</div>
<div class="line"><span class="lineno">22538</span>            JSON_THROW(type_error::create(309, detail::concat(<span class="stringliteral">&quot;cannot use insert() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22539</span>        }</div>
<div class="line"><span class="lineno">22540</span> </div>
<div class="line"><span class="lineno">22541</span>        <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><span class="lineno">22542</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><span class="lineno">22543</span>        {</div>
<div class="line"><span class="lineno">22544</span>            JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22545</span>        }</div>
<div class="line"><span class="lineno">22546</span> </div>
<div class="line"><span class="lineno">22547</span>        <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><span class="lineno">22548</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a>(pos, ilist.begin(), ilist.end());</div>
<div class="line"><span class="lineno">22549</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d7b302f4e6249b8b28dcfbebd934600" name="a1d7b302f4e6249b8b28dcfbebd934600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7b302f4e6249b8b28dcfbebd934600">&#9670;&#160;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts copies of element into array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/insert/">https://json.nlohmann.me/api/basic_json/insert/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22482">22482</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22483</span>    {</div>
<div class="line"><span class="lineno">22484</span>        <span class="comment">// insert only works for arrays</span></div>
<div class="line"><span class="lineno">22485</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">22486</span>        {</div>
<div class="line"><span class="lineno">22487</span>            <span class="comment">// check if iterator pos fits to this JSON value</span></div>
<div class="line"><span class="lineno">22488</span>            <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(pos.m_object != <span class="keyword">this</span>))</div>
<div class="line"><span class="lineno">22489</span>            {</div>
<div class="line"><span class="lineno">22490</span>                JSON_THROW(invalid_iterator::create(202, <span class="stringliteral">&quot;iterator does not fit current value&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22491</span>            }</div>
<div class="line"><span class="lineno">22492</span> </div>
<div class="line"><span class="lineno">22493</span>            <span class="comment">// insert to array and return iterator</span></div>
<div class="line"><span class="lineno">22494</span>            <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a6940b08bda32ce195a9e4508b8aa1126">insert_iterator</a>(pos, cnt, val);</div>
<div class="line"><span class="lineno">22495</span>        }</div>
<div class="line"><span class="lineno">22496</span> </div>
<div class="line"><span class="lineno">22497</span>        JSON_THROW(type_error::create(309, detail::concat(<span class="stringliteral">&quot;cannot use insert() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22498</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6940b08bda32ce195a9e4508b8aa1126" name="a6940b08bda32ce195a9e4508b8aa1126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6940b08bda32ce195a9e4508b8aa1126">&#9670;&#160;</a></span>insert_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::insert_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for insertion of an iterator </p><dl class="section note"><dt>Note</dt><dd>: This uses std::distance to support GCC 4.8, see <a href="https://github.com/nlohmann/json/pull/1257">https://github.com/nlohmann/json/pull/1257</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22436">22436</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22437</span>    {</div>
<div class="line"><span class="lineno">22438</span>        <a class="code hl_typedef" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> result(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">22439</span>        JSON_ASSERT(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array != <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">22440</span> </div>
<div class="line"><span class="lineno">22441</span>        <span class="keyword">auto</span> insert_pos = std::distance(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;begin(), pos.m_it.array_iterator);</div>
<div class="line"><span class="lineno">22442</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;insert(pos.m_it.array_iterator, std::forward&lt;Args&gt;(args)...);</div>
<div class="line"><span class="lineno">22443</span>        result.m_it.array_iterator = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;begin() + insert_pos;</div>
<div class="line"><span class="lineno">22444</span> </div>
<div class="line"><span class="lineno">22445</span>        <span class="comment">// This could have been written as:</span></div>
<div class="line"><span class="lineno">22446</span>        <span class="comment">// result.m_it.array_iterator = m_value.array-&gt;insert(pos.m_it.array_iterator, cnt, val);</span></div>
<div class="line"><span class="lineno">22447</span>        <span class="comment">// but the return value of insert is missing in GCC 4.8, so it is written this way instead.</span></div>
<div class="line"><span class="lineno">22448</span> </div>
<div class="line"><span class="lineno">22449</span>        set_parents();</div>
<div class="line"><span class="lineno">22450</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">22451</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a89ea48a4e802ef81783c0c7ce89aa7bb" name="a89ea48a4e802ef81783c0c7ce89aa7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ea48a4e802ef81783c0c7ce89aa7bb">&#9670;&#160;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_array/">https://json.nlohmann.me/api/basic_json/is_array/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20529">20529</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20530</span>    {</div>
<div class="line"><span class="lineno">20531</span>        <span class="keywordflow">return</span> m_type == value_t::array;</div>
<div class="line"><span class="lineno">20532</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa25e81e71e2a263c0431f02f3245a8aa" name="aa25e81e71e2a263c0431f02f3245a8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25e81e71e2a263c0431f02f3245a8aa">&#9670;&#160;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a binary array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_binary/">https://json.nlohmann.me/api/basic_json/is_binary/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20543">20543</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20544</span>    {</div>
<div class="line"><span class="lineno">20545</span>        <span class="keywordflow">return</span> m_type == value_t::binary;</div>
<div class="line"><span class="lineno">20546</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a814771ab0add0def16119c157b44003a" name="a814771ab0add0def16119c157b44003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814771ab0add0def16119c157b44003a">&#9670;&#160;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_boolean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a boolean </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_boolean/">https://json.nlohmann.me/api/basic_json/is_boolean/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20487">20487</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20488</span>    {</div>
<div class="line"><span class="lineno">20489</span>        <span class="keywordflow">return</span> m_type == value_t::boolean;</div>
<div class="line"><span class="lineno">20490</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abcc7082bb9fa07704c659f6be7c41bc9" name="abcc7082bb9fa07704c659f6be7c41bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7082bb9fa07704c659f6be7c41bc9">&#9670;&#160;</a></span>is_discarded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_discarded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is discarded </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_discarded/">https://json.nlohmann.me/api/basic_json/is_discarded/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20550">20550</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20551</span>    {</div>
<div class="line"><span class="lineno">20552</span>        <span class="keywordflow">return</span> m_type == value_t::discarded;</div>
<div class="line"><span class="lineno">20553</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ed948b2c2e71ce5f5c03b5eeb575df4" name="a6ed948b2c2e71ce5f5c03b5eeb575df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed948b2c2e71ce5f5c03b5eeb575df4">&#9670;&#160;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is null </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_null/">https://json.nlohmann.me/api/basic_json/is_null/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20480">20480</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20481</span>    {</div>
<div class="line"><span class="lineno">20482</span>        <span class="keywordflow">return</span> m_type == value_t::null;</div>
<div class="line"><span class="lineno">20483</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab84294fe5d1a2822e2f67685f6e8c735" name="ab84294fe5d1a2822e2f67685f6e8c735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84294fe5d1a2822e2f67685f6e8c735">&#9670;&#160;</a></span>is_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number/">https://json.nlohmann.me/api/basic_json/is_number/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20494">20494</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20495</span>    {</div>
<div class="line"><span class="lineno">20496</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#ad14438fe7c1f5a2f750eb56b8e73e538">is_number_integer</a>() || <a class="code hl_function" href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">is_number_float</a>();</div>
<div class="line"><span class="lineno">20497</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aa8c885a9182fd22b05826ab2a9548f60"><div class="ttname"><a href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">basic_json::is_number_float</a></div><div class="ttdeci">constexpr bool is_number_float() const noexcept</div><div class="ttdoc">return whether value is a floating-point number</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20515">json.hpp:20515</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ad14438fe7c1f5a2f750eb56b8e73e538"><div class="ttname"><a href="classbasic__json.html#ad14438fe7c1f5a2f750eb56b8e73e538">basic_json::is_number_integer</a></div><div class="ttdeci">constexpr bool is_number_integer() const noexcept</div><div class="ttdoc">return whether value is an integer number</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20501">json.hpp:20501</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8c885a9182fd22b05826ab2a9548f60" name="aa8c885a9182fd22b05826ab2a9548f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c885a9182fd22b05826ab2a9548f60">&#9670;&#160;</a></span>is_number_float()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a floating-point number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_float/">https://json.nlohmann.me/api/basic_json/is_number_float/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20515">20515</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20516</span>    {</div>
<div class="line"><span class="lineno">20517</span>        <span class="keywordflow">return</span> m_type == value_t::number_float;</div>
<div class="line"><span class="lineno">20518</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad14438fe7c1f5a2f750eb56b8e73e538" name="ad14438fe7c1f5a2f750eb56b8e73e538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14438fe7c1f5a2f750eb56b8e73e538">&#9670;&#160;</a></span>is_number_integer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_integer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_integer/">https://json.nlohmann.me/api/basic_json/is_number_integer/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20501">20501</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20502</span>    {</div>
<div class="line"><span class="lineno">20503</span>        <span class="keywordflow">return</span> m_type == value_t::number_integer || m_type == value_t::number_unsigned;</div>
<div class="line"><span class="lineno">20504</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5744d3f2404f2376ab0dbe531e4d3bc" name="aa5744d3f2404f2376ab0dbe531e4d3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5744d3f2404f2376ab0dbe531e4d3bc">&#9670;&#160;</a></span>is_number_unsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_number_unsigned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an unsigned integer number </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_number_unsigned/">https://json.nlohmann.me/api/basic_json/is_number_unsigned/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20508">20508</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20509</span>    {</div>
<div class="line"><span class="lineno">20510</span>        <span class="keywordflow">return</span> m_type == value_t::number_unsigned;</div>
<div class="line"><span class="lineno">20511</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af758a912346776b086abb82487b1d73b" name="af758a912346776b086abb82487b1d73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af758a912346776b086abb82487b1d73b">&#9670;&#160;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_object/">https://json.nlohmann.me/api/basic_json/is_object/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20522">20522</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20523</span>    {</div>
<div class="line"><span class="lineno">20524</span>        <span class="keywordflow">return</span> m_type == value_t::object;</div>
<div class="line"><span class="lineno">20525</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7fa8bc506b1519193a7bbc09f8a0f095" name="a7fa8bc506b1519193a7bbc09f8a0f095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa8bc506b1519193a7bbc09f8a0f095">&#9670;&#160;</a></span>is_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_primitive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is primitive </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_primitive/">https://json.nlohmann.me/api/basic_json/is_primitive/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20466">20466</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20467</span>    {</div>
<div class="line"><span class="lineno">20468</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a>() || <a class="code hl_function" href="classbasic__json.html#a814771ab0add0def16119c157b44003a">is_boolean</a>() || <a class="code hl_function" href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">is_number</a>() || <a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>();</div>
<div class="line"><span class="lineno">20469</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a814771ab0add0def16119c157b44003a"><div class="ttname"><a href="classbasic__json.html#a814771ab0add0def16119c157b44003a">basic_json::is_boolean</a></div><div class="ttdeci">constexpr bool is_boolean() const noexcept</div><div class="ttdoc">return whether value is a boolean</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20487">json.hpp:20487</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ab84294fe5d1a2822e2f67685f6e8c735"><div class="ttname"><a href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">basic_json::is_number</a></div><div class="ttdeci">constexpr bool is_number() const noexcept</div><div class="ttdoc">return whether value is a number</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20494">json.hpp:20494</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d4378552d27c9f15e4cb4ff4c075c94" name="a3d4378552d27c9f15e4cb4ff4c075c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4378552d27c9f15e4cb4ff4c075c94">&#9670;&#160;</a></span>is_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether value is a string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_string/">https://json.nlohmann.me/api/basic_json/is_string/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20536">20536</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20537</span>    {</div>
<div class="line"><span class="lineno">20538</span>        <span class="keywordflow">return</span> m_type == value_t::string;</div>
<div class="line"><span class="lineno">20539</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aded85ec1014821c21b8a47bc816a6917" name="aded85ec1014821c21b8a47bc816a6917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded85ec1014821c21b8a47bc816a6917">&#9670;&#160;</a></span>is_structured()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::is_structured </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether type is structured </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/is_structured/">https://json.nlohmann.me/api/basic_json/is_structured/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20473">20473</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20474</span>    {</div>
<div class="line"><span class="lineno">20475</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>() || <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>();</div>
<div class="line"><span class="lineno">20476</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b062fb036928f3c4c945c18609ca0ec" name="a2b062fb036928f3c4c945c18609ca0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b062fb036928f3c4c945c18609ca0ec">&#9670;&#160;</a></span>items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iteration_proxy&lt; <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper to access iterator member functions in range-based for </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/items/">https://json.nlohmann.me/api/basic_json/items/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22058">22058</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22059</span>    {</div>
<div class="line"><span class="lineno">22060</span>        <span class="keywordflow">return</span> iteration_proxy&lt;const_iterator&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">22061</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a164b219291271e36e427d6b9c9916fec" name="a164b219291271e36e427d6b9c9916fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164b219291271e36e427d6b9c9916fec">&#9670;&#160;</a></span>items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iteration_proxy&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper to access iterator member functions in range-based for </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/items/">https://json.nlohmann.me/api/basic_json/items/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22051">22051</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22052</span>    {</div>
<div class="line"><span class="lineno">22053</span>        <span class="keywordflow">return</span> iteration_proxy&lt;iterator&gt;(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">22054</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af373ec8f75f254b79fe1b1ca776797b9" name="af373ec8f75f254b79fe1b1ca776797b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af373ec8f75f254b79fe1b1ca776797b9">&#9670;&#160;</a></span>iterator_wrapper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static iteration_proxy&lt; <a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a> &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrapper to access iterator member functions in range-based for </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/items/">https://json.nlohmann.me/api/basic_json/items/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function is deprecated since 3.1.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#a164b219291271e36e427d6b9c9916fec">items()</a> instead; that is, replace <code>json::iterator_wrapper(j)</code> with <code>j.items()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22044">22044</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22045</span>    {</div>
<div class="line"><span class="lineno">22046</span>        <span class="keywordflow">return</span> ref.items();</div>
<div class="line"><span class="lineno">22047</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a091a63384590fe2cf7a122155b30011a" name="a091a63384590fe2cf7a122155b30011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091a63384590fe2cf7a122155b30011a">&#9670;&#160;</a></span>iterator_wrapper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static iteration_proxy&lt; <a class="el" href="classbasic__json.html#a2935c91b82c8e586b1dd68ad665075a6">iterator</a> &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::iterator_wrapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrapper to access iterator member functions in range-based for </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/items/">https://json.nlohmann.me/api/basic_json/items/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is deprecated since 3.1.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#a164b219291271e36e427d6b9c9916fec">items()</a> instead; that is, replace <code>json::iterator_wrapper(j)</code> with <code>j.items()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22033">22033</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22034</span>    {</div>
<div class="line"><span class="lineno">22035</span>        <span class="keywordflow">return</span> ref.items();</div>
<div class="line"><span class="lineno">22036</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d46cece4c9f4700e4d6ac9565bde067" name="a6d46cece4c9f4700e4d6ac9565bde067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d46cece4c9f4700e4d6ac9565bde067">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the maximum possible number of elements </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/max_size/">https://json.nlohmann.me/api/basic_json/max_size/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22153">22153</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22154</span>    {</div>
<div class="line"><span class="lineno">22155</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">22156</span>        {</div>
<div class="line"><span class="lineno">22157</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">22158</span>            {</div>
<div class="line"><span class="lineno">22159</span>                <span class="comment">// delegate call to array_t::max_size()</span></div>
<div class="line"><span class="lineno">22160</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;max_size();</div>
<div class="line"><span class="lineno">22161</span>            }</div>
<div class="line"><span class="lineno">22162</span> </div>
<div class="line"><span class="lineno">22163</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">22164</span>            {</div>
<div class="line"><span class="lineno">22165</span>                <span class="comment">// delegate call to object_t::max_size()</span></div>
<div class="line"><span class="lineno">22166</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;max_size();</div>
<div class="line"><span class="lineno">22167</span>            }</div>
<div class="line"><span class="lineno">22168</span> </div>
<div class="line"><span class="lineno">22169</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">22170</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">22171</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">22172</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">22173</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">22174</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">22175</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">22176</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">22177</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">22178</span>            {</div>
<div class="line"><span class="lineno">22179</span>                <span class="comment">// all other types have max_size() == size()</span></div>
<div class="line"><span class="lineno">22180</span>                <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>();</div>
<div class="line"><span class="lineno">22181</span>            }</div>
<div class="line"><span class="lineno">22182</span>        }</div>
<div class="line"><span class="lineno">22183</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c7ab88eb6d043b434cd9e0b68ec7321" name="a1c7ab88eb6d043b434cd9e0b68ec7321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ab88eb6d043b434cd9e0b68ec7321">&#9670;&#160;</a></span>merge_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::merge_patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>apply_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON Merge Patch </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/merge_patch/">https://json.nlohmann.me/api/basic_json/merge_patch/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24269">24269</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">24270</span>    {</div>
<div class="line"><span class="lineno">24271</span>        <span class="keywordflow">if</span> (apply_patch.<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">24272</span>        {</div>
<div class="line"><span class="lineno">24273</span>            <span class="keywordflow">if</span> (!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">24274</span>            {</div>
<div class="line"><span class="lineno">24275</span>                *<span class="keyword">this</span> = <a class="code hl_function" href="classbasic__json.html#a10aa3ec9e58f6852709913408519c01c">object</a>();</div>
<div class="line"><span class="lineno">24276</span>            }</div>
<div class="line"><span class="lineno">24277</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = apply_patch.<a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>(); it != apply_patch.<a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>(); ++it)</div>
<div class="line"><span class="lineno">24278</span>            {</div>
<div class="line"><span class="lineno">24279</span>                <span class="keywordflow">if</span> (it.value().is_null())</div>
<div class="line"><span class="lineno">24280</span>                {</div>
<div class="line"><span class="lineno">24281</span>                    <a class="code hl_function" href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">erase</a>(it.key());</div>
<div class="line"><span class="lineno">24282</span>                }</div>
<div class="line"><span class="lineno">24283</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">24284</span>                {</div>
<div class="line"><span class="lineno">24285</span>                    <a class="code hl_function" href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">operator[]</a>(it.key()).<a class="code hl_function" href="classbasic__json.html#a1c7ab88eb6d043b434cd9e0b68ec7321">merge_patch</a>(it.value());</div>
<div class="line"><span class="lineno">24286</span>                }</div>
<div class="line"><span class="lineno">24287</span>            }</div>
<div class="line"><span class="lineno">24288</span>        }</div>
<div class="line"><span class="lineno">24289</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">24290</span>        {</div>
<div class="line"><span class="lineno">24291</span>            *<span class="keyword">this</span> = apply_patch;</div>
<div class="line"><span class="lineno">24292</span>        }</div>
<div class="line"><span class="lineno">24293</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a1c7ab88eb6d043b434cd9e0b68ec7321"><div class="ttname"><a href="classbasic__json.html#a1c7ab88eb6d043b434cd9e0b68ec7321">basic_json::merge_patch</a></div><div class="ttdeci">void merge_patch(const basic_json &amp;apply_patch)</div><div class="ttdoc">applies a JSON Merge Patch</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l24269">json.hpp:24269</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a7a5ed019983b582705ef5ee43d15ca24"><div class="ttname"><a href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">basic_json::erase</a></div><div class="ttdeci">IteratorType erase(IteratorType pos)</div><div class="ttdoc">remove element given an iterator</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21595">json.hpp:21595</a></div></div>
<div class="ttc" id="aclassbasic__json_html_aa3dfeae16fa9a8ec1390a27d6a4a58b3"><div class="ttname"><a href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">basic_json::operator[]</a></div><div class="ttdeci">reference operator[](size_type idx)</div><div class="ttdoc">access specified array element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21226">json.hpp:21226</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a08303da85f75965764bb0c8d8b79a449" name="a08303da85f75965764bb0c8d8b79a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08303da85f75965764bb0c8d8b79a449">&#9670;&#160;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns version information on the library </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/meta/">https://json.nlohmann.me/api/basic_json/meta/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19424">19424</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">19425</span>    {</div>
<div class="line"><span class="lineno">19426</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result;</div>
<div class="line"><span class="lineno">19427</span> </div>
<div class="line"><span class="lineno">19428</span>        result[<span class="stringliteral">&quot;copyright&quot;</span>] = <span class="stringliteral">&quot;(C) 2013-2022 Niels Lohmann&quot;</span>;</div>
<div class="line"><span class="lineno">19429</span>        result[<span class="stringliteral">&quot;name&quot;</span>] = <span class="stringliteral">&quot;JSON for Modern C++&quot;</span>;</div>
<div class="line"><span class="lineno">19430</span>        result[<span class="stringliteral">&quot;url&quot;</span>] = <span class="stringliteral">&quot;https://github.com/nlohmann/json&quot;</span>;</div>
<div class="line"><span class="lineno">19431</span>        result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;string&quot;</span>] =</div>
<div class="line"><span class="lineno">19432</span>            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), <span class="charliteral">&#39;.&#39;</span>,</div>
<div class="line"><span class="lineno">19433</span>                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), <span class="charliteral">&#39;.&#39;</span>,</div>
<div class="line"><span class="lineno">19434</span>                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));</div>
<div class="line"><span class="lineno">19435</span>        result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;major&quot;</span>] = NLOHMANN_JSON_VERSION_MAJOR;</div>
<div class="line"><span class="lineno">19436</span>        result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;minor&quot;</span>] = NLOHMANN_JSON_VERSION_MINOR;</div>
<div class="line"><span class="lineno">19437</span>        result[<span class="stringliteral">&quot;version&quot;</span>][<span class="stringliteral">&quot;patch&quot;</span>] = NLOHMANN_JSON_VERSION_PATCH;</div>
<div class="line"><span class="lineno">19438</span> </div>
<div class="line"><span class="lineno">19439</span><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="lineno">19440</span>        result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;win32&quot;</span>;</div>
<div class="line"><span class="lineno">19441</span><span class="preprocessor">#elif defined __linux__</span></div>
<div class="line"><span class="lineno">19442</span>        result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;linux&quot;</span>;</div>
<div class="line"><span class="lineno">19443</span><span class="preprocessor">#elif defined __APPLE__</span></div>
<div class="line"><span class="lineno">19444</span>        result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;apple&quot;</span>;</div>
<div class="line"><span class="lineno">19445</span><span class="preprocessor">#elif defined __unix__</span></div>
<div class="line"><span class="lineno">19446</span>        result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;unix&quot;</span>;</div>
<div class="line"><span class="lineno">19447</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">19448</span>        result[<span class="stringliteral">&quot;platform&quot;</span>] = <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line"><span class="lineno">19449</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">19450</span> </div>
<div class="line"><span class="lineno">19451</span><span class="preprocessor">#if defined(__ICC) || defined(__INTEL_COMPILER)</span></div>
<div class="line"><span class="lineno">19452</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;icc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __INTEL_COMPILER}};</div>
<div class="line"><span class="lineno">19453</span><span class="preprocessor">#elif defined(__clang__)</span></div>
<div class="line"><span class="lineno">19454</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;clang&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __clang_version__}};</div>
<div class="line"><span class="lineno">19455</span><span class="preprocessor">#elif defined(__GNUC__) || defined(__GNUG__)</span></div>
<div class="line"><span class="lineno">19456</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;gcc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, detail::concat(</div>
<div class="line"><span class="lineno">19457</span>                    std::to_string(__GNUC__), <span class="charliteral">&#39;.&#39;</span>,</div>
<div class="line"><span class="lineno">19458</span>                    std::to_string(__GNUC_MINOR__), <span class="charliteral">&#39;.&#39;</span>,</div>
<div class="line"><span class="lineno">19459</span>                    std::to_string(__GNUC_PATCHLEVEL__))</div>
<div class="line"><span class="lineno">19460</span>            }</div>
<div class="line"><span class="lineno">19461</span>        };</div>
<div class="line"><span class="lineno">19462</span><span class="preprocessor">#elif defined(__HP_cc) || defined(__HP_aCC)</span></div>
<div class="line"><span class="lineno">19463</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = <span class="stringliteral">&quot;hp&quot;</span></div>
<div class="line"><span class="lineno">19464</span><span class="preprocessor">#elif defined(__IBMCPP__)</span></div>
<div class="line"><span class="lineno">19465</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;ilecpp&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __IBMCPP__}};</div>
<div class="line"><span class="lineno">19466</span><span class="preprocessor">#elif defined(_MSC_VER)</span></div>
<div class="line"><span class="lineno">19467</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;msvc&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, _MSC_VER}};</div>
<div class="line"><span class="lineno">19468</span><span class="preprocessor">#elif defined(__PGI)</span></div>
<div class="line"><span class="lineno">19469</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;pgcpp&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __PGI}};</div>
<div class="line"><span class="lineno">19470</span><span class="preprocessor">#elif defined(__SUNPRO_CC)</span></div>
<div class="line"><span class="lineno">19471</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;sunpro&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, __SUNPRO_CC}};</div>
<div class="line"><span class="lineno">19472</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">19473</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>] = {{<span class="stringliteral">&quot;family&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>}, {<span class="stringliteral">&quot;version&quot;</span>, <span class="stringliteral">&quot;unknown&quot;</span>}};</div>
<div class="line"><span class="lineno">19474</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">19475</span> </div>
<div class="line"><span class="lineno">19476</span> </div>
<div class="line"><span class="lineno">19477</span><span class="preprocessor">#if defined(_MSVC_LANG)</span></div>
<div class="line"><span class="lineno">19478</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>][<span class="stringliteral">&quot;c++&quot;</span>] = std::to_string(_MSVC_LANG);</div>
<div class="line"><span class="lineno">19479</span><span class="preprocessor">#elif defined(__cplusplus)</span></div>
<div class="line"><span class="lineno">19480</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>][<span class="stringliteral">&quot;c++&quot;</span>] = std::to_string(__cplusplus);</div>
<div class="line"><span class="lineno">19481</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">19482</span>        result[<span class="stringliteral">&quot;compiler&quot;</span>][<span class="stringliteral">&quot;c++&quot;</span>] = <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line"><span class="lineno">19483</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">19484</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">19485</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a10aa3ec9e58f6852709913408519c01c" name="a10aa3ec9e58f6852709913408519c01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa3ec9e58f6852709913408519c01c">&#9670;&#160;</a></span>object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static JSON_HEDLEY_WARN_UNUSED_RESULT <a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicitly create an object from an initializer list </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/object/">https://json.nlohmann.me/api/basic_json/object/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20178">20178</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20178</span>                                                       {})</div>
<div class="line"><span class="lineno">20179</span>    {</div>
<div class="line"><span class="lineno">20180</span>        <span class="keywordflow">return</span> <a class="code hl_class" href="classbasic__json.html">basic_json</a>(init, <span class="keyword">false</span>, value_t::object);</div>
<div class="line"><span class="lineno">20181</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab025e8b5ac852c84758f92183b569b99" name="ab025e8b5ac852c84758f92183b569b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab025e8b5ac852c84758f92183b569b99">&#9670;&#160;</a></span>operator value_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (implicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_value_t/">https://json.nlohmann.me/api/basic_json/operator_value_t/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20557">20557</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20558</span>    {</div>
<div class="line"><span class="lineno">20559</span>        <span class="keywordflow">return</span> m_type;</div>
<div class="line"><span class="lineno">20560</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31ccb49215a3dcac15438fb94485e86f" name="a31ccb49215a3dcac15438fb94485e86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ccb49215a3dcac15438fb94485e86f">&#9670;&#160;</a></span>operator ValueType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename std::enable_if&lt; <a class="el" href="structdetail_1_1conjunction.html">detail::conjunction</a>&lt; <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_pointer&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::nullptr_t &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, <a class="el" href="classdetail_1_1json__ref.html">detail::json_ref</a>&lt; <a class="el" href="classbasic__json.html">basic_json</a> &gt; &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, typename string_t::value_type &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; ValueType &gt; &gt;, <a class="el" href="structdetail_1_1negation.html">detail::negation</a>&lt; std::is_same&lt; ValueType, std::initializer_list&lt; typename string_t::value_type &gt; &gt; &gt;, <a class="el" href="structdetail_1_1is__detected__lazy.html">detail::is_detected_lazy</a>&lt; detail::get_template_function, const basic_json_t &amp;, ValueType &gt; &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;<a class="el" href="classbasic__json.html#a1338e4eef7282cd57a4a57e034531029">::type</a>  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSON_EXPLICIT <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator ValueType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a value (implicit) </p>
<p>Implicit type conversion between the JSON value and a compatible value. The call is realized by calling <a class="el" href="classbasic__json.html#ab11bff397526e8255d151066caeba48e">get() const</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>non-pointer type compatible to the JSON value, for instance <code>int</code> for JSON integer numbers, <code>bool</code> for JSON booleans, or <code>std::vector</code> types for JSON arrays. The character type of <a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to <code>std::string</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the JSON value, converted to type <em>ValueType</em> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">type_error.302</td><td>in case passed type <em>ValueType</em> is incompatible to the JSON value type (e.g., the JSON value is of type boolean, but a string is requested); see example below</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity Linear in the size of the JSON value.</p>
<p>@liveexample{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\, (2) A JSON array can be converted to a standard <code>std::vector&lt;short&gt;</code>\, (3) A JSON object can be converted to C++ associative containers such as <code>std::unordered_map&lt;std::string\, json&gt;</code>.,operator__ValueType}</p>
<dl class="section since"><dt>Since</dt><dd>version 1.0.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21061">21061</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21062</span>    {</div>
<div class="line"><span class="lineno">21063</span>        <span class="comment">// delegate the call to get&lt;&gt;() const</span></div>
<div class="line"><span class="lineno">21064</span>        <span class="keywordflow">return</span> get&lt;ValueType&gt;();</div>
<div class="line"><span class="lineno">21065</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a042aa42f535d1dbf2176d159fd3d96eb" name="a042aa42f535d1dbf2176d159fd3d96eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042aa42f535d1dbf2176d159fd3d96eb">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22283">22283</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22284</span>    {</div>
<div class="line"><span class="lineno">22285</span>        <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(std::move(val));</div>
<div class="line"><span class="lineno">22286</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22287</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_ae9dd9991cbc1c10d35987680038f6359"><div class="ttname"><a href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">basic_json::push_back</a></div><div class="ttdeci">void push_back(basic_json &amp;&amp;val)</div><div class="ttdoc">add an object to an array</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22258">json.hpp:22258</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afbbf3e602301f1b9fc81c445c8f3bd1a" name="afbbf3e602301f1b9fc81c445c8f3bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbf3e602301f1b9fc81c445c8f3bd1a">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22315">22315</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22316</span>    {</div>
<div class="line"><span class="lineno">22317</span>        <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(val);</div>
<div class="line"><span class="lineno">22318</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22319</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a024a7d334069a60f8cb95c3f858fc9e6" name="a024a7d334069a60f8cb95c3f858fc9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024a7d334069a60f8cb95c3f858fc9e6">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22346">22346</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22347</span>    {</div>
<div class="line"><span class="lineno">22348</span>        <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(val);</div>
<div class="line"><span class="lineno">22349</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22350</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3350669b0628bf54a4771512a55f135" name="ae3350669b0628bf54a4771512a55f135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3350669b0628bf54a4771512a55f135">&#9670;&#160;</a></span>operator+=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator+=/">https://json.nlohmann.me/api/basic_json/operator+=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22370">22370</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22371</span>    {</div>
<div class="line"><span class="lineno">22372</span>        <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(init);</div>
<div class="line"><span class="lineno">22373</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22374</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cb70d0ea0c23ac40f1f3b67d40c174f" name="a8cb70d0ea0c23ac40f1f3b67d40c174f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb70d0ea0c23ac40f1f3b67d40c174f">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> &amp; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator=/">https://json.nlohmann.me/api/basic_json/operator=/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20397">20397</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20403</span>    {</div>
<div class="line"><span class="lineno">20404</span>        <span class="comment">// check that passed value is valid</span></div>
<div class="line"><span class="lineno">20405</span>        other.assert_invariant();</div>
<div class="line"><span class="lineno">20406</span> </div>
<div class="line"><span class="lineno">20407</span>        <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">20408</span>        <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(m_type, other.m_type);</div>
<div class="line"><span class="lineno">20409</span>        <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>, other.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>);</div>
<div class="line"><span class="lineno">20410</span> </div>
<div class="line"><span class="lineno">20411</span>        set_parents();</div>
<div class="line"><span class="lineno">20412</span>        assert_invariant();</div>
<div class="line"><span class="lineno">20413</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">20414</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aee0ae36cbfb0336832ebc0374c3c7679"><div class="ttname"><a href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">basic_json::swap</a></div><div class="ttdeci">friend void swap(reference left, reference right) noexcept(std::is_nothrow_move_constructible&lt; value_t &gt;::value &amp;&amp;std::is_nothrow_move_assignable&lt; value_t &gt;::value &amp;&amp;std::is_nothrow_move_constructible&lt; json_value &gt;::value &amp;&amp;std::is_nothrow_move_assignable&lt; json_value &gt;::value)</div><div class="ttdoc">exchanges the values</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22649">json.hpp:22649</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ca526e935364213525dd8e23397472c" name="a6ca526e935364213525dd8e23397472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca526e935364213525dd8e23397472c">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23772">23772</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23773</span>    {</div>
<div class="line"><span class="lineno">23774</span>        <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23775</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ed2a2a59c3437b4b57e4f0b03e4333a" name="a8ed2a2a59c3437b4b57e4f0b03e4333a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed2a2a59c3437b4b57e4f0b03e4333a">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23786">23786</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23787</span>    {</div>
<div class="line"><span class="lineno">23788</span>        <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23789</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f0b9af87d5c9c8bed6dc0e165af3147" name="a2f0b9af87d5c9c8bed6dc0e165af3147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0b9af87d5c9c8bed6dc0e165af3147">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23765">23765</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23766</span>    {</div>
<div class="line"><span class="lineno">23767</span>        <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23768</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ba36b6659d266fd0299446a20b611d9" name="a9ba36b6659d266fd0299446a20b611d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba36b6659d266fd0299446a20b611d9">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified element via JSON Pointer </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23779">23779</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23780</span>    {</div>
<div class="line"><span class="lineno">23781</span>        <span class="keywordflow">return</span> ptr.get_unchecked(<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23782</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af57b78559cad28275bc515bb2a072605" name="af57b78559cad28275bc515bb2a072605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57b78559cad28275bc515bb2a072605">&#9670;&#160;</a></span>operator[]() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21307">21307</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21308</span>    {</div>
<div class="line"><span class="lineno">21309</span>        <span class="comment">// const operator[] only works for objects</span></div>
<div class="line"><span class="lineno">21310</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21311</span>        {</div>
<div class="line"><span class="lineno">21312</span>            <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(key);</div>
<div class="line"><span class="lineno">21313</span>            JSON_ASSERT(it != <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end());</div>
<div class="line"><span class="lineno">21314</span>            <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><span class="lineno">21315</span>        }</div>
<div class="line"><span class="lineno">21316</span> </div>
<div class="line"><span class="lineno">21317</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21318</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a7e1bd642902ec90f118f00d48c024d" name="a5a7e1bd642902ec90f118f00d48c024d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7e1bd642902ec90f118f00d48c024d">&#9670;&#160;</a></span>operator[]() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21338">21338</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21339</span>    {</div>
<div class="line"><span class="lineno">21340</span>        <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><span class="lineno">21341</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">21342</span>        {</div>
<div class="line"><span class="lineno">21343</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">21344</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object = create&lt;object_t&gt;();</div>
<div class="line"><span class="lineno">21345</span>            assert_invariant();</div>
<div class="line"><span class="lineno">21346</span>        }</div>
<div class="line"><span class="lineno">21347</span> </div>
<div class="line"><span class="lineno">21348</span>        <span class="comment">// operator[] only works for objects</span></div>
<div class="line"><span class="lineno">21349</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21350</span>        {</div>
<div class="line"><span class="lineno">21351</span>            <span class="keyword">auto</span> result = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;emplace(std::forward&lt;KeyType&gt;(key), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">21352</span>            <span class="keywordflow">return</span> set_parent(result.first-&gt;second);</div>
<div class="line"><span class="lineno">21353</span>        }</div>
<div class="line"><span class="lineno">21354</span> </div>
<div class="line"><span class="lineno">21355</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21356</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afb04aaee2ee66a6c822aaad827123314" name="afb04aaee2ee66a6c822aaad827123314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb04aaee2ee66a6c822aaad827123314">&#9670;&#160;</a></span>operator[]() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KeyType , detail::enable_if_t&lt; detail::is_usable_as_basic_json_key_type&lt; basic_json_t, KeyType &gt;<a class="el" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">::value</a>, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21362">21362</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21363</span>    {</div>
<div class="line"><span class="lineno">21364</span>        <span class="comment">// const operator[] only works for objects</span></div>
<div class="line"><span class="lineno">21365</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21366</span>        {</div>
<div class="line"><span class="lineno">21367</span>            <span class="keyword">auto</span> it = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21368</span>            JSON_ASSERT(it != <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end());</div>
<div class="line"><span class="lineno">21369</span>            <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><span class="lineno">21370</span>        }</div>
<div class="line"><span class="lineno">21371</span> </div>
<div class="line"><span class="lineno">21372</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21373</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3dfeae16fa9a8ec1390a27d6a4a58b3" name="aa3dfeae16fa9a8ec1390a27d6a4a58b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dfeae16fa9a8ec1390a27d6a4a58b3">&#9670;&#160;</a></span>operator[]() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21226">21226</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21227</span>    {</div>
<div class="line"><span class="lineno">21228</span>        <span class="comment">// implicitly convert null value to an empty array</span></div>
<div class="line"><span class="lineno">21229</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">21230</span>        {</div>
<div class="line"><span class="lineno">21231</span>            m_type = value_t::array;</div>
<div class="line"><span class="lineno">21232</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array = create&lt;array_t&gt;();</div>
<div class="line"><span class="lineno">21233</span>            assert_invariant();</div>
<div class="line"><span class="lineno">21234</span>        }</div>
<div class="line"><span class="lineno">21235</span> </div>
<div class="line"><span class="lineno">21236</span>        <span class="comment">// operator[] only works for arrays</span></div>
<div class="line"><span class="lineno">21237</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">21238</span>        {</div>
<div class="line"><span class="lineno">21239</span>            <span class="comment">// fill up array with null values if given idx is outside range</span></div>
<div class="line"><span class="lineno">21240</span>            <span class="keywordflow">if</span> (idx &gt;= <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;size())</div>
<div class="line"><span class="lineno">21241</span>            {</div>
<div class="line"><span class="lineno">21242</span><span class="preprocessor">#if JSON_DIAGNOSTICS</span></div>
<div class="line"><span class="lineno">21243</span>                <span class="comment">// remember array size &amp; capacity before resizing</span></div>
<div class="line"><span class="lineno">21244</span>                <span class="keyword">const</span> <span class="keyword">auto</span> old_size = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;size();</div>
<div class="line"><span class="lineno">21245</span>                <span class="keyword">const</span> <span class="keyword">auto</span> old_capacity = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;capacity();</div>
<div class="line"><span class="lineno">21246</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">21247</span>                <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;resize(idx + 1);</div>
<div class="line"><span class="lineno">21248</span> </div>
<div class="line"><span class="lineno">21249</span><span class="preprocessor">#if JSON_DIAGNOSTICS</span></div>
<div class="line"><span class="lineno">21250</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;capacity() != old_capacity))</div>
<div class="line"><span class="lineno">21251</span>                {</div>
<div class="line"><span class="lineno">21252</span>                    <span class="comment">// capacity has changed: update all parents</span></div>
<div class="line"><span class="lineno">21253</span>                    set_parents();</div>
<div class="line"><span class="lineno">21254</span>                }</div>
<div class="line"><span class="lineno">21255</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">21256</span>                {</div>
<div class="line"><span class="lineno">21257</span>                    <span class="comment">// set parent for values added above</span></div>
<div class="line"><span class="lineno">21258</span>                    set_parents(<a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>() + <span class="keyword">static_cast&lt;</span>typename iterator::difference_type<span class="keyword">&gt;</span>(old_size), <span class="keyword">static_cast&lt;</span>typename iterator::difference_type<span class="keyword">&gt;</span>(idx + 1 - old_size));</div>
<div class="line"><span class="lineno">21259</span>                }</div>
<div class="line"><span class="lineno">21260</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">21261</span>                assert_invariant();</div>
<div class="line"><span class="lineno">21262</span>            }</div>
<div class="line"><span class="lineno">21263</span> </div>
<div class="line"><span class="lineno">21264</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;operator[](idx);</div>
<div class="line"><span class="lineno">21265</span>        }</div>
<div class="line"><span class="lineno">21266</span> </div>
<div class="line"><span class="lineno">21267</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a numeric argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21268</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a61677841384622af7c3174f3f10df621" name="a61677841384622af7c3174f3f10df621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61677841384622af7c3174f3f10df621">&#9670;&#160;</a></span>operator[]() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified array element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21272">21272</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21273</span>    {</div>
<div class="line"><span class="lineno">21274</span>        <span class="comment">// const operator[] only works for arrays</span></div>
<div class="line"><span class="lineno">21275</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">21276</span>        {</div>
<div class="line"><span class="lineno">21277</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;operator[](idx);</div>
<div class="line"><span class="lineno">21278</span>        }</div>
<div class="line"><span class="lineno">21279</span> </div>
<div class="line"><span class="lineno">21280</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a numeric argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21281</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb748eeb63f40f12f81f9e9c5d53d127" name="abb748eeb63f40f12f81f9e9c5d53d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb748eeb63f40f12f81f9e9c5d53d127">&#9670;&#160;</a></span>operator[]() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21323">21323</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21324</span>    {</div>
<div class="line"><span class="lineno">21325</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">operator[]</a>(<span class="keyword">typename</span> object_t::key_type(key));</div>
<div class="line"><span class="lineno">21326</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19e43d3f7092719836ac3e8249044bb6" name="a19e43d3f7092719836ac3e8249044bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e43d3f7092719836ac3e8249044bb6">&#9670;&#160;</a></span>operator[]() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21329">21329</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21330</span>    {</div>
<div class="line"><span class="lineno">21331</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#aa3dfeae16fa9a8ec1390a27d6a4a58b3">operator[]</a>(<span class="keyword">typename</span> object_t::key_type(key));</div>
<div class="line"><span class="lineno">21332</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a272177c4eb206c70f41e35146915b710" name="a272177c4eb206c70f41e35146915b710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272177c4eb206c70f41e35146915b710">&#9670;&#160;</a></span>operator[]() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">typename object_t::key_type&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator%5B%5D/">https://json.nlohmann.me/api/basic_json/operator%5B%5D/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21285">21285</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21286</span>    {</div>
<div class="line"><span class="lineno">21287</span>        <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><span class="lineno">21288</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">21289</span>        {</div>
<div class="line"><span class="lineno">21290</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">21291</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object = create&lt;object_t&gt;();</div>
<div class="line"><span class="lineno">21292</span>            assert_invariant();</div>
<div class="line"><span class="lineno">21293</span>        }</div>
<div class="line"><span class="lineno">21294</span> </div>
<div class="line"><span class="lineno">21295</span>        <span class="comment">// operator[] only works for objects</span></div>
<div class="line"><span class="lineno">21296</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21297</span>        {</div>
<div class="line"><span class="lineno">21298</span>            <span class="keyword">auto</span> result = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;emplace(std::move(key), <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">21299</span>            <span class="keywordflow">return</span> set_parent(result.first-&gt;second);</div>
<div class="line"><span class="lineno">21300</span>        }</div>
<div class="line"><span class="lineno">21301</span> </div>
<div class="line"><span class="lineno">21302</span>        JSON_THROW(type_error::create(305, detail::concat(<span class="stringliteral">&quot;cannot use operator[] with a string argument with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21303</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a009b55b9dcdb30352f5f62537931b7" name="a5a009b55b9dcdb30352f5f62537931b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a009b55b9dcdb30352f5f62537931b7">&#9670;&#160;</a></span>patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::patch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON patch to a copy of the current object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/patch/">https://json.nlohmann.me/api/basic_json/patch/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l24117">24117</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">24118</span>    {</div>
<div class="line"><span class="lineno">24119</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a> result = *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">24120</span>        result.<a class="code hl_function" href="classbasic__json.html#adc2ae40925906c7e1d559b8bf12028a7">patch_inplace</a>(json_patch);</div>
<div class="line"><span class="lineno">24121</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">24122</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_adc2ae40925906c7e1d559b8bf12028a7"><div class="ttname"><a href="classbasic__json.html#adc2ae40925906c7e1d559b8bf12028a7">basic_json::patch_inplace</a></div><div class="ttdeci">void patch_inplace(const basic_json &amp;json_patch)</div><div class="ttdoc">applies a JSON patch in-place without copying the object</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23846">json.hpp:23846</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adc2ae40925906c7e1d559b8bf12028a7" name="adc2ae40925906c7e1d559b8bf12028a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2ae40925906c7e1d559b8bf12028a7">&#9670;&#160;</a></span>patch_inplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::patch_inplace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>json_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies a JSON patch in-place without copying the object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/patch/">https://json.nlohmann.me/api/basic_json/patch/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23846">23846</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23847</span>    {</div>
<div class="line"><span class="lineno">23848</span>        <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp; result = *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">23849</span>        <span class="comment">// the valid JSON Patch operations</span></div>
<div class="line"><span class="lineno">23850</span>        <span class="keyword">enum class</span> patch_operations {add, remove, <a class="code hl_enumvalue" href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c">replace</a>, move, copy, test, invalid};</div>
<div class="line"><span class="lineno">23851</span> </div>
<div class="line"><span class="lineno">23852</span>        <span class="keyword">const</span> <span class="keyword">auto</span> get_op = [](<span class="keyword">const</span> std::string &amp; op)</div>
<div class="line"><span class="lineno">23853</span>        {</div>
<div class="line"><span class="lineno">23854</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;add&quot;</span>)</div>
<div class="line"><span class="lineno">23855</span>            {</div>
<div class="line"><span class="lineno">23856</span>                <span class="keywordflow">return</span> patch_operations::add;</div>
<div class="line"><span class="lineno">23857</span>            }</div>
<div class="line"><span class="lineno">23858</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;remove&quot;</span>)</div>
<div class="line"><span class="lineno">23859</span>            {</div>
<div class="line"><span class="lineno">23860</span>                <span class="keywordflow">return</span> patch_operations::remove;</div>
<div class="line"><span class="lineno">23861</span>            }</div>
<div class="line"><span class="lineno">23862</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;replace&quot;</span>)</div>
<div class="line"><span class="lineno">23863</span>            {</div>
<div class="line"><span class="lineno">23864</span>                <span class="keywordflow">return</span> patch_operations::replace;</div>
<div class="line"><span class="lineno">23865</span>            }</div>
<div class="line"><span class="lineno">23866</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;move&quot;</span>)</div>
<div class="line"><span class="lineno">23867</span>            {</div>
<div class="line"><span class="lineno">23868</span>                <span class="keywordflow">return</span> patch_operations::move;</div>
<div class="line"><span class="lineno">23869</span>            }</div>
<div class="line"><span class="lineno">23870</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;copy&quot;</span>)</div>
<div class="line"><span class="lineno">23871</span>            {</div>
<div class="line"><span class="lineno">23872</span>                <span class="keywordflow">return</span> patch_operations::copy;</div>
<div class="line"><span class="lineno">23873</span>            }</div>
<div class="line"><span class="lineno">23874</span>            <span class="keywordflow">if</span> (op == <span class="stringliteral">&quot;test&quot;</span>)</div>
<div class="line"><span class="lineno">23875</span>            {</div>
<div class="line"><span class="lineno">23876</span>                <span class="keywordflow">return</span> patch_operations::test;</div>
<div class="line"><span class="lineno">23877</span>            }</div>
<div class="line"><span class="lineno">23878</span> </div>
<div class="line"><span class="lineno">23879</span>            <span class="keywordflow">return</span> patch_operations::invalid;</div>
<div class="line"><span class="lineno">23880</span>        };</div>
<div class="line"><span class="lineno">23881</span> </div>
<div class="line"><span class="lineno">23882</span>        <span class="comment">// wrapper for &quot;add&quot; operation; add value at ptr</span></div>
<div class="line"><span class="lineno">23883</span>        <span class="keyword">const</span> <span class="keyword">auto</span> operation_add = [&amp;result](<a class="code hl_class" href="classjson__pointer.html">json_pointer</a> &amp; ptr, <a class="code hl_class" href="classbasic__json.html">basic_json</a> val)</div>
<div class="line"><span class="lineno">23884</span>        {</div>
<div class="line"><span class="lineno">23885</span>            <span class="comment">// adding to the root of the target document means replacing it</span></div>
<div class="line"><span class="lineno">23886</span>            <span class="keywordflow">if</span> (ptr.<a class="code hl_function" href="classjson__pointer.html#a5c3d08bd0a0e99c3377db33600c68a64">empty</a>())</div>
<div class="line"><span class="lineno">23887</span>            {</div>
<div class="line"><span class="lineno">23888</span>                result = val;</div>
<div class="line"><span class="lineno">23889</span>                <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">23890</span>            }</div>
<div class="line"><span class="lineno">23891</span> </div>
<div class="line"><span class="lineno">23892</span>            <span class="comment">// make sure the top element of the pointer exists</span></div>
<div class="line"><span class="lineno">23893</span>            <a class="code hl_class" href="classjson__pointer.html">json_pointer</a> top_pointer = ptr.top();</div>
<div class="line"><span class="lineno">23894</span>            <span class="keywordflow">if</span> (top_pointer != ptr)</div>
<div class="line"><span class="lineno">23895</span>            {</div>
<div class="line"><span class="lineno">23896</span>                result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(top_pointer);</div>
<div class="line"><span class="lineno">23897</span>            }</div>
<div class="line"><span class="lineno">23898</span> </div>
<div class="line"><span class="lineno">23899</span>            <span class="comment">// get reference to parent of JSON pointer ptr</span></div>
<div class="line"><span class="lineno">23900</span>            <span class="keyword">const</span> <span class="keyword">auto</span> last_path = ptr.<a class="code hl_function" href="classjson__pointer.html#aba71e63e4032cfc46dd90aeb09e5cb0f">back</a>();</div>
<div class="line"><span class="lineno">23901</span>            ptr.<a class="code hl_function" href="classjson__pointer.html#a662118b470c87a1b564946c2602c49ce">pop_back</a>();</div>
<div class="line"><span class="lineno">23902</span>            <span class="comment">// parent must exist when performing patch add per RFC6902 specs</span></div>
<div class="line"><span class="lineno">23903</span>            <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp; parent = result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(ptr);</div>
<div class="line"><span class="lineno">23904</span> </div>
<div class="line"><span class="lineno">23905</span>            <span class="keywordflow">switch</span> (parent.m_type)</div>
<div class="line"><span class="lineno">23906</span>            {</div>
<div class="line"><span class="lineno">23907</span>                <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">23908</span>                <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">23909</span>                {</div>
<div class="line"><span class="lineno">23910</span>                    <span class="comment">// use operator[] to add value</span></div>
<div class="line"><span class="lineno">23911</span>                    parent[last_path] = val;</div>
<div class="line"><span class="lineno">23912</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">23913</span>                }</div>
<div class="line"><span class="lineno">23914</span> </div>
<div class="line"><span class="lineno">23915</span>                <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">23916</span>                {</div>
<div class="line"><span class="lineno">23917</span>                    <span class="keywordflow">if</span> (last_path == <span class="stringliteral">&quot;-&quot;</span>)</div>
<div class="line"><span class="lineno">23918</span>                    {</div>
<div class="line"><span class="lineno">23919</span>                        <span class="comment">// special case: append to back</span></div>
<div class="line"><span class="lineno">23920</span>                        parent.<a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(val);</div>
<div class="line"><span class="lineno">23921</span>                    }</div>
<div class="line"><span class="lineno">23922</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">23923</span>                    {</div>
<div class="line"><span class="lineno">23924</span>                        <span class="keyword">const</span> <span class="keyword">auto</span> idx = json_pointer::template array_index&lt;basic_json_t&gt;(last_path);</div>
<div class="line"><span class="lineno">23925</span>                        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(idx &gt; parent.<a class="code hl_function" href="classbasic__json.html#a769537e4631ccd39b5ab3753547a8274">size</a>()))</div>
<div class="line"><span class="lineno">23926</span>                        {</div>
<div class="line"><span class="lineno">23927</span>                            <span class="comment">// avoid undefined behavior</span></div>
<div class="line"><span class="lineno">23928</span>                            JSON_THROW(out_of_range::create(401, detail::concat(<span class="stringliteral">&quot;array index &quot;</span>, std::to_string(idx), <span class="stringliteral">&quot; is out of range&quot;</span>), &amp;parent));</div>
<div class="line"><span class="lineno">23929</span>                        }</div>
<div class="line"><span class="lineno">23930</span> </div>
<div class="line"><span class="lineno">23931</span>                        <span class="comment">// default case: insert add offset</span></div>
<div class="line"><span class="lineno">23932</span>                        parent.<a class="code hl_function" href="classbasic__json.html#a4467ec0c7679150140f9d2f85e95bf4b">insert</a>(parent.<a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>() + <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="classbasic__json.html#a2fe32d636c1b78861884dde9716b22b6">difference_type</a><span class="keyword">&gt;</span>(idx), val);</div>
<div class="line"><span class="lineno">23933</span>                    }</div>
<div class="line"><span class="lineno">23934</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">23935</span>                }</div>
<div class="line"><span class="lineno">23936</span> </div>
<div class="line"><span class="lineno">23937</span>                <span class="comment">// if there exists a parent it cannot be primitive</span></div>
<div class="line"><span class="lineno">23938</span>                <span class="keywordflow">case</span> value_t::string: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23939</span>                <span class="keywordflow">case</span> value_t::boolean: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23940</span>                <span class="keywordflow">case</span> value_t::number_integer: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23941</span>                <span class="keywordflow">case</span> value_t::number_unsigned: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23942</span>                <span class="keywordflow">case</span> value_t::number_float: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23943</span>                <span class="keywordflow">case</span> value_t::binary: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23944</span>                <span class="keywordflow">case</span> value_t::discarded: <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23945</span>                <span class="keywordflow">default</span>:            <span class="comment">// LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23946</span>                    JSON_ASSERT(<span class="keyword">false</span>); <span class="comment">// NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE</span></div>
<div class="line"><span class="lineno">23947</span>            }</div>
<div class="line"><span class="lineno">23948</span>        };</div>
<div class="line"><span class="lineno">23949</span> </div>
<div class="line"><span class="lineno">23950</span>        <span class="comment">// wrapper for &quot;remove&quot; operation; remove value at ptr</span></div>
<div class="line"><span class="lineno">23951</span>        <span class="keyword">const</span> <span class="keyword">auto</span> operation_remove = [<span class="keyword">this</span>, &amp;result](<a class="code hl_class" href="classjson__pointer.html">json_pointer</a> &amp; ptr)</div>
<div class="line"><span class="lineno">23952</span>        {</div>
<div class="line"><span class="lineno">23953</span>            <span class="comment">// get reference to parent of JSON pointer ptr</span></div>
<div class="line"><span class="lineno">23954</span>            <span class="keyword">const</span> <span class="keyword">auto</span> last_path = ptr.<a class="code hl_function" href="classjson__pointer.html#aba71e63e4032cfc46dd90aeb09e5cb0f">back</a>();</div>
<div class="line"><span class="lineno">23955</span>            ptr.<a class="code hl_function" href="classjson__pointer.html#a662118b470c87a1b564946c2602c49ce">pop_back</a>();</div>
<div class="line"><span class="lineno">23956</span>            <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp; parent = result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(ptr);</div>
<div class="line"><span class="lineno">23957</span> </div>
<div class="line"><span class="lineno">23958</span>            <span class="comment">// remove child</span></div>
<div class="line"><span class="lineno">23959</span>            <span class="keywordflow">if</span> (parent.<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())</div>
<div class="line"><span class="lineno">23960</span>            {</div>
<div class="line"><span class="lineno">23961</span>                <span class="comment">// perform range check</span></div>
<div class="line"><span class="lineno">23962</span>                <span class="keyword">auto</span> it = parent.<a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(last_path);</div>
<div class="line"><span class="lineno">23963</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(it != parent.<a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>()))</div>
<div class="line"><span class="lineno">23964</span>                {</div>
<div class="line"><span class="lineno">23965</span>                    parent.<a class="code hl_function" href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">erase</a>(it);</div>
<div class="line"><span class="lineno">23966</span>                }</div>
<div class="line"><span class="lineno">23967</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">23968</span>                {</div>
<div class="line"><span class="lineno">23969</span>                    JSON_THROW(out_of_range::create(403, detail::concat(<span class="stringliteral">&quot;key &#39;&quot;</span>, last_path, <span class="stringliteral">&quot;&#39; not found&quot;</span>), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">23970</span>                }</div>
<div class="line"><span class="lineno">23971</span>            }</div>
<div class="line"><span class="lineno">23972</span>            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent.<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>())</div>
<div class="line"><span class="lineno">23973</span>            {</div>
<div class="line"><span class="lineno">23974</span>                <span class="comment">// note erase performs range check</span></div>
<div class="line"><span class="lineno">23975</span>                parent.<a class="code hl_function" href="classbasic__json.html#a7a5ed019983b582705ef5ee43d15ca24">erase</a>(json_pointer::template array_index&lt;basic_json_t&gt;(last_path));</div>
<div class="line"><span class="lineno">23976</span>            }</div>
<div class="line"><span class="lineno">23977</span>        };</div>
<div class="line"><span class="lineno">23978</span> </div>
<div class="line"><span class="lineno">23979</span>        <span class="comment">// type check: top level value must be an array</span></div>
<div class="line"><span class="lineno">23980</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!json_patch.<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">23981</span>        {</div>
<div class="line"><span class="lineno">23982</span>            JSON_THROW(<a class="code hl_function" href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">parse_error::create</a>(104, 0, <span class="stringliteral">&quot;JSON patch must be an array of objects&quot;</span>, &amp;json_patch));</div>
<div class="line"><span class="lineno">23983</span>        }</div>
<div class="line"><span class="lineno">23984</span> </div>
<div class="line"><span class="lineno">23985</span>        <span class="comment">// iterate and apply the operations</span></div>
<div class="line"><span class="lineno">23986</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val : json_patch)</div>
<div class="line"><span class="lineno">23987</span>        {</div>
<div class="line"><span class="lineno">23988</span>            <span class="comment">// wrapper to get a value for an operation</span></div>
<div class="line"><span class="lineno">23989</span>            <span class="keyword">const</span> <span class="keyword">auto</span> get_value = [&amp;val](<span class="keyword">const</span> std::string &amp; op,</div>
<div class="line"><span class="lineno">23990</span>                                          <span class="keyword">const</span> std::string &amp; member,</div>
<div class="line"><span class="lineno">23991</span>                                          <span class="keywordtype">bool</span> string_type) -&gt; <a class="code hl_class" href="classbasic__json.html">basic_json</a> &amp;</div>
<div class="line"><span class="lineno">23992</span>            {</div>
<div class="line"><span class="lineno">23993</span>                <span class="comment">// find value</span></div>
<div class="line"><span class="lineno">23994</span>                <span class="keyword">auto</span> it = val.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(member);</div>
<div class="line"><span class="lineno">23995</span> </div>
<div class="line"><span class="lineno">23996</span>                <span class="comment">// context-sensitive error message</span></div>
<div class="line"><span class="lineno">23997</span>                <span class="keyword">const</span> <span class="keyword">auto</span> error_msg = (op == <span class="stringliteral">&quot;op&quot;</span>) ? <span class="stringliteral">&quot;operation&quot;</span> : <a class="code hl_namespace" href="namespacedetail.html">detail</a>::concat(<span class="stringliteral">&quot;operation &#39;&quot;</span>, op, <span class="stringliteral">&#39;\&#39;&#39;</span>);</div>
<div class="line"><span class="lineno">23998</span> </div>
<div class="line"><span class="lineno">23999</span>                <span class="comment">// check if desired value is present</span></div>
<div class="line"><span class="lineno">24000</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(it == val.m_value.object-&gt;end()))</div>
<div class="line"><span class="lineno">24001</span>                {</div>
<div class="line"><span class="lineno">24002</span>                    <span class="comment">// NOLINTNEXTLINE(performance-inefficient-string-concatenation)</span></div>
<div class="line"><span class="lineno">24003</span>                    JSON_THROW(<a class="code hl_function" href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">parse_error::create</a>(105, 0, detail::concat(error_msg, <span class="stringliteral">&quot; must have member &#39;&quot;</span>, member, <span class="stringliteral">&quot;&#39;&quot;</span>), &amp;val));</div>
<div class="line"><span class="lineno">24004</span>                }</div>
<div class="line"><span class="lineno">24005</span> </div>
<div class="line"><span class="lineno">24006</span>                <span class="comment">// check if result is of type string</span></div>
<div class="line"><span class="lineno">24007</span>                <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(string_type &amp;&amp; !it-&gt;second.is_string()))</div>
<div class="line"><span class="lineno">24008</span>                {</div>
<div class="line"><span class="lineno">24009</span>                    <span class="comment">// NOLINTNEXTLINE(performance-inefficient-string-concatenation)</span></div>
<div class="line"><span class="lineno">24010</span>                    JSON_THROW(<a class="code hl_function" href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">parse_error::create</a>(105, 0, detail::concat(error_msg, <span class="stringliteral">&quot; must have string member &#39;&quot;</span>, member, <span class="stringliteral">&quot;&#39;&quot;</span>), &amp;val));</div>
<div class="line"><span class="lineno">24011</span>                }</div>
<div class="line"><span class="lineno">24012</span> </div>
<div class="line"><span class="lineno">24013</span>                <span class="comment">// no error: return value</span></div>
<div class="line"><span class="lineno">24014</span>                <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"><span class="lineno">24015</span>            };</div>
<div class="line"><span class="lineno">24016</span> </div>
<div class="line"><span class="lineno">24017</span>            <span class="comment">// type check: every element of the array must be an object</span></div>
<div class="line"><span class="lineno">24018</span>            <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!val.is_object()))</div>
<div class="line"><span class="lineno">24019</span>            {</div>
<div class="line"><span class="lineno">24020</span>                JSON_THROW(<a class="code hl_function" href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">parse_error::create</a>(104, 0, <span class="stringliteral">&quot;JSON patch must be an array of objects&quot;</span>, &amp;val));</div>
<div class="line"><span class="lineno">24021</span>            }</div>
<div class="line"><span class="lineno">24022</span> </div>
<div class="line"><span class="lineno">24023</span>            <span class="comment">// collect mandatory members</span></div>
<div class="line"><span class="lineno">24024</span>            <span class="keyword">const</span> <span class="keyword">auto</span> op = get_value(<span class="stringliteral">&quot;op&quot;</span>, <span class="stringliteral">&quot;op&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><span class="lineno">24025</span>            <span class="keyword">const</span> <span class="keyword">auto</span> path = get_value(op, <span class="stringliteral">&quot;path&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><span class="lineno">24026</span>            <a class="code hl_class" href="classjson__pointer.html">json_pointer</a> ptr(path);</div>
<div class="line"><span class="lineno">24027</span> </div>
<div class="line"><span class="lineno">24028</span>            <span class="keywordflow">switch</span> (get_op(op))</div>
<div class="line"><span class="lineno">24029</span>            {</div>
<div class="line"><span class="lineno">24030</span>                <span class="keywordflow">case</span> patch_operations::add:</div>
<div class="line"><span class="lineno">24031</span>                {</div>
<div class="line"><span class="lineno">24032</span>                    operation_add(ptr, get_value(<span class="stringliteral">&quot;add&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>));</div>
<div class="line"><span class="lineno">24033</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24034</span>                }</div>
<div class="line"><span class="lineno">24035</span> </div>
<div class="line"><span class="lineno">24036</span>                <span class="keywordflow">case</span> patch_operations::remove:</div>
<div class="line"><span class="lineno">24037</span>                {</div>
<div class="line"><span class="lineno">24038</span>                    operation_remove(ptr);</div>
<div class="line"><span class="lineno">24039</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24040</span>                }</div>
<div class="line"><span class="lineno">24041</span> </div>
<div class="line"><span class="lineno">24042</span>                <span class="keywordflow">case</span> patch_operations::replace:</div>
<div class="line"><span class="lineno">24043</span>                {</div>
<div class="line"><span class="lineno">24044</span>                    <span class="comment">// the &quot;path&quot; location must exist - use at()</span></div>
<div class="line"><span class="lineno">24045</span>                    result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(ptr) = get_value(<span class="stringliteral">&quot;replace&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">24046</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24047</span>                }</div>
<div class="line"><span class="lineno">24048</span> </div>
<div class="line"><span class="lineno">24049</span>                <span class="keywordflow">case</span> patch_operations::move:</div>
<div class="line"><span class="lineno">24050</span>                {</div>
<div class="line"><span class="lineno">24051</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> from_path = get_value(<span class="stringliteral">&quot;move&quot;</span>, <span class="stringliteral">&quot;from&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><span class="lineno">24052</span>                    <a class="code hl_class" href="classjson__pointer.html">json_pointer</a> from_ptr(from_path);</div>
<div class="line"><span class="lineno">24053</span> </div>
<div class="line"><span class="lineno">24054</span>                    <span class="comment">// the &quot;from&quot; location must exist - use at()</span></div>
<div class="line"><span class="lineno">24055</span>                    <a class="code hl_class" href="classbasic__json.html">basic_json</a> v = result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(from_ptr);</div>
<div class="line"><span class="lineno">24056</span> </div>
<div class="line"><span class="lineno">24057</span>                    <span class="comment">// The move operation is functionally identical to a</span></div>
<div class="line"><span class="lineno">24058</span>                    <span class="comment">// &quot;remove&quot; operation on the &quot;from&quot; location, followed</span></div>
<div class="line"><span class="lineno">24059</span>                    <span class="comment">// immediately by an &quot;add&quot; operation at the target</span></div>
<div class="line"><span class="lineno">24060</span>                    <span class="comment">// location with the value that was just removed.</span></div>
<div class="line"><span class="lineno">24061</span>                    operation_remove(from_ptr);</div>
<div class="line"><span class="lineno">24062</span>                    operation_add(ptr, v);</div>
<div class="line"><span class="lineno">24063</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24064</span>                }</div>
<div class="line"><span class="lineno">24065</span> </div>
<div class="line"><span class="lineno">24066</span>                <span class="keywordflow">case</span> patch_operations::copy:</div>
<div class="line"><span class="lineno">24067</span>                {</div>
<div class="line"><span class="lineno">24068</span>                    <span class="keyword">const</span> <span class="keyword">auto</span> from_path = get_value(<span class="stringliteral">&quot;copy&quot;</span>, <span class="stringliteral">&quot;from&quot;</span>, <span class="keyword">true</span>).template get&lt;std::string&gt;();</div>
<div class="line"><span class="lineno">24069</span>                    <span class="keyword">const</span> <a class="code hl_class" href="classjson__pointer.html">json_pointer</a> from_ptr(from_path);</div>
<div class="line"><span class="lineno">24070</span> </div>
<div class="line"><span class="lineno">24071</span>                    <span class="comment">// the &quot;from&quot; location must exist - use at()</span></div>
<div class="line"><span class="lineno">24072</span>                    <a class="code hl_class" href="classbasic__json.html">basic_json</a> v = result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(from_ptr);</div>
<div class="line"><span class="lineno">24073</span> </div>
<div class="line"><span class="lineno">24074</span>                    <span class="comment">// The copy is functionally identical to an &quot;add&quot;</span></div>
<div class="line"><span class="lineno">24075</span>                    <span class="comment">// operation at the target location using the value</span></div>
<div class="line"><span class="lineno">24076</span>                    <span class="comment">// specified in the &quot;from&quot; member.</span></div>
<div class="line"><span class="lineno">24077</span>                    operation_add(ptr, v);</div>
<div class="line"><span class="lineno">24078</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24079</span>                }</div>
<div class="line"><span class="lineno">24080</span> </div>
<div class="line"><span class="lineno">24081</span>                <span class="keywordflow">case</span> patch_operations::test:</div>
<div class="line"><span class="lineno">24082</span>                {</div>
<div class="line"><span class="lineno">24083</span>                    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">24084</span>                    JSON_TRY</div>
<div class="line"><span class="lineno">24085</span>                    {</div>
<div class="line"><span class="lineno">24086</span>                        <span class="comment">// check if &quot;value&quot; matches the one at &quot;path&quot;</span></div>
<div class="line"><span class="lineno">24087</span>                        <span class="comment">// the &quot;path&quot; location must exist - use at()</span></div>
<div class="line"><span class="lineno">24088</span>                        success = (result.<a class="code hl_function" href="classbasic__json.html#a603779687f401ad11de45f8397f92296">at</a>(ptr) == get_value(<span class="stringliteral">&quot;test&quot;</span>, <span class="stringliteral">&quot;value&quot;</span>, <span class="keyword">false</span>));</div>
<div class="line"><span class="lineno">24089</span>                    }</div>
<div class="line"><span class="lineno">24090</span>                    JSON_INTERNAL_CATCH (out_of_range&amp;)</div>
<div class="line"><span class="lineno">24091</span>                    {</div>
<div class="line"><span class="lineno">24092</span>                        <span class="comment">// ignore out of range errors: success remains false</span></div>
<div class="line"><span class="lineno">24093</span>                    }</div>
<div class="line"><span class="lineno">24094</span> </div>
<div class="line"><span class="lineno">24095</span>                    <span class="comment">// throw an exception if test fails</span></div>
<div class="line"><span class="lineno">24096</span>                    <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!success))</div>
<div class="line"><span class="lineno">24097</span>                    {</div>
<div class="line"><span class="lineno">24098</span>                        JSON_THROW(other_error::create(501, detail::concat(<span class="stringliteral">&quot;unsuccessful: &quot;</span>, val.dump()), &amp;val));</div>
<div class="line"><span class="lineno">24099</span>                    }</div>
<div class="line"><span class="lineno">24100</span> </div>
<div class="line"><span class="lineno">24101</span>                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">24102</span>                }</div>
<div class="line"><span class="lineno">24103</span> </div>
<div class="line"><span class="lineno">24104</span>                <span class="keywordflow">case</span> patch_operations::invalid:</div>
<div class="line"><span class="lineno">24105</span>                <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">24106</span>                {</div>
<div class="line"><span class="lineno">24107</span>                    <span class="comment">// op must be &quot;add&quot;, &quot;remove&quot;, &quot;replace&quot;, &quot;move&quot;, &quot;copy&quot;, or</span></div>
<div class="line"><span class="lineno">24108</span>                    <span class="comment">// &quot;test&quot;</span></div>
<div class="line"><span class="lineno">24109</span>                    JSON_THROW(<a class="code hl_function" href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">parse_error::create</a>(105, 0, detail::concat(<span class="stringliteral">&quot;operation value &#39;&quot;</span>, op, <span class="stringliteral">&quot;&#39; is invalid&quot;</span>), &amp;val));</div>
<div class="line"><span class="lineno">24110</span>                }</div>
<div class="line"><span class="lineno">24111</span>            }</div>
<div class="line"><span class="lineno">24112</span>        }</div>
<div class="line"><span class="lineno">24113</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a603779687f401ad11de45f8397f92296"><div class="ttname"><a href="classbasic__json.html#a603779687f401ad11de45f8397f92296">basic_json::at</a></div><div class="ttdeci">reference at(size_type idx)</div><div class="ttdoc">access specified array element with bounds checking</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21104">json.hpp:21104</a></div></div>
<div class="ttc" id="aclassdetail_1_1parse__error_html_a07046ea9f33d28f120af188ed674d6df"><div class="ttname"><a href="classdetail_1_1parse__error.html#a07046ea9f33d28f120af188ed674d6df">detail::parse_error::create</a></div><div class="ttdeci">static parse_error create(int id_, const position_t &amp;pos, const std::string &amp;what_arg, BasicJsonContext context)</div><div class="ttdoc">create a parse error exception</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l04411">json.hpp:4411</a></div></div>
<div class="ttc" id="aclassjson__pointer_html"><div class="ttname"><a href="classjson__pointer.html">json_pointer</a></div><div class="ttdoc">JSON Pointer defines a string syntax for identifying a specific value within a JSON document.</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l13716">json.hpp:13717</a></div></div>
<div class="ttc" id="aclassjson__pointer_html_a5c3d08bd0a0e99c3377db33600c68a64"><div class="ttname"><a href="classjson__pointer.html#a5c3d08bd0a0e99c3377db33600c68a64">json_pointer::empty</a></div><div class="ttdeci">bool empty() const noexcept</div><div class="ttdoc">return whether pointer points to the root document</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l13878">json.hpp:13878</a></div></div>
<div class="ttc" id="aclassjson__pointer_html_a662118b470c87a1b564946c2602c49ce"><div class="ttname"><a href="classjson__pointer.html#a662118b470c87a1b564946c2602c49ce">json_pointer::pop_back</a></div><div class="ttdeci">void pop_back()</div><div class="ttdoc">remove last reference token</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l13840">json.hpp:13840</a></div></div>
<div class="ttc" id="aclassjson__pointer_html_aba71e63e4032cfc46dd90aeb09e5cb0f"><div class="ttname"><a href="classjson__pointer.html#aba71e63e4032cfc46dd90aeb09e5cb0f">json_pointer::back</a></div><div class="ttdeci">const string_t &amp; back() const</div><div class="ttdoc">return last reference token</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l13852">json.hpp:13852</a></div></div>
<div class="ttc" id="anamespacedetail_html"><div class="ttname"><a href="namespacedetail.html">detail</a></div><div class="ttdoc">detail namespace with internal helper functions</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l00246">json.hpp:247</a></div></div>
<div class="ttc" id="anamespacedetail_html_abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c"><div class="ttname"><a href="namespacedetail.html#abe7cfa1fd8fa706ff4392bff9d1a8298a9dde360102c103867bd2f45872f1129c">detail::error_handler_t::replace</a></div><div class="ttdeci">@ replace</div><div class="ttdoc">replace invalid UTF-8 sequences with U+FFFD</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9dd9991cbc1c10d35987680038f6359" name="ae9dd9991cbc1c10d35987680038f6359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dd9991cbc1c10d35987680038f6359">&#9670;&#160;</a></span>push_back() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22258">22258</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22259</span>    {</div>
<div class="line"><span class="lineno">22260</span>        <span class="comment">// push_back only works for null objects or arrays</span></div>
<div class="line"><span class="lineno">22261</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!(<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>())))</div>
<div class="line"><span class="lineno">22262</span>        {</div>
<div class="line"><span class="lineno">22263</span>            JSON_THROW(type_error::create(308, detail::concat(<span class="stringliteral">&quot;cannot use push_back() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22264</span>        }</div>
<div class="line"><span class="lineno">22265</span> </div>
<div class="line"><span class="lineno">22266</span>        <span class="comment">// transform null object into an array</span></div>
<div class="line"><span class="lineno">22267</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22268</span>        {</div>
<div class="line"><span class="lineno">22269</span>            m_type = value_t::array;</div>
<div class="line"><span class="lineno">22270</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::array;</div>
<div class="line"><span class="lineno">22271</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22272</span>        }</div>
<div class="line"><span class="lineno">22273</span> </div>
<div class="line"><span class="lineno">22274</span>        <span class="comment">// add element to array (move semantics)</span></div>
<div class="line"><span class="lineno">22275</span>        <span class="keyword">const</span> <span class="keyword">auto</span> old_capacity = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;capacity();</div>
<div class="line"><span class="lineno">22276</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;push_back(std::move(val));</div>
<div class="line"><span class="lineno">22277</span>        set_parent(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;back(), old_capacity);</div>
<div class="line"><span class="lineno">22278</span>        <span class="comment">// if val is moved from, basic_json move constructor marks it null, so we do not call the destructor</span></div>
<div class="line"><span class="lineno">22279</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a102e459f1d163cea963ed6fdda595cd3" name="a102e459f1d163cea963ed6fdda595cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102e459f1d163cea963ed6fdda595cd3">&#9670;&#160;</a></span>push_back() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an array </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22291">22291</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22292</span>    {</div>
<div class="line"><span class="lineno">22293</span>        <span class="comment">// push_back only works for null objects or arrays</span></div>
<div class="line"><span class="lineno">22294</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!(<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>())))</div>
<div class="line"><span class="lineno">22295</span>        {</div>
<div class="line"><span class="lineno">22296</span>            JSON_THROW(type_error::create(308, detail::concat(<span class="stringliteral">&quot;cannot use push_back() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22297</span>        }</div>
<div class="line"><span class="lineno">22298</span> </div>
<div class="line"><span class="lineno">22299</span>        <span class="comment">// transform null object into an array</span></div>
<div class="line"><span class="lineno">22300</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22301</span>        {</div>
<div class="line"><span class="lineno">22302</span>            m_type = value_t::array;</div>
<div class="line"><span class="lineno">22303</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::array;</div>
<div class="line"><span class="lineno">22304</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22305</span>        }</div>
<div class="line"><span class="lineno">22306</span> </div>
<div class="line"><span class="lineno">22307</span>        <span class="comment">// add element to array</span></div>
<div class="line"><span class="lineno">22308</span>        <span class="keyword">const</span> <span class="keyword">auto</span> old_capacity = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;capacity();</div>
<div class="line"><span class="lineno">22309</span>        <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;push_back(val);</div>
<div class="line"><span class="lineno">22310</span>        set_parent(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;back(), old_capacity);</div>
<div class="line"><span class="lineno">22311</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4efb88d640b634b77af5825321e6c4ba" name="a4efb88d640b634b77af5825321e6c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efb88d640b634b77af5825321e6c4ba">&#9670;&#160;</a></span>push_back() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::value_type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22323">22323</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22324</span>    {</div>
<div class="line"><span class="lineno">22325</span>        <span class="comment">// push_back only works for null objects or objects</span></div>
<div class="line"><span class="lineno">22326</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!(<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>() || <a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>())))</div>
<div class="line"><span class="lineno">22327</span>        {</div>
<div class="line"><span class="lineno">22328</span>            JSON_THROW(type_error::create(308, detail::concat(<span class="stringliteral">&quot;cannot use push_back() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22329</span>        }</div>
<div class="line"><span class="lineno">22330</span> </div>
<div class="line"><span class="lineno">22331</span>        <span class="comment">// transform null object into an object</span></div>
<div class="line"><span class="lineno">22332</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22333</span>        {</div>
<div class="line"><span class="lineno">22334</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">22335</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a> = value_t::object;</div>
<div class="line"><span class="lineno">22336</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22337</span>        }</div>
<div class="line"><span class="lineno">22338</span> </div>
<div class="line"><span class="lineno">22339</span>        <span class="comment">// add element to object</span></div>
<div class="line"><span class="lineno">22340</span>        <span class="keyword">auto</span> res = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;insert(val);</div>
<div class="line"><span class="lineno">22341</span>        set_parent(res.first-&gt;second);</div>
<div class="line"><span class="lineno">22342</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adabd8c4eea861419dc2629610a922e97" name="adabd8c4eea861419dc2629610a922e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabd8c4eea861419dc2629610a922e97">&#9670;&#160;</a></span>push_back() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a2063ed828cd027216c549ac48527a562">initializer_list_t</a>&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add an object to an object </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/push_back/">https://json.nlohmann.me/api/basic_json/push_back/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22354">22354</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22355</span>    {</div>
<div class="line"><span class="lineno">22356</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>() &amp;&amp; init.size() == 2 &amp;&amp; (*init.begin())-&gt;is_string())</div>
<div class="line"><span class="lineno">22357</span>        {</div>
<div class="line"><span class="lineno">22358</span>            <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp;&amp; key = init.begin()-&gt;moved_or_copied();</div>
<div class="line"><span class="lineno">22359</span>            <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(<span class="keyword">typename</span> object_t::value_type(</div>
<div class="line"><span class="lineno">22360</span>                          std::move(key.get_ref&lt;<a class="code hl_typedef" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a>&amp;&gt;()), (init.begin() + 1)-&gt;moved_or_copied()));</div>
<div class="line"><span class="lineno">22361</span>        }</div>
<div class="line"><span class="lineno">22362</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22363</span>        {</div>
<div class="line"><span class="lineno">22364</span>            <a class="code hl_function" href="classbasic__json.html#ae9dd9991cbc1c10d35987680038f6359">push_back</a>(<a class="code hl_class" href="classbasic__json.html">basic_json</a>(init));</div>
<div class="line"><span class="lineno">22365</span>        }</div>
<div class="line"><span class="lineno">22366</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9eb8bf73439e55c11983f51de32614b5" name="a9eb8bf73439e55c11983f51de32614b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8bf73439e55c11983f51de32614b5">&#9670;&#160;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the reverse-beginning </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/rbegin/">https://json.nlohmann.me/api/basic_json/rbegin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21993">21993</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21994</span>    {</div>
<div class="line"><span class="lineno">21995</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#aed4f45b1b03cd315b3700dacb22d1fb3">crbegin</a>();</div>
<div class="line"><span class="lineno">21996</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aed4f45b1b03cd315b3700dacb22d1fb3"><div class="ttname"><a href="classbasic__json.html#aed4f45b1b03cd315b3700dacb22d1fb3">basic_json::crbegin</a></div><div class="ttdeci">const_reverse_iterator crbegin() const noexcept</div><div class="ttdoc">returns a const reverse iterator to the last element</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22014">json.hpp:22014</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8c2b82d885e4765ad078f475c777320" name="ac8c2b82d885e4765ad078f475c777320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c2b82d885e4765ad078f475c777320">&#9670;&#160;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the reverse-beginning </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/rbegin/">https://json.nlohmann.me/api/basic_json/rbegin/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21986">21986</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21987</span>    {</div>
<div class="line"><span class="lineno">21988</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a>(<a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>());</div>
<div class="line"><span class="lineno">21989</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_ac639cd1b4238d158286e7e21b5829709"><div class="ttname"><a href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">basic_json::reverse_iterator</a></div><div class="ttdeci">json_reverse_iterator&lt; typename basic_json::iterator &gt; reverse_iterator</div><div class="ttdoc">a reverse iterator for a basic_json container</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19407">json.hpp:19407</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeeda19c8edb0398ba1c04575b077391d" name="aeeda19c8edb0398ba1c04575b077391d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeda19c8edb0398ba1c04575b077391d">&#9670;&#160;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a2aa7d4c7719ab82aa8c77a83642c843f">const_reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the reverse-end </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/rend/">https://json.nlohmann.me/api/basic_json/rend/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22007">22007</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22008</span>    {</div>
<div class="line"><span class="lineno">22009</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a463e1d370bf75906179dce60ad89a1ea">crend</a>();</div>
<div class="line"><span class="lineno">22010</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a463e1d370bf75906179dce60ad89a1ea"><div class="ttname"><a href="classbasic__json.html#a463e1d370bf75906179dce60ad89a1ea">basic_json::crend</a></div><div class="ttdeci">const_reverse_iterator crend() const noexcept</div><div class="ttdoc">returns a const reverse iterator to one before the first</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22021">json.hpp:22021</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf8366e38224d6bb07c9ef7b21d96553" name="aaf8366e38224d6bb07c9ef7b21d96553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8366e38224d6bb07c9ef7b21d96553">&#9670;&#160;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the reverse-end </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/rend/">https://json.nlohmann.me/api/basic_json/rend/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22000">22000</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22001</span>    {</div>
<div class="line"><span class="lineno">22002</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="classbasic__json.html#ac639cd1b4238d158286e7e21b5829709">reverse_iterator</a>(<a class="code hl_function" href="classbasic__json.html#af7ba4755c9131259324caaa166146513">begin</a>());</div>
<div class="line"><span class="lineno">22003</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a696ab4a7073c479bb1ef24c23c3d3d67" name="a696ab4a7073c479bb1ef24c23c3d3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ab4a7073c479bb1ef24c23c3d3d67">&#9670;&#160;</a></span>sax_parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">detail::span_input_adapter &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_format_t&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This function is deprecated since 3.8.0 and will be removed in version 4.0.0 of the library. Please use sax_parse(ptr, ptr + len) instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23287">23287</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23291</span>    {</div>
<div class="line"><span class="lineno">23292</span>        <span class="keyword">auto</span> ia = i.get();</div>
<div class="line"><span class="lineno">23293</span>        <span class="keywordflow">return</span> format == input_format_t::json</div>
<div class="line"><span class="lineno">23294</span>               <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23295</span>               ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><span class="lineno">23296</span>               <span class="comment">// NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)</span></div>
<div class="line"><span class="lineno">23297</span>               : <a class="code hl_class" href="classdetail_1_1binary__reader.html">detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;</a>(std::move(ia), format).<a class="code hl_function" href="classdetail_1_1binary__reader.html#a8e1b5452ae426e1d7b48761859e7f52d">sax_parse</a>(format, sax, strict);</div>
<div class="line"><span class="lineno">23298</span>    }</div>
<div class="ttc" id="aclassdetail_1_1binary__reader_html"><div class="ttname"><a href="classdetail_1_1binary__reader.html">detail::binary_reader</a></div><div class="ttdoc">deserialization of CBOR, MessagePack, and UBJSON values</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l09141">json.hpp:9142</a></div></div>
<div class="ttc" id="aclassdetail_1_1binary__reader_html_a8e1b5452ae426e1d7b48761859e7f52d"><div class="ttname"><a href="classdetail_1_1binary__reader.html#a8e1b5452ae426e1d7b48761859e7f52d">detail::binary_reader::sax_parse</a></div><div class="ttdeci">bool sax_parse(const input_format_t format, json_sax_t *sax_, const bool strict=true, const cbor_tag_handler_t tag_handler=cbor_tag_handler_t::error)</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l09179">json.hpp:9179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2eae76ffa6335685fa38190a18806d55" name="a2eae76ffa6335685fa38190a18806d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae76ffa6335685fa38190a18806d55">&#9670;&#160;</a></span>sax_parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool static SAX bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">InputType &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_format_t&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23253">23253</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23257</span>    {</div>
<div class="line"><span class="lineno">23258</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::forward&lt;InputType&gt;(i));</div>
<div class="line"><span class="lineno">23259</span>        <span class="keywordflow">return</span> format == input_format_t::json</div>
<div class="line"><span class="lineno">23260</span>               ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><span class="lineno">23261</span>               : <a class="code hl_class" href="classdetail_1_1binary__reader.html">detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;</a>(std::move(ia), format).<a class="code hl_function" href="classdetail_1_1binary__reader.html#a8e1b5452ae426e1d7b48761859e7f52d">sax_parse</a>(format, sax, strict);</div>
<div class="line"><span class="lineno">23262</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4e2094d16fe8fd49c20eca61fa88d602" name="a4e2094d16fe8fd49c20eca61fa88d602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2094d16fe8fd49c20eca61fa88d602">&#9670;&#160;</a></span>sax_parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class IteratorType , class SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::sax_parse </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SAX *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input_format_t&#160;</td>
          <td class="paramname"><em>format</em> = <code>input_format_t::json</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_comments</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>generate SAX events </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/sax_parse/">https://json.nlohmann.me/api/basic_json/sax_parse/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23268">23268</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23272</span>    {</div>
<div class="line"><span class="lineno">23273</span>        <span class="keyword">auto</span> ia = detail::input_adapter(std::move(first), std::move(last));</div>
<div class="line"><span class="lineno">23274</span>        <span class="keywordflow">return</span> format == input_format_t::json</div>
<div class="line"><span class="lineno">23275</span>               ? parser(std::move(ia), <span class="keyword">nullptr</span>, <span class="keyword">true</span>, ignore_comments).sax_parse(sax, strict)</div>
<div class="line"><span class="lineno">23276</span>               : <a class="code hl_class" href="classdetail_1_1binary__reader.html">detail::binary_reader&lt;basic_json, decltype(ia), SAX&gt;</a>(std::move(ia), format).<a class="code hl_function" href="classdetail_1_1binary__reader.html#a8e1b5452ae426e1d7b48761859e7f52d">sax_parse</a>(format, sax, strict);</div>
<div class="line"><span class="lineno">23277</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a769537e4631ccd39b5ab3753547a8274" name="a769537e4631ccd39b5ab3753547a8274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769537e4631ccd39b5ab3753547a8274">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html#a883ac4726a370dbf98474944ec0a0acc">size_type</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of elements </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/size/">https://json.nlohmann.me/api/basic_json/size/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22114">22114</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22115</span>    {</div>
<div class="line"><span class="lineno">22116</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">22117</span>        {</div>
<div class="line"><span class="lineno">22118</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">22119</span>            {</div>
<div class="line"><span class="lineno">22120</span>                <span class="comment">// null values are empty</span></div>
<div class="line"><span class="lineno">22121</span>                <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">22122</span>            }</div>
<div class="line"><span class="lineno">22123</span> </div>
<div class="line"><span class="lineno">22124</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">22125</span>            {</div>
<div class="line"><span class="lineno">22126</span>                <span class="comment">// delegate call to array_t::size()</span></div>
<div class="line"><span class="lineno">22127</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array-&gt;size();</div>
<div class="line"><span class="lineno">22128</span>            }</div>
<div class="line"><span class="lineno">22129</span> </div>
<div class="line"><span class="lineno">22130</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">22131</span>            {</div>
<div class="line"><span class="lineno">22132</span>                <span class="comment">// delegate call to object_t::size()</span></div>
<div class="line"><span class="lineno">22133</span>                <span class="keywordflow">return</span> <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;size();</div>
<div class="line"><span class="lineno">22134</span>            }</div>
<div class="line"><span class="lineno">22135</span> </div>
<div class="line"><span class="lineno">22136</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">22137</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">22138</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">22139</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">22140</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">22141</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">22142</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">22143</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">22144</span>            {</div>
<div class="line"><span class="lineno">22145</span>                <span class="comment">// all other types have size 1</span></div>
<div class="line"><span class="lineno">22146</span>                <span class="keywordflow">return</span> 1;</div>
<div class="line"><span class="lineno">22147</span>            }</div>
<div class="line"><span class="lineno">22148</span>        }</div>
<div class="line"><span class="lineno">22149</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af1bc171c2ec496dcc63c9035354d1138" name="af1bc171c2ec496dcc63c9035354d1138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bc171c2ec496dcc63c9035354d1138">&#9670;&#160;</a></span>swap() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a7cf28eb944e7c06aa47f0bc3a9d6f454">array_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22661">22661</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22662</span>    {</div>
<div class="line"><span class="lineno">22663</span>        <span class="comment">// swap only works for arrays</span></div>
<div class="line"><span class="lineno">22664</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a89ea48a4e802ef81783c0c7ce89aa7bb">is_array</a>()))</div>
<div class="line"><span class="lineno">22665</span>        {</div>
<div class="line"><span class="lineno">22666</span>            <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">22667</span>            <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(*(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.array), other);</div>
<div class="line"><span class="lineno">22668</span>        }</div>
<div class="line"><span class="lineno">22669</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22670</span>        {</div>
<div class="line"><span class="lineno">22671</span>            JSON_THROW(type_error::create(310, detail::concat(<span class="stringliteral">&quot;cannot use swap(array_t&amp;) with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22672</span>        }</div>
<div class="line"><span class="lineno">22673</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23296c72c9f837e20cfdc28d8018dd57" name="a23296c72c9f837e20cfdc28d8018dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23296c72c9f837e20cfdc28d8018dd57">&#9670;&#160;</a></span>swap() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aabedd827d4943302a4cf0413956341db">binary_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22709">22709</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22710</span>    {</div>
<div class="line"><span class="lineno">22711</span>        <span class="comment">// swap only works for strings</span></div>
<div class="line"><span class="lineno">22712</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>()))</div>
<div class="line"><span class="lineno">22713</span>        {</div>
<div class="line"><span class="lineno">22714</span>            <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">22715</span>            <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(*(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary), other);</div>
<div class="line"><span class="lineno">22716</span>        }</div>
<div class="line"><span class="lineno">22717</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22718</span>        {</div>
<div class="line"><span class="lineno">22719</span>            JSON_THROW(type_error::create(310, detail::concat(<span class="stringliteral">&quot;cannot use swap(binary_t&amp;) with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22720</span>        }</div>
<div class="line"><span class="lineno">22721</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2061fc20992f76b6fe4a7d2456391b8f" name="a2061fc20992f76b6fe4a7d2456391b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2061fc20992f76b6fe4a7d2456391b8f">&#9670;&#160;</a></span>swap() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a770279b71f788fe3f76411eedf5b1956">object_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22677">22677</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22678</span>    {</div>
<div class="line"><span class="lineno">22679</span>        <span class="comment">// swap only works for objects</span></div>
<div class="line"><span class="lineno">22680</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">22681</span>        {</div>
<div class="line"><span class="lineno">22682</span>            <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">22683</span>            <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(*(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object), other);</div>
<div class="line"><span class="lineno">22684</span>        }</div>
<div class="line"><span class="lineno">22685</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22686</span>        {</div>
<div class="line"><span class="lineno">22687</span>            JSON_THROW(type_error::create(310, detail::concat(<span class="stringliteral">&quot;cannot use swap(object_t&amp;) with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22688</span>        }</div>
<div class="line"><span class="lineno">22689</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a57541a1c736f6ea94fe4a92dd61b3c37" name="a57541a1c736f6ea94fe4a92dd61b3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57541a1c736f6ea94fe4a92dd61b3c37">&#9670;&#160;</a></span>swap() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22632">22632</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22638</span>    {</div>
<div class="line"><span class="lineno">22639</span>        std::swap(m_type, other.m_type);</div>
<div class="line"><span class="lineno">22640</span>        std::swap(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>, other.m_value);</div>
<div class="line"><span class="lineno">22641</span> </div>
<div class="line"><span class="lineno">22642</span>        set_parents();</div>
<div class="line"><span class="lineno">22643</span>        other.set_parents();</div>
<div class="line"><span class="lineno">22644</span>        assert_invariant();</div>
<div class="line"><span class="lineno">22645</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa914de665383b10bdd6265e6b63b8d93" name="aa914de665383b10bdd6265e6b63b8d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa914de665383b10bdd6265e6b63b8d93">&#9670;&#160;</a></span>swap() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a807932caebf0d62abc8642b9d1a2e5ef">string_t</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22693">22693</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22694</span>    {</div>
<div class="line"><span class="lineno">22695</span>        <span class="comment">// swap only works for strings</span></div>
<div class="line"><span class="lineno">22696</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#a3d4378552d27c9f15e4cb4ff4c075c94">is_string</a>()))</div>
<div class="line"><span class="lineno">22697</span>        {</div>
<div class="line"><span class="lineno">22698</span>            <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">22699</span>            <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(*(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.string), other);</div>
<div class="line"><span class="lineno">22700</span>        }</div>
<div class="line"><span class="lineno">22701</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22702</span>        {</div>
<div class="line"><span class="lineno">22703</span>            JSON_THROW(type_error::create(310, detail::concat(<span class="stringliteral">&quot;cannot use swap(string_t&amp;) with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22704</span>        }</div>
<div class="line"><span class="lineno">22705</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a636ae0a887a94436f43f26c94aa1f748" name="a636ae0a887a94436f43f26c94aa1f748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ae0a887a94436f43f26c94aa1f748">&#9670;&#160;</a></span>swap() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">typename binary_t::container_type &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22725">22725</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22726</span>    {</div>
<div class="line"><span class="lineno">22727</span>        <span class="comment">// swap only works for strings</span></div>
<div class="line"><span class="lineno">22728</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#aa25e81e71e2a263c0431f02f3245a8aa">is_binary</a>()))</div>
<div class="line"><span class="lineno">22729</span>        {</div>
<div class="line"><span class="lineno">22730</span>            <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">22731</span>            <a class="code hl_friend" href="classbasic__json.html#aee0ae36cbfb0336832ebc0374c3c7679">swap</a>(*(<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.binary), other);</div>
<div class="line"><span class="lineno">22732</span>        }</div>
<div class="line"><span class="lineno">22733</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">22734</span>        {</div>
<div class="line"><span class="lineno">22735</span>            JSON_THROW(type_error::create(310, detail::concat(<span class="stringliteral">&quot;cannot use swap(binary_t::container_type&amp;) with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22736</span>        }</div>
<div class="line"><span class="lineno">22737</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b222d92f075b0033a76a60ccb36269c" name="a2b222d92f075b0033a76a60ccb36269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b222d92f075b0033a76a60ccb36269c">&#9670;&#160;</a></span>to_bjdata() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23455">23455</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23458</span>    {</div>
<div class="line"><span class="lineno">23459</span>        std::vector&lt;std::uint8_t&gt; result;</div>
<div class="line"><span class="lineno">23460</span>        <a class="code hl_function" href="classbasic__json.html#a2b222d92f075b0033a76a60ccb36269c">to_bjdata</a>(j, result, use_size, use_type);</div>
<div class="line"><span class="lineno">23461</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23462</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a2b222d92f075b0033a76a60ccb36269c"><div class="ttname"><a href="classbasic__json.html#a2b222d92f075b0033a76a60ccb36269c">basic_json::to_bjdata</a></div><div class="ttdeci">static std::vector&lt; std::uint8_t &gt; to_bjdata(const basic_json &amp;j, const bool use_size=false, const bool use_type=false)</div><div class="ttdoc">create a BJData serialization of a given JSON value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23455">json.hpp:23455</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c66ff3a69ef4e4d0d1c136d4226c6af" name="a9c66ff3a69ef4e4d0d1c136d4226c6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c66ff3a69ef4e4d0d1c136d4226c6af">&#9670;&#160;</a></span>to_bjdata() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23474">23474</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23476</span>    {</div>
<div class="line"><span class="lineno">23477</span>        binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">23478</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b4a7117f98423b6d92e48951a7e3c55" name="a9b4a7117f98423b6d92e48951a7e3c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a7117f98423b6d92e48951a7e3c55">&#9670;&#160;</a></span>to_bjdata() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bjdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BJData serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bjdata/">https://json.nlohmann.me/api/basic_json/to_bjdata/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23466">23466</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23468</span>    {</div>
<div class="line"><span class="lineno">23469</span>        binary_writer&lt;std::uint8_t&gt;(o).write_ubjson(j, use_size, use_type, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">23470</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85f418313f92075a0ab72060bfe4de06" name="a85f418313f92075a0ab72060bfe4de06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f418313f92075a0ab72060bfe4de06">&#9670;&#160;</a></span>to_bson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23482">23482</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23483</span>    {</div>
<div class="line"><span class="lineno">23484</span>        std::vector&lt;std::uint8_t&gt; result;</div>
<div class="line"><span class="lineno">23485</span>        <a class="code hl_function" href="classbasic__json.html#a85f418313f92075a0ab72060bfe4de06">to_bson</a>(j, result);</div>
<div class="line"><span class="lineno">23486</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23487</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a85f418313f92075a0ab72060bfe4de06"><div class="ttname"><a href="classbasic__json.html#a85f418313f92075a0ab72060bfe4de06">basic_json::to_bson</a></div><div class="ttdeci">static std::vector&lt; std::uint8_t &gt; to_bson(const basic_json &amp;j)</div><div class="ttdoc">create a BSON serialization of a given JSON value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23482">json.hpp:23482</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a62bb643538ab0e016a2f319e22bf4c4d" name="a62bb643538ab0e016a2f319e22bf4c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bb643538ab0e016a2f319e22bf4c4d">&#9670;&#160;</a></span>to_bson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23498">23498</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23499</span>    {</div>
<div class="line"><span class="lineno">23500</span>        binary_writer&lt;char&gt;(o).write_bson(j);</div>
<div class="line"><span class="lineno">23501</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5ff725ab08638fbc83ed7e3c7c41396" name="ad5ff725ab08638fbc83ed7e3c7c41396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ff725ab08638fbc83ed7e3c7c41396">&#9670;&#160;</a></span>to_bson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_bson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a BSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_bson/">https://json.nlohmann.me/api/basic_json/to_bson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23491">23491</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23492</span>    {</div>
<div class="line"><span class="lineno">23493</span>        binary_writer&lt;std::uint8_t&gt;(o).write_bson(j);</div>
<div class="line"><span class="lineno">23494</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a12a270a8c98f23f838837562ddde18a8" name="a12a270a8c98f23f838837562ddde18a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a270a8c98f23f838837562ddde18a8">&#9670;&#160;</a></span>to_cbor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23382">23382</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23383</span>    {</div>
<div class="line"><span class="lineno">23384</span>        std::vector&lt;std::uint8_t&gt; result;</div>
<div class="line"><span class="lineno">23385</span>        <a class="code hl_function" href="classbasic__json.html#a12a270a8c98f23f838837562ddde18a8">to_cbor</a>(j, result);</div>
<div class="line"><span class="lineno">23386</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23387</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a12a270a8c98f23f838837562ddde18a8"><div class="ttname"><a href="classbasic__json.html#a12a270a8c98f23f838837562ddde18a8">basic_json::to_cbor</a></div><div class="ttdeci">static std::vector&lt; std::uint8_t &gt; to_cbor(const basic_json &amp;j)</div><div class="ttdoc">create a CBOR serialization of a given JSON value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23382">json.hpp:23382</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b49f22c2c0ed2c803c695f328ee5f4f" name="a4b49f22c2c0ed2c803c695f328ee5f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b49f22c2c0ed2c803c695f328ee5f4f">&#9670;&#160;</a></span>to_cbor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23398">23398</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23399</span>    {</div>
<div class="line"><span class="lineno">23400</span>        binary_writer&lt;char&gt;(o).write_cbor(j);</div>
<div class="line"><span class="lineno">23401</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a91e6116b577c4a402d0bf59ceb1ce3b6" name="a91e6116b577c4a402d0bf59ceb1ce3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e6116b577c4a402d0bf59ceb1ce3b6">&#9670;&#160;</a></span>to_cbor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_cbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a CBOR serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_cbor/">https://json.nlohmann.me/api/basic_json/to_cbor/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23391">23391</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23392</span>    {</div>
<div class="line"><span class="lineno">23393</span>        binary_writer&lt;std::uint8_t&gt;(o).write_cbor(j);</div>
<div class="line"><span class="lineno">23394</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d510f5c39b036deb96e61c8bef19f31" name="a4d510f5c39b036deb96e61c8bef19f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d510f5c39b036deb96e61c8bef19f31">&#9670;&#160;</a></span>to_msgpack() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23405">23405</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23406</span>    {</div>
<div class="line"><span class="lineno">23407</span>        std::vector&lt;std::uint8_t&gt; result;</div>
<div class="line"><span class="lineno">23408</span>        <a class="code hl_function" href="classbasic__json.html#a4d510f5c39b036deb96e61c8bef19f31">to_msgpack</a>(j, result);</div>
<div class="line"><span class="lineno">23409</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23410</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a4d510f5c39b036deb96e61c8bef19f31"><div class="ttname"><a href="classbasic__json.html#a4d510f5c39b036deb96e61c8bef19f31">basic_json::to_msgpack</a></div><div class="ttdeci">static std::vector&lt; std::uint8_t &gt; to_msgpack(const basic_json &amp;j)</div><div class="ttdoc">create a MessagePack serialization of a given JSON value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23405">json.hpp:23405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e3ec809212107cb5809c386c5e3dce3" name="a7e3ec809212107cb5809c386c5e3dce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3ec809212107cb5809c386c5e3dce3">&#9670;&#160;</a></span>to_msgpack() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23421">23421</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23422</span>    {</div>
<div class="line"><span class="lineno">23423</span>        binary_writer&lt;char&gt;(o).write_msgpack(j);</div>
<div class="line"><span class="lineno">23424</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad91a270a87e6aec97c18d44aaddf0d33" name="ad91a270a87e6aec97c18d44aaddf0d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91a270a87e6aec97c18d44aaddf0d33">&#9670;&#160;</a></span>to_msgpack() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_msgpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a MessagePack serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_msgpack/">https://json.nlohmann.me/api/basic_json/to_msgpack/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23414">23414</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23415</span>    {</div>
<div class="line"><span class="lineno">23416</span>        binary_writer&lt;std::uint8_t&gt;(o).write_msgpack(j);</div>
<div class="line"><span class="lineno">23417</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74a0e7569fb3170e0151e4aca3f4bf3b" name="a74a0e7569fb3170e0151e4aca3f4bf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a0e7569fb3170e0151e4aca3f4bf3b">&#9670;&#160;</a></span>to_ubjson() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::uint8_t &gt; <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23428">23428</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23431</span>    {</div>
<div class="line"><span class="lineno">23432</span>        std::vector&lt;std::uint8_t&gt; result;</div>
<div class="line"><span class="lineno">23433</span>        <a class="code hl_function" href="classbasic__json.html#a74a0e7569fb3170e0151e4aca3f4bf3b">to_ubjson</a>(j, result, use_size, use_type);</div>
<div class="line"><span class="lineno">23434</span>        <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">23435</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a74a0e7569fb3170e0151e4aca3f4bf3b"><div class="ttname"><a href="classbasic__json.html#a74a0e7569fb3170e0151e4aca3f4bf3b">basic_json::to_ubjson</a></div><div class="ttdeci">static std::vector&lt; std::uint8_t &gt; to_ubjson(const basic_json &amp;j, const bool use_size=false, const bool use_type=false)</div><div class="ttdoc">create a UBJSON serialization of a given JSON value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23428">json.hpp:23428</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a81aecae4901eb995b22ee6abccf94122" name="a81aecae4901eb995b22ee6abccf94122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aecae4901eb995b22ee6abccf94122">&#9670;&#160;</a></span>to_ubjson() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; char &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23447">23447</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23449</span>    {</div>
<div class="line"><span class="lineno">23450</span>        binary_writer&lt;char&gt;(o).write_ubjson(j, use_size, use_type);</div>
<div class="line"><span class="lineno">23451</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7567f6b4b51d3bc1cbe6a80cd6ca9a8" name="ad7567f6b4b51d3bc1cbe6a80cd6ca9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7567f6b4b51d3bc1cbe6a80cd6ca9a8">&#9670;&#160;</a></span>to_ubjson() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::to_ubjson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::output_adapter&lt; std::uint8_t &gt;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_size</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_type</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a UBJSON serialization of a given JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/to_ubjson/">https://json.nlohmann.me/api/basic_json/to_ubjson/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23439">23439</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23441</span>    {</div>
<div class="line"><span class="lineno">23442</span>        binary_writer&lt;std::uint8_t&gt;(o).write_ubjson(j, use_size, use_type);</div>
<div class="line"><span class="lineno">23443</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1338e4eef7282cd57a4a57e034531029" name="a1338e4eef7282cd57a4a57e034531029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1338e4eef7282cd57a4a57e034531029">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type of the JSON value (explicit) </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type/">https://json.nlohmann.me/api/basic_json/type/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l20459">20459</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">20460</span>    {</div>
<div class="line"><span class="lineno">20461</span>        <span class="keywordflow">return</span> m_type;</div>
<div class="line"><span class="lineno">20462</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7528ae3cfe082b3e6280eb5dfab4700b" name="a7528ae3cfe082b3e6280eb5dfab4700b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7528ae3cfe082b3e6280eb5dfab4700b">&#9670;&#160;</a></span>type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">JSON_HEDLEY_RETURNS_NON_NULL const char * <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the type as string </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/type_name/">https://json.nlohmann.me/api/basic_json/type_name/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23329">23329</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23330</span>    {</div>
<div class="line"><span class="lineno">23331</span>        <span class="keywordflow">switch</span> (m_type)</div>
<div class="line"><span class="lineno">23332</span>        {</div>
<div class="line"><span class="lineno">23333</span>            <span class="keywordflow">case</span> value_t::null:</div>
<div class="line"><span class="lineno">23334</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;null&quot;</span>;</div>
<div class="line"><span class="lineno">23335</span>            <span class="keywordflow">case</span> value_t::object:</div>
<div class="line"><span class="lineno">23336</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;object&quot;</span>;</div>
<div class="line"><span class="lineno">23337</span>            <span class="keywordflow">case</span> value_t::array:</div>
<div class="line"><span class="lineno">23338</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;array&quot;</span>;</div>
<div class="line"><span class="lineno">23339</span>            <span class="keywordflow">case</span> value_t::string:</div>
<div class="line"><span class="lineno">23340</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;string&quot;</span>;</div>
<div class="line"><span class="lineno">23341</span>            <span class="keywordflow">case</span> value_t::boolean:</div>
<div class="line"><span class="lineno">23342</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;boolean&quot;</span>;</div>
<div class="line"><span class="lineno">23343</span>            <span class="keywordflow">case</span> value_t::binary:</div>
<div class="line"><span class="lineno">23344</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;binary&quot;</span>;</div>
<div class="line"><span class="lineno">23345</span>            <span class="keywordflow">case</span> value_t::discarded:</div>
<div class="line"><span class="lineno">23346</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;discarded&quot;</span>;</div>
<div class="line"><span class="lineno">23347</span>            <span class="keywordflow">case</span> value_t::number_integer:</div>
<div class="line"><span class="lineno">23348</span>            <span class="keywordflow">case</span> value_t::number_unsigned:</div>
<div class="line"><span class="lineno">23349</span>            <span class="keywordflow">case</span> value_t::number_float:</div>
<div class="line"><span class="lineno">23350</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">23351</span>                <span class="keywordflow">return</span> <span class="stringliteral">&quot;number&quot;</span>;</div>
<div class="line"><span class="lineno">23352</span>        }</div>
<div class="line"><span class="lineno">23353</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a91ef6a13e3205323b67700c3e5e672c9" name="a91ef6a13e3205323b67700c3e5e672c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ef6a13e3205323b67700c3e5e672c9">&#9670;&#160;</a></span>unflatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbasic__json.html">basic_json</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::unflatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unflatten a previously flattened JSON value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/unflatten/">https://json.nlohmann.me/api/basic_json/unflatten/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23830">23830</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23831</span>    {</div>
<div class="line"><span class="lineno">23832</span>        <span class="keywordflow">return</span> json_pointer::unflatten(*<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">23833</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2db7c9bf454f893d156a7396d527873b" name="a2db7c9bf454f893d156a7396d527873b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db7c9bf454f893d156a7396d527873b">&#9670;&#160;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#a8f3470194c24d964e40d9be0b177cbc3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22585">22585</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22586</span>    {</div>
<div class="line"><span class="lineno">22587</span>        <span class="comment">// implicitly convert null value to an empty object</span></div>
<div class="line"><span class="lineno">22588</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classbasic__json.html#a6ed948b2c2e71ce5f5c03b5eeb575df4">is_null</a>())</div>
<div class="line"><span class="lineno">22589</span>        {</div>
<div class="line"><span class="lineno">22590</span>            m_type = value_t::object;</div>
<div class="line"><span class="lineno">22591</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object = create&lt;object_t&gt;();</div>
<div class="line"><span class="lineno">22592</span>            assert_invariant();</div>
<div class="line"><span class="lineno">22593</span>        }</div>
<div class="line"><span class="lineno">22594</span> </div>
<div class="line"><span class="lineno">22595</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">22596</span>        {</div>
<div class="line"><span class="lineno">22597</span>            JSON_THROW(type_error::create(312, detail::concat(<span class="stringliteral">&quot;cannot use update() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22598</span>        }</div>
<div class="line"><span class="lineno">22599</span> </div>
<div class="line"><span class="lineno">22600</span>        <span class="comment">// check if range iterators belong to the same JSON object</span></div>
<div class="line"><span class="lineno">22601</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))</div>
<div class="line"><span class="lineno">22602</span>        {</div>
<div class="line"><span class="lineno">22603</span>            JSON_THROW(invalid_iterator::create(210, <span class="stringliteral">&quot;iterators do not fit&quot;</span>, <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">22604</span>        }</div>
<div class="line"><span class="lineno">22605</span> </div>
<div class="line"><span class="lineno">22606</span>        <span class="comment">// passed iterators must belong to objects</span></div>
<div class="line"><span class="lineno">22607</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_UNLIKELY(!first.m_object-&gt;is_object()))</div>
<div class="line"><span class="lineno">22608</span>        {</div>
<div class="line"><span class="lineno">22609</span>            JSON_THROW(type_error::create(312, detail::concat(<span class="stringliteral">&quot;cannot use update() with &quot;</span>, first.m_object-&gt;type_name()), first.m_object));</div>
<div class="line"><span class="lineno">22610</span>        }</div>
<div class="line"><span class="lineno">22611</span> </div>
<div class="line"><span class="lineno">22612</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = first; it != last; ++it)</div>
<div class="line"><span class="lineno">22613</span>        {</div>
<div class="line"><span class="lineno">22614</span>            <span class="keywordflow">if</span> (merge_objects &amp;&amp; it.value().is_object())</div>
<div class="line"><span class="lineno">22615</span>            {</div>
<div class="line"><span class="lineno">22616</span>                <span class="keyword">auto</span> it2 = <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;find(it.key());</div>
<div class="line"><span class="lineno">22617</span>                <span class="keywordflow">if</span> (it2 != <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;end())</div>
<div class="line"><span class="lineno">22618</span>                {</div>
<div class="line"><span class="lineno">22619</span>                    it2-&gt;second.update(it.value(), <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">22620</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">22621</span>                }</div>
<div class="line"><span class="lineno">22622</span>            }</div>
<div class="line"><span class="lineno">22623</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;operator[](it.key()) = it.value();</div>
<div class="line"><span class="lineno">22624</span><span class="preprocessor">#if JSON_DIAGNOSTICS</span></div>
<div class="line"><span class="lineno">22625</span>            <a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.object-&gt;operator[](it.key()).m_parent = <span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22626</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22627</span>        }</div>
<div class="line"><span class="lineno">22628</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1c13ddcc1eb615dc56ebd7cb44791bd" name="aa1c13ddcc1eb615dc56ebd7cb44791bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c13ddcc1eb615dc56ebd7cb44791bd">&#9670;&#160;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge_objects</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>updates a JSON object from another object, overwriting existing keys </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/update/">https://json.nlohmann.me/api/basic_json/update/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22578">22578</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22579</span>    {</div>
<div class="line"><span class="lineno">22580</span>        <a class="code hl_function" href="classbasic__json.html#aa1c13ddcc1eb615dc56ebd7cb44791bd">update</a>(j.begin(), j.end(), merge_objects);</div>
<div class="line"><span class="lineno">22581</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aa1c13ddcc1eb615dc56ebd7cb44791bd"><div class="ttname"><a href="classbasic__json.html#aa1c13ddcc1eb615dc56ebd7cb44791bd">basic_json::update</a></div><div class="ttdeci">void update(const_reference j, bool merge_objects=false)</div><div class="ttdoc">updates a JSON object from another object, overwriting existing keys</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l22578">json.hpp:22578</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c7141baa06e635fe37736659a9f1631" name="a6c7141baa06e635fe37736659a9f1631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7141baa06e635fe37736659a9f1631">&#9670;&#160;</a></span>value() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class BasicJsonType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21542">21542</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21543</span>    {</div>
<div class="line"><span class="lineno">21544</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">value</a>(ptr.convert(), default_value);</div>
<div class="line"><span class="lineno">21545</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_a3fb507ac4a659d45a9ccdfb67a0646ec"><div class="ttname"><a href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">basic_json::value</a></div><div class="ttdeci">ValueType value(const typename object_t::key_type &amp;key, const ValueType &amp;default_value) const</div><div class="ttdoc">access specified object element with default value</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l21392">json.hpp:21392</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5ea0e7032d5697076d3f2faf318af18" name="aa5ea0e7032d5697076d3f2faf318af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ea0e7032d5697076d3f2faf318af18">&#9670;&#160;</a></span>value() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class BasicJsonType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__basic__json.html">detail::is_basic_json</a>&lt; BasicJsonType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const ::nlohmann::json_pointer&lt; BasicJsonType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21553">21553</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21554</span>    {</div>
<div class="line"><span class="lineno">21555</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classbasic__json.html#a3fb507ac4a659d45a9ccdfb67a0646ec">value</a>(ptr.convert(), std::forward&lt;ValueType&gt;(default_value));</div>
<div class="line"><span class="lineno">21556</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e07f0a0e66b05e7b77b95f623cbfac1" name="a8e07f0a0e66b05e7b77b95f623cbfac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07f0a0e66b05e7b77b95f623cbfac1">&#9670;&#160;</a></span>value() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21493">21493</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21494</span>    {</div>
<div class="line"><span class="lineno">21495</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21496</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21497</span>        {</div>
<div class="line"><span class="lineno">21498</span>            <span class="comment">// if pointer resolves a value, return it or use default value</span></div>
<div class="line"><span class="lineno">21499</span>            JSON_TRY</div>
<div class="line"><span class="lineno">21500</span>            {</div>
<div class="line"><span class="lineno">21501</span>                <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>).template get&lt;ValueType&gt;();</div>
<div class="line"><span class="lineno">21502</span>            }</div>
<div class="line"><span class="lineno">21503</span>            JSON_INTERNAL_CATCH (out_of_range&amp;)</div>
<div class="line"><span class="lineno">21504</span>            {</div>
<div class="line"><span class="lineno">21505</span>                <span class="keywordflow">return</span> default_value;</div>
<div class="line"><span class="lineno">21506</span>            }</div>
<div class="line"><span class="lineno">21507</span>        }</div>
<div class="line"><span class="lineno">21508</span> </div>
<div class="line"><span class="lineno">21509</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21510</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af435aab4d160572776d7e66c3809e4b1" name="af435aab4d160572776d7e66c3809e4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af435aab4d160572776d7e66c3809e4b1">&#9670;&#160;</a></span>value() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbasic__json.html#a7c7e3533ab09b9e9d24a516379961a93">json_pointer</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21518">21518</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21519</span>    {</div>
<div class="line"><span class="lineno">21520</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21521</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21522</span>        {</div>
<div class="line"><span class="lineno">21523</span>            <span class="comment">// if pointer resolves a value, return it or use default value</span></div>
<div class="line"><span class="lineno">21524</span>            JSON_TRY</div>
<div class="line"><span class="lineno">21525</span>            {</div>
<div class="line"><span class="lineno">21526</span>                <span class="keywordflow">return</span> ptr.get_checked(<span class="keyword">this</span>).template get&lt;ReturnType&gt;();</div>
<div class="line"><span class="lineno">21527</span>            }</div>
<div class="line"><span class="lineno">21528</span>            JSON_INTERNAL_CATCH (out_of_range&amp;)</div>
<div class="line"><span class="lineno">21529</span>            {</div>
<div class="line"><span class="lineno">21530</span>                <span class="keywordflow">return</span> std::forward&lt;ValueType&gt;(default_value);</div>
<div class="line"><span class="lineno">21531</span>            }</div>
<div class="line"><span class="lineno">21532</span>        }</div>
<div class="line"><span class="lineno">21533</span> </div>
<div class="line"><span class="lineno">21534</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21535</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3fb507ac4a659d45a9ccdfb67a0646ec" name="a3fb507ac4a659d45a9ccdfb67a0646ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb507ac4a659d45a9ccdfb67a0646ec">&#9670;&#160;</a></span>value() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21392">21392</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21393</span>    {</div>
<div class="line"><span class="lineno">21394</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21395</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21396</span>        {</div>
<div class="line"><span class="lineno">21397</span>            <span class="comment">// if key is found, return value and given default value otherwise</span></div>
<div class="line"><span class="lineno">21398</span>            <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(key);</div>
<div class="line"><span class="lineno">21399</span>            <span class="keywordflow">if</span> (it != <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">21400</span>            {</div>
<div class="line"><span class="lineno">21401</span>                <span class="keywordflow">return</span> it-&gt;template get&lt;ValueType&gt;();</div>
<div class="line"><span class="lineno">21402</span>            }</div>
<div class="line"><span class="lineno">21403</span> </div>
<div class="line"><span class="lineno">21404</span>            <span class="keywordflow">return</span> default_value;</div>
<div class="line"><span class="lineno">21405</span>        }</div>
<div class="line"><span class="lineno">21406</span> </div>
<div class="line"><span class="lineno">21407</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21408</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1460a0f28bedca9050f2259ec6bf86e6" name="a1460a0f28bedca9050f2259ec6bf86e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460a0f28bedca9050f2259ec6bf86e6">&#9670;&#160;</a></span>value() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; !<a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const typename object_t::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21417">21417</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21418</span>    {</div>
<div class="line"><span class="lineno">21419</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21420</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21421</span>        {</div>
<div class="line"><span class="lineno">21422</span>            <span class="comment">// if key is found, return value and given default value otherwise</span></div>
<div class="line"><span class="lineno">21423</span>            <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(key);</div>
<div class="line"><span class="lineno">21424</span>            <span class="keywordflow">if</span> (it != <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">21425</span>            {</div>
<div class="line"><span class="lineno">21426</span>                <span class="keywordflow">return</span> it-&gt;template get&lt;ReturnType&gt;();</div>
<div class="line"><span class="lineno">21427</span>            }</div>
<div class="line"><span class="lineno">21428</span> </div>
<div class="line"><span class="lineno">21429</span>            <span class="keywordflow">return</span> std::forward&lt;ValueType&gt;(default_value);</div>
<div class="line"><span class="lineno">21430</span>        }</div>
<div class="line"><span class="lineno">21431</span> </div>
<div class="line"><span class="lineno">21432</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21433</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a58469bce489ece80e50e7ed59fa09484" name="a58469bce489ece80e50e7ed59fa09484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58469bce489ece80e50e7ed59fa09484">&#9670;&#160;</a></span>value() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ValueType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ValueType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21443">21443</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21444</span>    {</div>
<div class="line"><span class="lineno">21445</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21446</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21447</span>        {</div>
<div class="line"><span class="lineno">21448</span>            <span class="comment">// if key is found, return value and given default value otherwise</span></div>
<div class="line"><span class="lineno">21449</span>            <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21450</span>            <span class="keywordflow">if</span> (it != <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">21451</span>            {</div>
<div class="line"><span class="lineno">21452</span>                <span class="keywordflow">return</span> it-&gt;template get&lt;ValueType&gt;();</div>
<div class="line"><span class="lineno">21453</span>            }</div>
<div class="line"><span class="lineno">21454</span> </div>
<div class="line"><span class="lineno">21455</span>            <span class="keywordflow">return</span> default_value;</div>
<div class="line"><span class="lineno">21456</span>        }</div>
<div class="line"><span class="lineno">21457</span> </div>
<div class="line"><span class="lineno">21458</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21459</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac7d24993dea7dcd5442465e43b0554cb" name="ac7d24993dea7dcd5442465e43b0554cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d24993dea7dcd5442465e43b0554cb">&#9670;&#160;</a></span>value() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ValueType , class KeyType , class ReturnType  = typename value_return_type&lt;ValueType&gt;::type, detail::enable_if_t&lt; <a class="el" href="structdetail_1_1is__transparent.html">detail::is_transparent</a>&lt; <a class="el" href="classbasic__json.html#a7866de66dd6c55590efa7cf0ef79e74f">object_comparator_t</a> &gt;::value &amp;&amp;!detail::is_json_pointer&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__comparable.html">is_comparable_with_object_key</a>&lt; KeyType &gt;::value &amp;&amp;<a class="el" href="structdetail_1_1is__getable.html">detail::is_getable</a>&lt; basic_json_t, ReturnType &gt;::value &amp;&amp;!std::is_same&lt; <a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">value_t</a>, detail::uncvref_t&lt; ValueType &gt; &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::value </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access specified object element via JSON Pointer with default value </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/value/">https://json.nlohmann.me/api/basic_json/value/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l21470">21470</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">21471</span>    {</div>
<div class="line"><span class="lineno">21472</span>        <span class="comment">// value only works for objects</span></div>
<div class="line"><span class="lineno">21473</span>        <span class="keywordflow">if</span> (JSON_HEDLEY_LIKELY(<a class="code hl_function" href="classbasic__json.html#af758a912346776b086abb82487b1d73b">is_object</a>()))</div>
<div class="line"><span class="lineno">21474</span>        {</div>
<div class="line"><span class="lineno">21475</span>            <span class="comment">// if key is found, return value and given default value otherwise</span></div>
<div class="line"><span class="lineno">21476</span>            <span class="keyword">const</span> <span class="keyword">auto</span> it = <a class="code hl_function" href="classbasic__json.html#a8ed11f83edce392fd94659b1102d078e">find</a>(std::forward&lt;KeyType&gt;(key));</div>
<div class="line"><span class="lineno">21477</span>            <span class="keywordflow">if</span> (it != <a class="code hl_function" href="classbasic__json.html#a06e303bfaafda414b4b5821384501bc1">end</a>())</div>
<div class="line"><span class="lineno">21478</span>            {</div>
<div class="line"><span class="lineno">21479</span>                <span class="keywordflow">return</span> it-&gt;template get&lt;ReturnType&gt;();</div>
<div class="line"><span class="lineno">21480</span>            }</div>
<div class="line"><span class="lineno">21481</span> </div>
<div class="line"><span class="lineno">21482</span>            <span class="keywordflow">return</span> std::forward&lt;ValueType&gt;(default_value);</div>
<div class="line"><span class="lineno">21483</span>        }</div>
<div class="line"><span class="lineno">21484</span> </div>
<div class="line"><span class="lineno">21485</span>        JSON_THROW(type_error::create(306, detail::concat(<span class="stringliteral">&quot;cannot use value() with &quot;</span>, <a class="code hl_function" href="classbasic__json.html#a7528ae3cfe082b3e6280eb5dfab4700b">type_name</a>()), <span class="keyword">this</span>));</div>
<div class="line"><span class="lineno">21486</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa226ed5103dfd10e27e562d35a3a106b" name="aa226ed5103dfd10e27e562d35a3a106b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa226ed5103dfd10e27e562d35a3a106b">&#9670;&#160;</a></span>::nlohmann::detail::binary_reader</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType , typename SAX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::binary_reader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19291">19291</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a69d491bbda88ade6d3c7a2b11309e8bf" name="a69d491bbda88ade6d3c7a2b11309e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d491bbda88ade6d3c7a2b11309e8bf">&#9670;&#160;</a></span>::nlohmann::detail::binary_writer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename CharType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::binary_writer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19289">19289</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abdcb15d025676b4d3db0f32a50f4393f" name="abdcb15d025676b4d3db0f32a50f4393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcb15d025676b4d3db0f32a50f4393f">&#9670;&#160;</a></span>::nlohmann::detail::exception</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::exception</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19296">19296</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a842e5c7ca096025c18b11e715d3401f4" name="a842e5c7ca096025c18b11e715d3401f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842e5c7ca096025c18b11e715d3401f4">&#9670;&#160;</a></span>::nlohmann::detail::iter_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::iter_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19287">19287</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a95574da8d12905ea99dc348934c837da" name="a95574da8d12905ea99dc348934c837da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95574da8d12905ea99dc348934c837da">&#9670;&#160;</a></span>::nlohmann::detail::json_sax_dom_callback_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::json_sax_dom_callback_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19295">19295</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a47aabb1eceae32e8a6e8e7f0ff34be60" name="a47aabb1eceae32e8a6e8e7f0ff34be60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aabb1eceae32e8a6e8e7f0ff34be60">&#9670;&#160;</a></span>::nlohmann::detail::json_sax_dom_parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::json_sax_dom_parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19293">19293</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="ac8f3125911eb018ef4ab00d879487baf" name="ac8f3125911eb018ef4ab00d879487baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f3125911eb018ef4ab00d879487baf">&#9670;&#160;</a></span>::nlohmann::detail::parser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename BasicJsonType , typename InputType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::detail::parser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19284">19284</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a43f901b14cf3f7135269b0c75c9ac233" name="a43f901b14cf3f7135269b0c75c9ac233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f901b14cf3f7135269b0c75c9ac233">&#9670;&#160;</a></span>::nlohmann::json_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::nlohmann::json_pointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19279">19279</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="a6275ed57bae6866cdf5db5370a7ad47c" name="a6275ed57bae6866cdf5db5370a7ad47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6275ed57bae6866cdf5db5370a7ad47c">&#9670;&#160;</a></span>detail::external_constructor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacedetail.html#a917c3efabea8a20dc72d9ae2c673d632">detail::value_t</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structdetail_1_1external__constructor.html">detail::external_constructor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l19276">19276</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="af9907af448f7ff794120033e132025f6" name="af9907af448f7ff794120033e132025f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9907af448f7ff794120033e132025f6">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>This stream operator is deprecated since 3.0.0 and will be removed in version 4.0.0 of the library. Please use <a class="el" href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d" title="deserialize from stream">operator&gt;&gt;(std::istream&amp;, basic_json&amp;)</a> instead; that is, replace calls like <code>j &lt;&lt; i;</code> with <code>i &gt;&gt; j;</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23307">23307</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23308</span>    {</div>
<div class="line"><span class="lineno">23309</span>        <span class="keywordflow">return</span> <a class="code hl_friend" href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d">operator&gt;&gt;</a>(i, j);</div>
<div class="line"><span class="lineno">23310</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_aea0de29387d532e0bc5f2475cb83995d"><div class="ttname"><a href="classbasic__json.html#aea0de29387d532e0bc5f2475cb83995d">basic_json::operator&gt;&gt;</a></div><div class="ttdeci">friend std::istream &amp; operator&gt;&gt;(std::istream &amp;i, basic_json &amp;j)</div><div class="ttdoc">deserialize from stream</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l23314">json.hpp:23314</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea0de29387d532e0bc5f2475cb83995d" name="aea0de29387d532e0bc5f2475cb83995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0de29387d532e0bc5f2475cb83995d">&#9670;&#160;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize from stream </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/operator_gtgt/">https://json.nlohmann.me/api/basic_json/operator_gtgt/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23314">23314</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23315</span>    {</div>
<div class="line"><span class="lineno">23316</span>        parser(detail::input_adapter(i)).parse(<span class="keyword">false</span>, j);</div>
<div class="line"><span class="lineno">23317</span>        <span class="keywordflow">return</span> i;</div>
<div class="line"><span class="lineno">23318</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aee0ae36cbfb0336832ebc0374c3c7679" name="aee0ae36cbfb0336832ebc0374c3c7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0ae36cbfb0336832ebc0374c3c7679">&#9670;&#160;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbasic__json.html#aa95f366d506aca733799e4c310927b5d">reference</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>exchanges the values </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://json.nlohmann.me/api/basic_json/swap/">https://json.nlohmann.me/api/basic_json/swap/</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22649">22649</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22655</span>    {</div>
<div class="line"><span class="lineno">22656</span>        left.swap(right);</div>
<div class="line"><span class="lineno">22657</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7e8bca0d3d745150dbaae538443bb626" name="a7e8bca0d3d745150dbaae538443bb626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8bca0d3d745150dbaae538443bb626">&#9670;&#160;</a></span>__pad3__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::__pad3__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22821">22821</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="aba63131a6c69e3f5121632d496c9b708" name="aba63131a6c69e3f5121632d496c9b708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba63131a6c69e3f5121632d496c9b708">&#9670;&#160;</a></span>__pad4__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::__pad4__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23356">23356</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<a id="abe6a2b3e624ac8772519963bcfb8fb56" name="abe6a2b3e624ac8772519963bcfb8fb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6a2b3e624ac8772519963bcfb8fb56">&#9670;&#160;</a></span>inverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> bool <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::inverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22827">22827</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">22828</span>    {</div>
<div class="line"><span class="lineno">22829</span>        <span class="keywordflow">if</span> ((lhs.is_number_float() &amp;&amp; std::isnan(lhs.m_value.number_float) &amp;&amp; rhs.<a class="code hl_function" href="classbasic__json.html#ab84294fe5d1a2822e2f67685f6e8c735">is_number</a>())</div>
<div class="line"><span class="lineno">22830</span>                || (rhs.<a class="code hl_function" href="classbasic__json.html#aa8c885a9182fd22b05826ab2a9548f60">is_number_float</a>() &amp;&amp; std::isnan(rhs.<a class="code hl_variable" href="classbasic__json.html#a34bc6074bd3f9ac2bdab12ebc02d70f5">m_value</a>.number_float) &amp;&amp; lhs.is_number()))</div>
<div class="line"><span class="lineno">22831</span>        {</div>
<div class="line"><span class="lineno">22832</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">22833</span>        }</div>
<div class="line"><span class="lineno">22834</span><span class="preprocessor">#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</span></div>
<div class="line"><span class="lineno">22835</span>        <span class="keywordflow">return</span> (lhs.is_discarded() || rhs.<a class="code hl_function" href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">is_discarded</a>()) &amp;&amp; !inverse;</div>
<div class="line"><span class="lineno">22836</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">22837</span>        <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span><span class="keyword">&gt;</span>(inverse);</div>
<div class="line"><span class="lineno">22838</span>        <span class="keywordflow">return</span> lhs.<a class="code hl_function" href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">is_discarded</a>() || rhs.<a class="code hl_function" href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">is_discarded</a>();</div>
<div class="line"><span class="lineno">22839</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22840</span>    }</div>
<div class="line"><span class="lineno">22841</span> </div>
<div class="line"><span class="lineno">22842</span>  <span class="keyword">private</span>:</div>
<div class="line"><span class="lineno">22843</span>    <span class="keywordtype">bool</span> compares_unordered(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs, <span class="keywordtype">bool</span> inverse = <span class="keyword">false</span>) const noexcept</div>
<div class="line"><span class="lineno">22844</span>    {</div>
<div class="line"><span class="lineno">22845</span>        <span class="keywordflow">return</span> compares_unordered(*<span class="keyword">this</span>, rhs, inverse);</div>
<div class="line"><span class="lineno">22846</span>    }</div>
<div class="line"><span class="lineno">22847</span> </div>
<div class="line"><span class="lineno">22848</span>  <span class="keyword">public</span>:</div>
<div class="line"><span class="lineno">22849</span><span class="preprocessor">#if JSON_HAS_THREE_WAY_COMPARISON</span></div>
<div class="line"><span class="lineno">22852</span>    <span class="keywordtype">bool</span> operator==(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22853</span>    {</div>
<div class="line"><span class="lineno">22854</span><span class="preprocessor">#ifdef __GNUC__</span></div>
<div class="line"><span class="lineno">22855</span><span class="preprocessor">#pragma GCC diagnostic push</span></div>
<div class="line"><span class="lineno">22856</span><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;</span></div>
<div class="line"><span class="lineno">22857</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22858</span>        <a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> lhs = *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22859</span>        JSON_IMPLEMENT_OPERATOR( ==, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</div>
<div class="line"><span class="lineno">22860</span><span class="preprocessor">#ifdef __GNUC__</span></div>
<div class="line"><span class="lineno">22861</span><span class="preprocessor">#pragma GCC diagnostic pop</span></div>
<div class="line"><span class="lineno">22862</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22863</span>    }</div>
<div class="line"><span class="lineno">22864</span> </div>
<div class="line"><span class="lineno">22867</span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ScalarType&gt;</div>
<div class="line"><span class="lineno">22868</span>    <span class="keyword">requires</span> std::is_scalar_v&lt;ScalarType&gt;</div>
<div class="line"><span class="lineno">22869</span>    <span class="keywordtype">bool</span> operator==(ScalarType rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22870</span>    {</div>
<div class="line"><span class="lineno">22871</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span> == <a class="code hl_class" href="classbasic__json.html">basic_json</a>(rhs);</div>
<div class="line"><span class="lineno">22872</span>    }</div>
<div class="line"><span class="lineno">22873</span> </div>
<div class="line"><span class="lineno">22876</span>    <span class="keywordtype">bool</span> operator!=(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22877</span>    {</div>
<div class="line"><span class="lineno">22878</span>        <span class="keywordflow">if</span> (compares_unordered(rhs, <span class="keyword">true</span>))</div>
<div class="line"><span class="lineno">22879</span>        {</div>
<div class="line"><span class="lineno">22880</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">22881</span>        }</div>
<div class="line"><span class="lineno">22882</span>        <span class="keywordflow">return</span> !operator==(rhs);</div>
<div class="line"><span class="lineno">22883</span>    }</div>
<div class="line"><span class="lineno">22884</span> </div>
<div class="line"><span class="lineno">22887</span>    std::partial_ordering operator&lt;=&gt;(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="comment">// *NOPAD*</span></div>
<div class="line"><span class="lineno">22888</span>    {</div>
<div class="line"><span class="lineno">22889</span>        <a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> lhs = *<span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">22890</span>        <span class="comment">// default_result is used if we cannot compare values. In that case,</span></div>
<div class="line"><span class="lineno">22891</span>        <span class="comment">// we compare types.</span></div>
<div class="line"><span class="lineno">22892</span>        JSON_IMPLEMENT_OPERATOR(&lt;=&gt;, <span class="comment">// *NOPAD*</span></div>
<div class="line"><span class="lineno">22893</span>                                std::partial_ordering::equivalent,</div>
<div class="line"><span class="lineno">22894</span>                                std::partial_ordering::unordered,</div>
<div class="line"><span class="lineno">22895</span>                                lhs_type &lt;=&gt; rhs_type) <span class="comment">// *NOPAD*</span></div>
<div class="line"><span class="lineno">22896</span>    }</div>
<div class="line"><span class="lineno">22897</span> </div>
<div class="line"><span class="lineno">22900</span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ScalarType&gt;</div>
<div class="line"><span class="lineno">22901</span>    <span class="keyword">requires</span> std::is_scalar_v&lt;ScalarType&gt;</div>
<div class="line"><span class="lineno">22902</span>    std::partial_ordering operator&lt;=&gt;(ScalarType rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="comment">// *NOPAD*</span></div>
<div class="line"><span class="lineno">22903</span>    {</div>
<div class="line"><span class="lineno">22904</span>        <span class="keywordflow">return</span> *this &lt;=&gt; <a class="code hl_class" href="classbasic__json.html">basic_json</a>(rhs); <span class="comment">// *NOPAD*</span></div>
<div class="line"><span class="lineno">22905</span>    }</div>
<div class="line"><span class="lineno">22906</span> </div>
<div class="line"><span class="lineno">22907</span><span class="preprocessor">#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON</span></div>
<div class="line"><span class="lineno">22908</span>    <span class="comment">// all operators that are computed as an odd number of inverses of others</span></div>
<div class="line"><span class="lineno">22909</span>    <span class="comment">// need to be overloaded to emulate the legacy comparison behavior</span></div>
<div class="line"><span class="lineno">22910</span> </div>
<div class="line"><span class="lineno">22913</span>    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)</div>
<div class="line"><span class="lineno">22914</span>    <span class="keywordtype">bool</span> operator&lt;=(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22915</span>    {</div>
<div class="line"><span class="lineno">22916</span>        <span class="keywordflow">if</span> (compares_unordered(rhs, <span class="keyword">true</span>))</div>
<div class="line"><span class="lineno">22917</span>        {</div>
<div class="line"><span class="lineno">22918</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">22919</span>        }</div>
<div class="line"><span class="lineno">22920</span>        <span class="keywordflow">return</span> !(rhs &lt; *<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">22921</span>    }</div>
<div class="line"><span class="lineno">22922</span> </div>
<div class="line"><span class="lineno">22925</span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ScalarType&gt;</div>
<div class="line"><span class="lineno">22926</span>    <span class="keyword">requires</span> std::is_scalar_v&lt;ScalarType&gt;</div>
<div class="line"><span class="lineno">22927</span>    <span class="keywordtype">bool</span> operator&lt;=(ScalarType rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22928</span>    {</div>
<div class="line"><span class="lineno">22929</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span> &lt;= <a class="code hl_class" href="classbasic__json.html">basic_json</a>(rhs);</div>
<div class="line"><span class="lineno">22930</span>    }</div>
<div class="line"><span class="lineno">22931</span> </div>
<div class="line"><span class="lineno">22934</span>    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)</div>
<div class="line"><span class="lineno">22935</span>    <span class="keywordtype">bool</span> operator&gt;=(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22936</span>    {</div>
<div class="line"><span class="lineno">22937</span>        <span class="keywordflow">if</span> (compares_unordered(rhs, <span class="keyword">true</span>))</div>
<div class="line"><span class="lineno">22938</span>        {</div>
<div class="line"><span class="lineno">22939</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">22940</span>        }</div>
<div class="line"><span class="lineno">22941</span>        <span class="keywordflow">return</span> !(*<span class="keyword">this</span> &lt; rhs);</div>
<div class="line"><span class="lineno">22942</span>    }</div>
<div class="line"><span class="lineno">22943</span> </div>
<div class="line"><span class="lineno">22946</span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ScalarType&gt;</div>
<div class="line"><span class="lineno">22947</span>    <span class="keyword">requires</span> std::is_scalar_v&lt;ScalarType&gt;</div>
<div class="line"><span class="lineno">22948</span>    <span class="keywordtype">bool</span> operator&gt;=(ScalarType rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22949</span>    {</div>
<div class="line"><span class="lineno">22950</span>        <span class="keywordflow">return</span> *<span class="keyword">this</span> &gt;= <a class="code hl_class" href="classbasic__json.html">basic_json</a>(rhs);</div>
<div class="line"><span class="lineno">22951</span>    }</div>
<div class="line"><span class="lineno">22952</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22953</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">22956</span>    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> lhs, <a class="code hl_typedef" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> rhs) <span class="keyword">noexcept</span></div>
<div class="line"><span class="lineno">22957</span>    {</div>
<div class="line"><span class="lineno">22958</span><span class="preprocessor">#ifdef __GNUC__</span></div>
<div class="line"><span class="lineno">22959</span><span class="preprocessor">#pragma GCC diagnostic push</span></div>
<div class="line"><span class="lineno">22960</span><span class="preprocessor">#pragma GCC diagnostic ignored &quot;-Wfloat-equal&quot;</span></div>
<div class="line"><span class="lineno">22961</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22962</span>        JSON_IMPLEMENT_OPERATOR( ==, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>)</div>
<div class="line"><span class="lineno">22963</span><span class="preprocessor">#ifdef __GNUC__</span></div>
<div class="line"><span class="lineno">22964</span><span class="preprocessor">#pragma GCC diagnostic pop</span></div>
<div class="line"><span class="lineno">22965</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">22966</span>    }</div>
<div class="ttc" id="aclassbasic__json_html_abcc7082bb9fa07704c659f6be7c41bc9"><div class="ttname"><a href="classbasic__json.html#abcc7082bb9fa07704c659f6be7c41bc9">basic_json::is_discarded</a></div><div class="ttdeci">constexpr bool is_discarded() const noexcept</div><div class="ttdoc">return whether value is discarded</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l20550">json.hpp:20550</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ac9d32cf719260c22b33bab670cd5602b"><div class="ttname"><a href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">basic_json::const_reference</a></div><div class="ttdeci">const value_type &amp; const_reference</div><div class="ttdoc">the type of an element const reference</div><div class="ttdef"><b>Definition</b> <a href="json_8hpp_source.html#l19387">json.hpp:19387</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a34bc6074bd3f9ac2bdab12ebc02d70f5" name="a34bc6074bd3f9ac2bdab12ebc02d70f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34bc6074bd3f9ac2bdab12ebc02d70f5">&#9670;&#160;</a></span>m_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">json_value <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::m_value = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the value of the current element </p>

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l23365">23365</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">23365</span>{};</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac83f2e1cec130719f862008b9e16acee" name="ac83f2e1cec130719f862008b9e16acee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83f2e1cec130719f862008b9e16acee">&#9670;&#160;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class ObjectType = std::map, template&lt; typename U, typename... Args &gt; class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template&lt; typename U &gt; class AllocatorType = std::allocator, template&lt; typename T, typename SFINAE=void &gt; class JSONSerializer = adl_serializer, class BinaryType  = std::vector&lt;std::uint8_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">JSON_PRIVATE_UNLESS_TESTED <a class="el" href="classbasic__json.html#ac9d32cf719260c22b33bab670cd5602b">const_reference</a> <a class="el" href="classbasic__json.html">basic_json</a>&lt; ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType &gt;::rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="json_8hpp_source.html#l22827">22827</a> of file <a class="el" href="json_8hpp_source.html">json.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>event_detector_db_recording_plugin/include/nlohmann/<a class="el" href="json_8hpp_source.html">json.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
